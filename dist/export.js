/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/export.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/M2M5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/assertThisInitialized.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcz9jOTczIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/asyncToGenerator.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzPzk3MGIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/classCallCheck.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzPzViYzMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/createClass.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzPzM2YzYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/getPrototypeOf.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzP2VkNmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/inherits.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _typeof = __webpack_require__(/*! ../helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcz82YjU4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzPzRhNGIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/setPrototypeOf.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/NzAzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/YTM0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/styles.less":
/*!******************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/styles.less ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".bbox_plus_info_text {\\n  text-shadow: 2px 2px 2px grey;\\n}\\n/* The alert message box */\\n.bbox_plus_flash_message {\\n  position: fixed;\\n  top: 200px;\\n  left: 20px;\\n  width: 200px;\\n  display: block;\\n  z-index: 9999;\\n  padding: 10px;\\n  border-radius: 6px;\\n  color: white;\\n  background: rgba(244, 67, 54, 0.8);\\n  border: 2px solid red;\\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7);\\n}\\n.bbox_plus_flash_message_type_info {\\n  color: #31708f;\\n  background: rgba(217, 237, 247, 0.9);\\n  border-color: #c6dbe6;\\n}\\n.bbox_plus_flash_message_type_success {\\n  color: darkgreen;\\n  background: rgba(144, 238, 144, 0.9);\\n  border: darkgreen;\\n}\\n.bbox_plus_flash_message_type_warn {\\n  color: #9F6000;\\n  border-color: #9F6000;\\n  background: rgba(254, 239, 179, 0.9);\\n}\\n.bbox_plus_flash_message_type_error {\\n  color: #D8000C;\\n  background: rgba(255, 186, 186, 0.9);\\n  border-color: red;\\n}\\n/* The close button */\\n.bbox_plus_flash_message_closebtn {\\n  margin-left: 15px;\\n  color: black;\\n  font-weight: bold;\\n  float: right;\\n  font-size: 22px;\\n  line-height: 20px;\\n  cursor: pointer;\\n  transition: 0.3s;\\n}\\n.bbox_plus_flash_message_closebtn:hover {\\n  color: black;\\n  font-size: 27px;\\n}\\n.bbox_plus_download_link {\\n  font-weight: bold;\\n}\\n.bbox_plus_button,\\n.bbox_plus button {\\n  cursor: pointer;\\n}\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9zdHlsZXMubGVzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZXMubGVzcz84YjMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYmJveF9wbHVzX2luZm9fdGV4dCB7XFxuICB0ZXh0LXNoYWRvdzogMnB4IDJweCAycHggZ3JleTtcXG59XFxuLyogVGhlIGFsZXJ0IG1lc3NhZ2UgYm94ICovXFxuLmJib3hfcGx1c19mbGFzaF9tZXNzYWdlIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMjAwcHg7XFxuICBsZWZ0OiAyMHB4O1xcbiAgd2lkdGg6IDIwMHB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB6LWluZGV4OiA5OTk5O1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDZweDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjQ0LCA2NywgNTQsIDAuOCk7XFxuICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XFxuICBib3gtc2hhZG93OiBpbnNldCAwIDFweCAwIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KTtcXG59XFxuLmJib3hfcGx1c19mbGFzaF9tZXNzYWdlX3R5cGVfaW5mbyB7XFxuICBjb2xvcjogIzMxNzA4ZjtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjE3LCAyMzcsIDI0NywgMC45KTtcXG4gIGJvcmRlci1jb2xvcjogI2M2ZGJlNjtcXG59XFxuLmJib3hfcGx1c19mbGFzaF9tZXNzYWdlX3R5cGVfc3VjY2VzcyB7XFxuICBjb2xvcjogZGFya2dyZWVuO1xcbiAgYmFja2dyb3VuZDogcmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjkpO1xcbiAgYm9yZGVyOiBkYXJrZ3JlZW47XFxufVxcbi5iYm94X3BsdXNfZmxhc2hfbWVzc2FnZV90eXBlX3dhcm4ge1xcbiAgY29sb3I6ICM5RjYwMDA7XFxuICBib3JkZXItY29sb3I6ICM5RjYwMDA7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NCwgMjM5LCAxNzksIDAuOSk7XFxufVxcbi5iYm94X3BsdXNfZmxhc2hfbWVzc2FnZV90eXBlX2Vycm9yIHtcXG4gIGNvbG9yOiAjRDgwMDBDO1xcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDE4NiwgMTg2LCAwLjkpO1xcbiAgYm9yZGVyLWNvbG9yOiByZWQ7XFxufVxcbi8qIFRoZSBjbG9zZSBidXR0b24gKi9cXG4uYmJveF9wbHVzX2ZsYXNoX21lc3NhZ2VfY2xvc2VidG4ge1xcbiAgbWFyZ2luLWxlZnQ6IDE1cHg7XFxuICBjb2xvcjogYmxhY2s7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGZsb2F0OiByaWdodDtcXG4gIGZvbnQtc2l6ZTogMjJweDtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgdHJhbnNpdGlvbjogMC4zcztcXG59XFxuLmJib3hfcGx1c19mbGFzaF9tZXNzYWdlX2Nsb3NlYnRuOmhvdmVyIHtcXG4gIGNvbG9yOiBibGFjaztcXG4gIGZvbnQtc2l6ZTogMjdweDtcXG59XFxuLmJib3hfcGx1c19kb3dubG9hZF9saW5rIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4uYmJveF9wbHVzX2J1dHRvbixcXG4uYmJveF9wbHVzIGJ1dHRvbiB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/styles.less\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8yNGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/deeks/src/deeks.js":
/*!*****************************************!*\
  !*** ./node_modules/deeks/src/deeks.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst _ = __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js\");\n\nmodule.exports = {\n    deepKeys: deepKeys,\n    deepKeysFromList: deepKeysFromList\n};\n\n/**\n * Return the deep keys list for a single document\n * @param object\n * @param options\n * @returns {Array}\n */\nfunction deepKeys(object, options) {\n    options = mergeOptions(options);\n    if (_.isObject(object)) {\n        return generateDeepKeysList('', object, options);\n    }\n    return [];\n}\n\n/**\n * Return the deep keys list for all documents in the provided list\n * @param list\n * @param options\n * @returns Array[Array[String]]\n */\nfunction deepKeysFromList(list, options) {\n    options = mergeOptions(options);\n    return list.map((document) => { // for each document\n        if (_.isObject(document)) {\n            // if the data at the key is a document, then we retrieve the subHeading starting with an empty string heading and the doc\n            return deepKeys(document, options);\n        }\n        return [];\n    });\n}\n\nfunction generateDeepKeysList(heading, data, options) {\n    let keys = Object.keys(data).map((currentKey) => {\n        // If the given heading is empty, then we set the heading to be the subKey, otherwise set it as a nested heading w/ a dot\n        let keyName = buildKeyName(heading, currentKey);\n\n        // If we have another nested document, recur on the sub-document to retrieve the full key name\n        if (isDocumentToRecurOn(data[currentKey])) {\n            return generateDeepKeysList(keyName, data[currentKey], options);\n        } else if (options.expandArrayObjects && isArrayToRecurOn(data[currentKey])) {\n            // If we have a nested array that we need to recur on\n            return processArrayKeys(data[currentKey], currentKey, options);\n        }\n        // Otherwise return this key name since we don't have a sub document\n        return keyName;\n    });\n\n    return _.flatten(keys);\n}\n\n/**\n * Helper function to handle the processing of arrays when the expandArrayObjects\n * option is specified.\n * @param subArray\n * @param currentKeyPath\n * @param options\n * @returns {*}\n */\nfunction processArrayKeys(subArray, currentKeyPath, options) {\n    let subArrayKeys = deepKeysFromList(subArray);\n\n    if (!subArray.length) {\n        return options.ignoreEmptyArraysWhenExpanding ? [] : [currentKeyPath];\n    } else if (subArray.length && _.flatten(subArrayKeys).length === 0) {\n        // Has items in the array, but no objects\n        return [currentKeyPath];\n    } else {\n        subArrayKeys = subArrayKeys.map((schemaKeys) => {\n            if (isEmptyArray(schemaKeys)) {\n                return [currentKeyPath];\n            }\n            return schemaKeys.map((subKey) => buildKeyName(currentKeyPath, subKey));\n        });\n\n        return _.uniq(_.flatten(subArrayKeys));\n    }\n}\n\n/**\n * Function used to generate the key path\n * @param upperKeyName String accumulated key path\n * @param currentKeyName String current key name\n * @returns String\n */\nfunction buildKeyName(upperKeyName, currentKeyName) {\n    if (upperKeyName) {\n        return upperKeyName + '.' + currentKeyName;\n    }\n    return currentKeyName;\n}\n\n/**\n * Returns whether this value is a document to recur on or not\n * @param val Any item whose type will be evaluated\n * @returns {boolean}\n */\nfunction isDocumentToRecurOn(val) {\n    return _.isObject(val) && !_.isNull(val) && !Array.isArray(val) && Object.keys(val).length;\n}\n\n/**\n * Returns whether this value is an array to recur on or not\n * @param val Any item whose type will be evaluated\n * @returns {boolean}\n */\nfunction isArrayToRecurOn(val) {\n    return Array.isArray(val);\n}\n\n/**\n * Helper function that determines whether or not a value is an empty array\n * @param val\n * @returns {boolean}\n */\nfunction isEmptyArray(val) {\n    return Array.isArray(val) && !val.length;\n}\n\nfunction mergeOptions(options) {\n    return _.defaults(options || {}, {\n        expandArrayObjects: false,\n        ignoreEmptyArraysWhenExpanding: false\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVla3Mvc3JjL2RlZWtzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZWtzL3NyYy9kZWVrcy5qcz9jN2E3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVlcEtleXM6IGRlZXBLZXlzLFxuICAgIGRlZXBLZXlzRnJvbUxpc3Q6IGRlZXBLZXlzRnJvbUxpc3Rcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBkZWVwIGtleXMgbGlzdCBmb3IgYSBzaW5nbGUgZG9jdW1lbnRcbiAqIEBwYXJhbSBvYmplY3RcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGRlZXBLZXlzKG9iamVjdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKF8uaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGVEZWVwS2V5c0xpc3QoJycsIG9iamVjdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRlZXAga2V5cyBsaXN0IGZvciBhbGwgZG9jdW1lbnRzIGluIHRoZSBwcm92aWRlZCBsaXN0XG4gKiBAcGFyYW0gbGlzdFxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIEFycmF5W0FycmF5W1N0cmluZ11dXG4gKi9cbmZ1bmN0aW9uIGRlZXBLZXlzRnJvbUxpc3QobGlzdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIGxpc3QubWFwKChkb2N1bWVudCkgPT4geyAvLyBmb3IgZWFjaCBkb2N1bWVudFxuICAgICAgICBpZiAoXy5pc09iamVjdChkb2N1bWVudCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBkYXRhIGF0IHRoZSBrZXkgaXMgYSBkb2N1bWVudCwgdGhlbiB3ZSByZXRyaWV2ZSB0aGUgc3ViSGVhZGluZyBzdGFydGluZyB3aXRoIGFuIGVtcHR5IHN0cmluZyBoZWFkaW5nIGFuZCB0aGUgZG9jXG4gICAgICAgICAgICByZXR1cm4gZGVlcEtleXMoZG9jdW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVEZWVwS2V5c0xpc3QoaGVhZGluZywgZGF0YSwgb3B0aW9ucykge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSkubWFwKChjdXJyZW50S2V5KSA9PiB7XG4gICAgICAgIC8vIElmIHRoZSBnaXZlbiBoZWFkaW5nIGlzIGVtcHR5LCB0aGVuIHdlIHNldCB0aGUgaGVhZGluZyB0byBiZSB0aGUgc3ViS2V5LCBvdGhlcndpc2Ugc2V0IGl0IGFzIGEgbmVzdGVkIGhlYWRpbmcgdy8gYSBkb3RcbiAgICAgICAgbGV0IGtleU5hbWUgPSBidWlsZEtleU5hbWUoaGVhZGluZywgY3VycmVudEtleSk7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbm90aGVyIG5lc3RlZCBkb2N1bWVudCwgcmVjdXIgb24gdGhlIHN1Yi1kb2N1bWVudCB0byByZXRyaWV2ZSB0aGUgZnVsbCBrZXkgbmFtZVxuICAgICAgICBpZiAoaXNEb2N1bWVudFRvUmVjdXJPbihkYXRhW2N1cnJlbnRLZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlRGVlcEtleXNMaXN0KGtleU5hbWUsIGRhdGFbY3VycmVudEtleV0sIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZXhwYW5kQXJyYXlPYmplY3RzICYmIGlzQXJyYXlUb1JlY3VyT24oZGF0YVtjdXJyZW50S2V5XSkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBuZXN0ZWQgYXJyYXkgdGhhdCB3ZSBuZWVkIHRvIHJlY3VyIG9uXG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0FycmF5S2V5cyhkYXRhW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIHRoaXMga2V5IG5hbWUgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIHN1YiBkb2N1bWVudFxuICAgICAgICByZXR1cm4ga2V5TmFtZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfLmZsYXR0ZW4oa2V5cyk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgcHJvY2Vzc2luZyBvZiBhcnJheXMgd2hlbiB0aGUgZXhwYW5kQXJyYXlPYmplY3RzXG4gKiBvcHRpb24gaXMgc3BlY2lmaWVkLlxuICogQHBhcmFtIHN1YkFycmF5XG4gKiBAcGFyYW0gY3VycmVudEtleVBhdGhcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0FycmF5S2V5cyhzdWJBcnJheSwgY3VycmVudEtleVBhdGgsIG9wdGlvbnMpIHtcbiAgICBsZXQgc3ViQXJyYXlLZXlzID0gZGVlcEtleXNGcm9tTGlzdChzdWJBcnJheSk7XG5cbiAgICBpZiAoIXN1YkFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5pZ25vcmVFbXB0eUFycmF5c1doZW5FeHBhbmRpbmcgPyBbXSA6IFtjdXJyZW50S2V5UGF0aF07XG4gICAgfSBlbHNlIGlmIChzdWJBcnJheS5sZW5ndGggJiYgXy5mbGF0dGVuKHN1YkFycmF5S2V5cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIEhhcyBpdGVtcyBpbiB0aGUgYXJyYXksIGJ1dCBubyBvYmplY3RzXG4gICAgICAgIHJldHVybiBbY3VycmVudEtleVBhdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YkFycmF5S2V5cyA9IHN1YkFycmF5S2V5cy5tYXAoKHNjaGVtYUtleXMpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5QXJyYXkoc2NoZW1hS2V5cykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzY2hlbWFLZXlzLm1hcCgoc3ViS2V5KSA9PiBidWlsZEtleU5hbWUoY3VycmVudEtleVBhdGgsIHN1YktleSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gXy51bmlxKF8uZmxhdHRlbihzdWJBcnJheUtleXMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGUga2V5IHBhdGhcbiAqIEBwYXJhbSB1cHBlcktleU5hbWUgU3RyaW5nIGFjY3VtdWxhdGVkIGtleSBwYXRoXG4gKiBAcGFyYW0gY3VycmVudEtleU5hbWUgU3RyaW5nIGN1cnJlbnQga2V5IG5hbWVcbiAqIEByZXR1cm5zIFN0cmluZ1xuICovXG5mdW5jdGlvbiBidWlsZEtleU5hbWUodXBwZXJLZXlOYW1lLCBjdXJyZW50S2V5TmFtZSkge1xuICAgIGlmICh1cHBlcktleU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHVwcGVyS2V5TmFtZSArICcuJyArIGN1cnJlbnRLZXlOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudEtleU5hbWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoaXMgdmFsdWUgaXMgYSBkb2N1bWVudCB0byByZWN1ciBvbiBvciBub3RcbiAqIEBwYXJhbSB2YWwgQW55IGl0ZW0gd2hvc2UgdHlwZSB3aWxsIGJlIGV2YWx1YXRlZFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnRUb1JlY3VyT24odmFsKSB7XG4gICAgcmV0dXJuIF8uaXNPYmplY3QodmFsKSAmJiAhXy5pc051bGwodmFsKSAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmIE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGlzIHZhbHVlIGlzIGFuIGFycmF5IHRvIHJlY3VyIG9uIG9yIG5vdFxuICogQHBhcmFtIHZhbCBBbnkgaXRlbSB3aG9zZSB0eXBlIHdpbGwgYmUgZXZhbHVhdGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNBcnJheVRvUmVjdXJPbih2YWwpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheVxuICogQHBhcmFtIHZhbFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHlBcnJheSh2YWwpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpICYmICF2YWwubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBfLmRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgZXhwYW5kQXJyYXlPYmplY3RzOiBmYWxzZSxcbiAgICAgICAgaWdub3JlRW1wdHlBcnJheXNXaGVuRXhwYW5kaW5nOiBmYWxzZVxuICAgIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeks/src/deeks.js\n");

/***/ }),

/***/ "./node_modules/doc-path/src/path.js":
/*!*******************************************!*\
  !*** ./node_modules/doc-path/src/path.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n    evaluatePath,\n    setPath\n};\n\nfunction evaluatePath(document, keyPath) {\n    if (!document) {\n        return null;\n    }\n\n    let {indexOfDot, currentKey, remainingKeyPath} = computeStateInformation(keyPath);\n\n    // If there is a '.' in the keyPath and keyPath doesn't appear in the document, recur on the subdocument\n    if (indexOfDot >= 0 && !document[keyPath]) {\n        // If there's an array at the currentKey in the document, then iterate over those items evaluating the remaining path\n        if (Array.isArray(document[currentKey])) {\n            return document[currentKey].map((doc) => evaluatePath(doc, remainingKeyPath));\n        }\n        // Otherwise, we can just recur\n        return evaluatePath(document[currentKey], remainingKeyPath);\n    } else if (Array.isArray(document)) {\n        // If this \"document\" is actually an array, then iterate over those items evaluating the path\n        return document.map((doc) => evaluatePath(doc, keyPath));\n    }\n\n    // Otherwise, we can just return value directly\n    return document[keyPath];\n}\n\nfunction setPath(document, keyPath, value) {\n    if (!document) {\n        throw new Error('No document was provided.');\n    }\n\n    let {indexOfDot, currentKey, remainingKeyPath} = computeStateInformation(keyPath);\n\n    // If there is a '.' in the keyPath, recur on the subdoc and ...\n    if (indexOfDot >= 0) {\n        if (!document[currentKey] && Array.isArray(document)) {\n            // If this is an array and there are multiple levels of keys to iterate over, recur.\n            return document.forEach((doc) => setPath(doc, keyPath, value));\n        } else if (!document[currentKey]) {\n            // If the currentKey doesn't exist yet, populate it\n            document[currentKey] = {};\n        }\n        setPath(document[currentKey], remainingKeyPath, value);\n    } else if (Array.isArray(document)) {\n        // If this \"document\" is actually an array, then we can loop over each of the values and set the path\n        return document.forEach((doc) => setPath(doc, remainingKeyPath, value));\n    } else {\n        // Otherwise, we can set the path directly\n        document[keyPath] = value;\n    }\n\n    return document;\n}\n\n/**\n * Helper function that returns some information necessary to evaluate or set a path\n *   based on the provided keyPath value\n * @param keyPath\n * @returns {{indexOfDot: Number, currentKey: String, remainingKeyPath: String}}\n */\nfunction computeStateInformation(keyPath) {\n    let indexOfDot = keyPath.indexOf('.');\n\n    return {\n        indexOfDot,\n        currentKey: keyPath.slice(0, indexOfDot >= 0 ? indexOfDot : undefined),\n        remainingKeyPath: keyPath.slice(indexOfDot + 1)\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9jLXBhdGgvc3JjL3BhdGguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9jLXBhdGgvc3JjL3BhdGguanM/ZjA3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGV2YWx1YXRlUGF0aCxcbiAgICBzZXRQYXRoXG59O1xuXG5mdW5jdGlvbiBldmFsdWF0ZVBhdGgoZG9jdW1lbnQsIGtleVBhdGgpIHtcbiAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCB7aW5kZXhPZkRvdCwgY3VycmVudEtleSwgcmVtYWluaW5nS2V5UGF0aH0gPSBjb21wdXRlU3RhdGVJbmZvcm1hdGlvbihrZXlQYXRoKTtcblxuICAgIC8vIElmIHRoZXJlIGlzIGEgJy4nIGluIHRoZSBrZXlQYXRoIGFuZCBrZXlQYXRoIGRvZXNuJ3QgYXBwZWFyIGluIHRoZSBkb2N1bWVudCwgcmVjdXIgb24gdGhlIHN1YmRvY3VtZW50XG4gICAgaWYgKGluZGV4T2ZEb3QgPj0gMCAmJiAhZG9jdW1lbnRba2V5UGF0aF0pIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBhcnJheSBhdCB0aGUgY3VycmVudEtleSBpbiB0aGUgZG9jdW1lbnQsIHRoZW4gaXRlcmF0ZSBvdmVyIHRob3NlIGl0ZW1zIGV2YWx1YXRpbmcgdGhlIHJlbWFpbmluZyBwYXRoXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRvY3VtZW50W2N1cnJlbnRLZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50W2N1cnJlbnRLZXldLm1hcCgoZG9jKSA9PiBldmFsdWF0ZVBhdGgoZG9jLCByZW1haW5pbmdLZXlQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBjYW4ganVzdCByZWN1clxuICAgICAgICByZXR1cm4gZXZhbHVhdGVQYXRoKGRvY3VtZW50W2N1cnJlbnRLZXldLCByZW1haW5pbmdLZXlQYXRoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZG9jdW1lbnQpKSB7XG4gICAgICAgIC8vIElmIHRoaXMgXCJkb2N1bWVudFwiIGlzIGFjdHVhbGx5IGFuIGFycmF5LCB0aGVuIGl0ZXJhdGUgb3ZlciB0aG9zZSBpdGVtcyBldmFsdWF0aW5nIHRoZSBwYXRoXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5tYXAoKGRvYykgPT4gZXZhbHVhdGVQYXRoKGRvYywga2V5UGF0aCkpO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgd2UgY2FuIGp1c3QgcmV0dXJuIHZhbHVlIGRpcmVjdGx5XG4gICAgcmV0dXJuIGRvY3VtZW50W2tleVBhdGhdO1xufVxuXG5mdW5jdGlvbiBzZXRQYXRoKGRvY3VtZW50LCBrZXlQYXRoLCB2YWx1ZSkge1xuICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkb2N1bWVudCB3YXMgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgbGV0IHtpbmRleE9mRG90LCBjdXJyZW50S2V5LCByZW1haW5pbmdLZXlQYXRofSA9IGNvbXB1dGVTdGF0ZUluZm9ybWF0aW9uKGtleVBhdGgpO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSAnLicgaW4gdGhlIGtleVBhdGgsIHJlY3VyIG9uIHRoZSBzdWJkb2MgYW5kIC4uLlxuICAgIGlmIChpbmRleE9mRG90ID49IDApIHtcbiAgICAgICAgaWYgKCFkb2N1bWVudFtjdXJyZW50S2V5XSAmJiBBcnJheS5pc0FycmF5KGRvY3VtZW50KSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBhcnJheSBhbmQgdGhlcmUgYXJlIG11bHRpcGxlIGxldmVscyBvZiBrZXlzIHRvIGl0ZXJhdGUgb3ZlciwgcmVjdXIuXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZm9yRWFjaCgoZG9jKSA9PiBzZXRQYXRoKGRvYywga2V5UGF0aCwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICghZG9jdW1lbnRbY3VycmVudEtleV0pIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50S2V5IGRvZXNuJ3QgZXhpc3QgeWV0LCBwb3B1bGF0ZSBpdFxuICAgICAgICAgICAgZG9jdW1lbnRbY3VycmVudEtleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBzZXRQYXRoKGRvY3VtZW50W2N1cnJlbnRLZXldLCByZW1haW5pbmdLZXlQYXRoLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRvY3VtZW50KSkge1xuICAgICAgICAvLyBJZiB0aGlzIFwiZG9jdW1lbnRcIiBpcyBhY3R1YWxseSBhbiBhcnJheSwgdGhlbiB3ZSBjYW4gbG9vcCBvdmVyIGVhY2ggb2YgdGhlIHZhbHVlcyBhbmQgc2V0IHRoZSBwYXRoXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5mb3JFYWNoKChkb2MpID0+IHNldFBhdGgoZG9jLCByZW1haW5pbmdLZXlQYXRoLCB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgY2FuIHNldCB0aGUgcGF0aCBkaXJlY3RseVxuICAgICAgICBkb2N1bWVudFtrZXlQYXRoXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBkb2N1bWVudDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHNvbWUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGV2YWx1YXRlIG9yIHNldCBhIHBhdGhcbiAqICAgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGtleVBhdGggdmFsdWVcbiAqIEBwYXJhbSBrZXlQYXRoXG4gKiBAcmV0dXJucyB7e2luZGV4T2ZEb3Q6IE51bWJlciwgY3VycmVudEtleTogU3RyaW5nLCByZW1haW5pbmdLZXlQYXRoOiBTdHJpbmd9fVxuICovXG5mdW5jdGlvbiBjb21wdXRlU3RhdGVJbmZvcm1hdGlvbihrZXlQYXRoKSB7XG4gICAgbGV0IGluZGV4T2ZEb3QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4T2ZEb3QsXG4gICAgICAgIGN1cnJlbnRLZXk6IGtleVBhdGguc2xpY2UoMCwgaW5kZXhPZkRvdCA+PSAwID8gaW5kZXhPZkRvdCA6IHVuZGVmaW5lZCksXG4gICAgICAgIHJlbWFpbmluZ0tleVBhdGg6IGtleVBhdGguc2xpY2UoaW5kZXhPZkRvdCArIDEpXG4gICAgfTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/doc-path/src/path.js\n");

/***/ }),

/***/ "./node_modules/json-2-csv/src/constants.json":
/*!****************************************************!*\
  !*** ./node_modules/json-2-csv/src/constants.json ***!
  \****************************************************/
/*! exports provided: errors, defaultOptions, values, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"errors\\\":{\\\"callbackRequired\\\":\\\"A callback is required!\\\",\\\"optionsRequired\\\":\\\"Options were not passed and are required.\\\",\\\"json2csv\\\":{\\\"cannotCallOn\\\":\\\"Cannot call json2csv on \\\",\\\"dataCheckFailure\\\":\\\"Data provided was not an array of documents.\\\",\\\"notSameSchema\\\":\\\"Not all documents have the same schema.\\\"},\\\"csv2json\\\":{\\\"cannotCallOn\\\":\\\"Cannot call csv2json on \\\",\\\"dataCheckFailure\\\":\\\"CSV is not a string.\\\"}},\\\"defaultOptions\\\":{\\\"delimiter\\\":{\\\"field\\\":\\\",\\\",\\\"wrap\\\":\\\"\\\\\\\"\\\",\\\"eol\\\":\\\"\\\\n\\\"},\\\"excelBOM\\\":false,\\\"prependHeader\\\":true,\\\"trimHeaderFields\\\":false,\\\"trimFieldValues\\\":false,\\\"sortHeader\\\":false,\\\"parseCsvNumbers\\\":false,\\\"keys\\\":null,\\\"checkSchemaDifferences\\\":false,\\\"expandArrayObjects\\\":false},\\\"values\\\":{\\\"excelBOM\\\":\\\"\\\"}}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9zcmMvY29uc3RhbnRzLmpzb24uanMiLCJzb3VyY2VzIjpbXSwibWFwcGluZ3MiOiIiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/json-2-csv/src/constants.json\n");

/***/ }),

/***/ "./node_modules/json-2-csv/src/converter.js":
/*!**************************************************!*\
  !*** ./node_modules/json-2-csv/src/converter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nlet {Json2Csv} = __webpack_require__(/*! ./json2csv */ \"./node_modules/json-2-csv/src/json2csv.js\"), // Require our json-2-csv code\n    {Csv2Json} = __webpack_require__(/*! ./csv2json */ \"./node_modules/json-2-csv/src/csv2json.js\"), // Require our csv-2-json code\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/json-2-csv/src/utils.js\");\n\nmodule.exports = {\n    json2csv: (data, callback, options) => convert(Json2Csv, data, callback, options),\n    csv2json: (data, callback, options) => convert(Csv2Json, data, callback, options),\n    json2csvAsync: (json, options) => convertAsync(Json2Csv, json, options),\n    csv2jsonAsync: (csv, options) => convertAsync(Csv2Json, csv, options),\n\n    /**\n     * @deprecated Since v3.0.0\n     */\n    json2csvPromisified: (json, options) => deprecatedAsync(Json2Csv, 'json2csvPromisified()', 'json2csvAsync()', json, options),\n\n    /**\n     * @deprecated Since v3.0.0\n     */\n    csv2jsonPromisified: (csv, options) => deprecatedAsync(Csv2Json, 'csv2jsonPromisified()', 'csv2jsonAsync()', csv, options)\n};\n\n/**\n * Abstracted converter function for json2csv and csv2json functionality\n * Takes in the converter to be used (either Json2Csv or Csv2Json)\n * @param converter\n * @param data\n * @param callback\n * @param options\n */\nfunction convert(converter, data, callback, options) {\n    return utils.convert({\n        data: data,\n        callback,\n        options,\n        converter: converter\n    });\n}\n\n/**\n * Simple way to promisify a callback version of json2csv or csv2json\n * @param converter\n * @param data\n * @param options\n * @returns {Promise<any>}\n */\nfunction convertAsync(converter, data, options) {\n    return new Promise((resolve, reject) => convert(converter, data, (err, data) => {\n        if (err) {\n            return reject(err);\n        }\n        return resolve(data);\n    }, options));\n}\n\n/**\n * Simple way to provide a deprecation warning for previous promisified versions\n * of module functionality.\n * @param converter\n * @param deprecatedName\n * @param replacementName\n * @param data\n * @param options\n * @returns {Promise<any>}\n */\nfunction deprecatedAsync(converter, deprecatedName, replacementName, data, options) {\n    console.warn('WARNING: ' + deprecatedName + ' is deprecated and will be removed soon. Please use ' + replacementName + ' instead.');\n    return convertAsync(converter, data, options);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9zcmMvY29udmVydGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb24tMi1jc3Yvc3JjL2NvbnZlcnRlci5qcz8xZmU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubGV0IHtKc29uMkNzdn0gPSByZXF1aXJlKCcuL2pzb24yY3N2JyksIC8vIFJlcXVpcmUgb3VyIGpzb24tMi1jc3YgY29kZVxuICAgIHtDc3YySnNvbn0gPSByZXF1aXJlKCcuL2NzdjJqc29uJyksIC8vIFJlcXVpcmUgb3VyIGNzdi0yLWpzb24gY29kZVxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBqc29uMmNzdjogKGRhdGEsIGNhbGxiYWNrLCBvcHRpb25zKSA9PiBjb252ZXJ0KEpzb24yQ3N2LCBkYXRhLCBjYWxsYmFjaywgb3B0aW9ucyksXG4gICAgY3N2Mmpzb246IChkYXRhLCBjYWxsYmFjaywgb3B0aW9ucykgPT4gY29udmVydChDc3YySnNvbiwgZGF0YSwgY2FsbGJhY2ssIG9wdGlvbnMpLFxuICAgIGpzb24yY3N2QXN5bmM6IChqc29uLCBvcHRpb25zKSA9PiBjb252ZXJ0QXN5bmMoSnNvbjJDc3YsIGpzb24sIG9wdGlvbnMpLFxuICAgIGNzdjJqc29uQXN5bmM6IChjc3YsIG9wdGlvbnMpID0+IGNvbnZlcnRBc3luYyhDc3YySnNvbiwgY3N2LCBvcHRpb25zKSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFNpbmNlIHYzLjAuMFxuICAgICAqL1xuICAgIGpzb24yY3N2UHJvbWlzaWZpZWQ6IChqc29uLCBvcHRpb25zKSA9PiBkZXByZWNhdGVkQXN5bmMoSnNvbjJDc3YsICdqc29uMmNzdlByb21pc2lmaWVkKCknLCAnanNvbjJjc3ZBc3luYygpJywganNvbiwgb3B0aW9ucyksXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2My4wLjBcbiAgICAgKi9cbiAgICBjc3YyanNvblByb21pc2lmaWVkOiAoY3N2LCBvcHRpb25zKSA9PiBkZXByZWNhdGVkQXN5bmMoQ3N2Mkpzb24sICdjc3YyanNvblByb21pc2lmaWVkKCknLCAnY3N2Mmpzb25Bc3luYygpJywgY3N2LCBvcHRpb25zKVxufTtcblxuLyoqXG4gKiBBYnN0cmFjdGVkIGNvbnZlcnRlciBmdW5jdGlvbiBmb3IganNvbjJjc3YgYW5kIGNzdjJqc29uIGZ1bmN0aW9uYWxpdHlcbiAqIFRha2VzIGluIHRoZSBjb252ZXJ0ZXIgdG8gYmUgdXNlZCAoZWl0aGVyIEpzb24yQ3N2IG9yIENzdjJKc29uKVxuICogQHBhcmFtIGNvbnZlcnRlclxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBjYWxsYmFja1xuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY29udmVydChjb252ZXJ0ZXIsIGRhdGEsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbnZlcnQoe1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY29udmVydGVyOiBjb252ZXJ0ZXJcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgd2F5IHRvIHByb21pc2lmeSBhIGNhbGxiYWNrIHZlcnNpb24gb2YganNvbjJjc3Ygb3IgY3N2Mmpzb25cbiAqIEBwYXJhbSBjb252ZXJ0ZXJcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAqL1xuZnVuY3Rpb24gY29udmVydEFzeW5jKGNvbnZlcnRlciwgZGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBjb252ZXJ0KGNvbnZlcnRlciwgZGF0YSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YSk7XG4gICAgfSwgb3B0aW9ucykpO1xufVxuXG4vKipcbiAqIFNpbXBsZSB3YXkgdG8gcHJvdmlkZSBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgZm9yIHByZXZpb3VzIHByb21pc2lmaWVkIHZlcnNpb25zXG4gKiBvZiBtb2R1bGUgZnVuY3Rpb25hbGl0eS5cbiAqIEBwYXJhbSBjb252ZXJ0ZXJcbiAqIEBwYXJhbSBkZXByZWNhdGVkTmFtZVxuICogQHBhcmFtIHJlcGxhY2VtZW50TmFtZVxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICovXG5mdW5jdGlvbiBkZXByZWNhdGVkQXN5bmMoY29udmVydGVyLCBkZXByZWNhdGVkTmFtZSwgcmVwbGFjZW1lbnROYW1lLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiAnICsgZGVwcmVjYXRlZE5hbWUgKyAnIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBzb29uLiBQbGVhc2UgdXNlICcgKyByZXBsYWNlbWVudE5hbWUgKyAnIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIGNvbnZlcnRBc3luYyhjb252ZXJ0ZXIsIGRhdGEsIG9wdGlvbnMpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/json-2-csv/src/converter.js\n");

/***/ }),

/***/ "./node_modules/json-2-csv/src/csv2json.js":
/*!*************************************************!*\
  !*** ./node_modules/json-2-csv/src/csv2json.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nlet constants = __webpack_require__(/*! ./constants.json */ \"./node_modules/json-2-csv/src/constants.json\"),\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/json-2-csv/src/utils.js\"),\n    _ = __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js\"),\n    path = __webpack_require__(/*! doc-path */ \"./node_modules/doc-path/src/path.js\");\n\nconst Csv2Json = function(options) {\n    const escapedWrapDelimiterRegex = new RegExp(options.delimiter.wrap + options.delimiter.wrap, 'g'),\n        excelBOMRegex = new RegExp('^' + constants.values.excelBOM);\n\n    /**\n     * Trims the header key, if specified by the user via the provided options\n     * @param headerKey\n     * @returns {*}\n     */\n    function processHeaderKey(headerKey) {\n        headerKey = removeWrapDelimitersFromValue(headerKey);\n        if (options.trimHeaderFields) {\n            return headerKey.split('.')\n                .map((component) => component.trim())\n                .join('.');\n        }\n        return headerKey;\n    }\n\n    /**\n     * Generate the JSON heading from the CSV\n     * @param lines {String[]} csv lines split by EOL delimiter\n     * @returns {*}\n     */\n    function retrieveHeading(lines) {\n        let params = {lines},\n            // Generate and return the heading keys\n            headerRow = params.lines[0];\n        params.headerFields = headerRow.map((headerKey, index) => ({\n            value: processHeaderKey(headerKey),\n            index: index\n        }));\n\n        // If the user provided keys, filter the generated keys to just the user provided keys so we also have the key index\n        if (options.keys) {\n            params.headerFields = params.headerFields.filter((headerKey) => options.keys.includes(headerKey.value));\n        }\n\n        return params;\n    }\n\n    /**\n     * Splits the lines of the CSV string by the EOL delimiter and resolves and array of strings (lines)\n     * @param csv\n     * @returns {Promise.<String[]>}\n     */\n    function splitCsvLines(csv) {\n        return Promise.resolve(splitLines(csv));\n    }\n\n    /**\n     * Removes the Excel BOM value, if specified by the options object\n     * @param csv\n     * @returns {Promise.<String>}\n     */\n    function stripExcelBOM(csv) {\n        if (options.excelBOM) {\n            return Promise.resolve(csv.replace(excelBOMRegex, ''));\n        }\n        return Promise.resolve(csv);\n    }\n\n    /**\n     * Helper function that splits a line so that we can handle wrapped fields\n     * @param csv\n     */\n    function splitLines(csv) {\n        // Parse out the line...\n        let lines = [],\n            splitLine = [],\n            character,\n            charBefore,\n            charAfter,\n            nextNChar,\n            lastCharacterIndex = csv.length - 1,\n            eolDelimiterLength = options.delimiter.eol.length,\n            stateVariables = {\n                insideWrapDelimiter: false,\n                parsingValue: true,\n                justParsedDoubleQuote: false,\n                startIndex: 0\n            },\n            index = 0;\n\n        // Loop through each character in the line to identify where to split the values\n        while (index < csv.length) {\n            // Current character\n            character = csv[index];\n            // Previous character\n            charBefore = index ? csv[index - 1] : '';\n            // Next character\n            charAfter = index < lastCharacterIndex ? csv[index + 1] : '';\n            // Next n characters, including the current character, where n = length(EOL delimiter)\n            // This allows for the checking of an EOL delimiter when if it is more than a single character (eg. '\\r\\n')\n            nextNChar = utils.getNCharacters(csv, index, eolDelimiterLength);\n\n            if ((nextNChar === options.delimiter.eol && !stateVariables.insideWrapDelimiter ||\n                index === lastCharacterIndex) && charBefore === options.delimiter.field) {\n                // If we reached an EOL delimiter or the end of the csv and the previous character is a field delimiter...\n\n                // If the start index is the current index (and since the previous character is a comma),\n                //   then the value being parsed is an empty value accordingly, add an empty string\n                let parsedValue = nextNChar === options.delimiter.eol && stateVariables.startIndex === index\n                    ? ''\n                    // Otherwise, there's a valid value, and the start index isn't the current index, grab the whole value\n                    : csv.substr(stateVariables.startIndex);\n\n                // Push the value for the field that we were parsing\n                splitLine.push(parsedValue);\n\n                // Since the last character is a comma, there's still an additional implied field value trailing the comma.\n                //   Since this value is empty, we push an extra empty value\n                splitLine.push('');\n\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            } else if (index === lastCharacterIndex || nextNChar === options.delimiter.eol &&\n                // if we aren't inside wrap delimiters or if we are but the character before was a wrap delimiter and we didn't just see two\n                (!stateVariables.insideWrapDelimiter ||\n                    stateVariables.insideWrapDelimiter && charBefore === options.delimiter.wrap && !stateVariables.justParsedDoubleQuote)) {\n                // Otherwise if we reached the end of the line or csv (and current character is not a field delimiter)\n\n                let toIndex = index !== lastCharacterIndex || charBefore === options.delimiter.wrap ? index : undefined;\n\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, toIndex));\n\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            } else if ((charBefore !== options.delimiter.wrap || stateVariables.justParsedDoubleQuote && charBefore === options.delimiter.wrap) &&\n                character === options.delimiter.wrap && utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                // If we reach a wrap which is not preceded by a wrap delim and the next character is an EOL delim (ie. *\"\\n)\n\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n                // Next iteration will substring, add the value to the line, and push the line onto the array of lines\n            } else if (character === options.delimiter.wrap && (index === 0 || utils.getNCharacters(csv, index - 1, eolDelimiterLength) === options.delimiter.eol)) {\n                // If the line starts with a wrap delimiter (ie. \"*)\n\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            } else if (character === options.delimiter.wrap && charAfter === options.delimiter.field) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. *\",)\n\n                splitLine.push(csv.substring(stateVariables.startIndex, index + 1));\n                stateVariables.startIndex = index + 2; // next value starts after the field delimiter\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n            } else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && !stateVariables.parsingValue) {\n                // If we reached a wrap delimiter after a comma and we aren't inside a wrap delimiter\n\n                stateVariables.startIndex = index;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n            } else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. ,\"*)\n\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            } else if (character === options.delimiter.wrap && charAfter === options.delimiter.wrap) {\n                // If we run into an escaped quote (ie. \"\") skip past the second quote\n\n                index += 2;\n                stateVariables.justParsedDoubleQuote = true;\n                continue;\n            } else if (character === options.delimiter.field && charBefore !== options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.insideWrapDelimiter &&\n                stateVariables.parsingValue) {\n                // If we reached a field delimiter and are not inside the wrap delimiters (ie. *,*)\n\n                splitLine.push(csv.substring(stateVariables.startIndex, index));\n                stateVariables.startIndex = index + 1;\n            } else if (character === options.delimiter.field && charBefore === options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.parsingValue) {\n                // If we reached a field delimiter, the previous character was a wrap delimiter, and the\n                //   next character is not a wrap delimiter (ie. \",*)\n\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index + 1;\n            }\n            // Otherwise increment to the next character\n            index++;\n            // Reset the double quote state variable\n            stateVariables.justParsedDoubleQuote = false;\n        }\n\n        return lines;\n    }\n\n    /**\n     * Retrieves the record lines from the split CSV lines and sets it on the params object\n     * @param params\n     * @returns {*}\n     */\n    function retrieveRecordLines(params) {\n        params.recordLines = params.lines.splice(1); // All lines except for the header line\n\n        return params;\n    }\n\n    /**\n     * Retrieves the value for the record from the line at the provided key.\n     * @param line {String[]} split line values for the record\n     * @param key {Object} {index: Number, value: String}\n     */\n    function retrieveRecordValueFromLine(line, key) {\n        // If there is a value at the key's index, use it; otherwise, null\n        let value = line[key.index];\n\n        // Perform any necessary value conversions on the record value\n        return processRecordValue(value);\n    }\n\n    /**\n     * Processes the record's value by parsing the data to ensure the CSV is\n     * converted to the JSON that created it.\n     * @param fieldValue {String}\n     * @returns {*}\n     */\n    function processRecordValue(fieldValue) {\n        // If the value is an array representation, convert it\n        let parsedJson = parseValue(fieldValue);\n        // If parsedJson is anything aside from an error, then we want to use the parsed value\n        // This allows us to interpret values like 'null' --> null, 'false' --> false\n        if (!_.isError(parsedJson)) {\n            fieldValue = parsedJson;\n        } else if (fieldValue === 'undefined') {\n            fieldValue = undefined;\n        }\n\n        return fieldValue;\n    }\n\n    /**\n     * Trims the record value, if specified by the user via the options object\n     * @param fieldValue\n     * @returns {String|null}\n     */\n    function trimRecordValue(fieldValue) {\n        if (options.trimFieldValues && !_.isNull(fieldValue)) {\n            return fieldValue.trim();\n        }\n        return fieldValue;\n    }\n\n    /**\n     * Create a JSON document with the given keys (designated by the CSV header)\n     *   and the values (from the given line)\n     * @param keys String[]\n     * @param line String\n     * @returns {Object} created json document\n     */\n    function createDocument(keys, line) {\n        // Reduce the keys into a JSON document representing the given line\n        return keys.reduce((document, key) => {\n            // If there is a value at the key's index in the line, set the value; otherwise null\n            let value = retrieveRecordValueFromLine(line, key);\n\n            // Otherwise add the key and value to the document\n            return path.setPath(document, key.value, value);\n        }, {});\n    }\n\n    /**\n     * Removes the outermost wrap delimiters from a value, if they are present\n     * Otherwise, the non-wrapped value is returned as is\n     * @param fieldValue\n     * @returns {String}\n     */\n    function removeWrapDelimitersFromValue(fieldValue) {\n        let firstChar = fieldValue[0],\n            lastIndex = fieldValue.length - 1,\n            lastChar = fieldValue[lastIndex];\n        // If the field starts and ends with a wrap delimiter\n        if (firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap) {\n            return fieldValue.substr(1, lastIndex - 1);\n        }\n        return fieldValue;\n    }\n\n    /**\n     * Unescapes wrap delimiters by replacing duplicates with a single (eg. \"\" -> \")\n     * This is done in order to parse RFC 4180 compliant CSV back to JSON\n     * @param fieldValue\n     * @returns {String}\n     */\n    function unescapeWrapDelimiterInField(fieldValue) {\n        return fieldValue.replace(escapedWrapDelimiterRegex, options.delimiter.wrap);\n    }\n\n    /**\n     * Main helper function to convert the CSV to the JSON document array\n     * @param params {Object} {lines: [String], callback: Function}\n     * @returns {Array}\n     */\n    function transformRecordLines(params) {\n        params.json = params.recordLines.reduce((generatedJsonObjects, line) => { // For each line, create the document and add it to the array of documents\n            line = line.map((fieldValue) => {\n                // Perform the necessary operations on each line\n                fieldValue = removeWrapDelimitersFromValue(fieldValue);\n                fieldValue = unescapeWrapDelimiterInField(fieldValue);\n                fieldValue = trimRecordValue(fieldValue);\n\n                return fieldValue;\n            });\n\n            let generatedDocument = createDocument(params.headerFields, line);\n            return generatedJsonObjects.concat(generatedDocument);\n        }, []);\n\n        return params;\n    }\n\n    /**\n     * Attempts to parse the provided value. If it is not parsable, then an error is returned\n     * @param value\n     * @returns {*}\n     */\n    function parseValue(value) {\n        try {\n            if (utils.isStringRepresentation(value, options) && !utils.isDateRepresentation(value)) {\n                return value;\n            }\n\n            let parsedJson = JSON.parse(value);\n\n            // If the parsed value is an array, then we also need to trim record values, if specified\n            if (_.isArray(parsedJson)) {\n                return parsedJson.map(trimRecordValue);\n            }\n\n            return parsedJson;\n        } catch (err) {\n            return err;\n        }\n    }\n\n    /**\n     * Internally exported csv2json function\n     * Takes options as a document, data as a CSV string, and a callback that will be used to report the results\n     * @param data String csv string\n     * @param callback Function callback function\n     */\n    function convert(data, callback) {\n        // Split the CSV into lines using the specified EOL option\n        // validateCsv(data, callback)\n        //     .then(stripExcelBOM)\n        stripExcelBOM(data)\n            .then(splitCsvLines)\n            .then(retrieveHeading) // Retrieve the headings from the CSV, unless the user specified the keys\n            .then(retrieveRecordLines) // Retrieve the record lines from the CSV\n            .then(transformRecordLines) // Retrieve the JSON document array\n            .then((params) => callback(null, params.json)) // Send the data back to the caller\n            .catch(callback);\n    }\n\n    return {\n        convert,\n        validationFn: _.isString,\n        validationMessages: constants.errors.csv2json\n    };\n};\n\nmodule.exports = { Csv2Json };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9zcmMvY3N2Mmpzb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9zcmMvY3N2Mmpzb24uanM/NmVlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmxldCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy5qc29uJyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyksXG4gICAgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSxcbiAgICBwYXRoID0gcmVxdWlyZSgnZG9jLXBhdGgnKTtcblxuY29uc3QgQ3N2Mkpzb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgY29uc3QgZXNjYXBlZFdyYXBEZWxpbWl0ZXJSZWdleCA9IG5ldyBSZWdFeHAob3B0aW9ucy5kZWxpbWl0ZXIud3JhcCArIG9wdGlvbnMuZGVsaW1pdGVyLndyYXAsICdnJyksXG4gICAgICAgIGV4Y2VsQk9NUmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGNvbnN0YW50cy52YWx1ZXMuZXhjZWxCT00pO1xuXG4gICAgLyoqXG4gICAgICogVHJpbXMgdGhlIGhlYWRlciBrZXksIGlmIHNwZWNpZmllZCBieSB0aGUgdXNlciB2aWEgdGhlIHByb3ZpZGVkIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gaGVhZGVyS2V5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcktleShoZWFkZXJLZXkpIHtcbiAgICAgICAgaGVhZGVyS2V5ID0gcmVtb3ZlV3JhcERlbGltaXRlcnNGcm9tVmFsdWUoaGVhZGVyS2V5KTtcbiAgICAgICAgaWYgKG9wdGlvbnMudHJpbUhlYWRlckZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcktleS5zcGxpdCgnLicpXG4gICAgICAgICAgICAgICAgLm1hcCgoY29tcG9uZW50KSA9PiBjb21wb25lbnQudHJpbSgpKVxuICAgICAgICAgICAgICAgIC5qb2luKCcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcktleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgSlNPTiBoZWFkaW5nIGZyb20gdGhlIENTVlxuICAgICAqIEBwYXJhbSBsaW5lcyB7U3RyaW5nW119IGNzdiBsaW5lcyBzcGxpdCBieSBFT0wgZGVsaW1pdGVyXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmVIZWFkaW5nKGxpbmVzKSB7XG4gICAgICAgIGxldCBwYXJhbXMgPSB7bGluZXN9LFxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYW5kIHJldHVybiB0aGUgaGVhZGluZyBrZXlzXG4gICAgICAgICAgICBoZWFkZXJSb3cgPSBwYXJhbXMubGluZXNbMF07XG4gICAgICAgIHBhcmFtcy5oZWFkZXJGaWVsZHMgPSBoZWFkZXJSb3cubWFwKChoZWFkZXJLZXksIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgdmFsdWU6IHByb2Nlc3NIZWFkZXJLZXkoaGVhZGVyS2V5KSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQga2V5cywgZmlsdGVyIHRoZSBnZW5lcmF0ZWQga2V5cyB0byBqdXN0IHRoZSB1c2VyIHByb3ZpZGVkIGtleXMgc28gd2UgYWxzbyBoYXZlIHRoZSBrZXkgaW5kZXhcbiAgICAgICAgaWYgKG9wdGlvbnMua2V5cykge1xuICAgICAgICAgICAgcGFyYW1zLmhlYWRlckZpZWxkcyA9IHBhcmFtcy5oZWFkZXJGaWVsZHMuZmlsdGVyKChoZWFkZXJLZXkpID0+IG9wdGlvbnMua2V5cy5pbmNsdWRlcyhoZWFkZXJLZXkudmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIHRoZSBsaW5lcyBvZiB0aGUgQ1NWIHN0cmluZyBieSB0aGUgRU9MIGRlbGltaXRlciBhbmQgcmVzb2x2ZXMgYW5kIGFycmF5IG9mIHN0cmluZ3MgKGxpbmVzKVxuICAgICAqIEBwYXJhbSBjc3ZcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48U3RyaW5nW10+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwbGl0Q3N2TGluZXMoY3N2KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3BsaXRMaW5lcyhjc3YpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBFeGNlbCBCT00gdmFsdWUsIGlmIHNwZWNpZmllZCBieSB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0gY3N2XG4gICAgICogQHJldHVybnMge1Byb21pc2UuPFN0cmluZz59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaXBFeGNlbEJPTShjc3YpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXhjZWxCT00pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3N2LnJlcGxhY2UoZXhjZWxCT01SZWdleCwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNzdik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgc3BsaXRzIGEgbGluZSBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgd3JhcHBlZCBmaWVsZHNcbiAgICAgKiBAcGFyYW0gY3N2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXRMaW5lcyhjc3YpIHtcbiAgICAgICAgLy8gUGFyc2Ugb3V0IHRoZSBsaW5lLi4uXG4gICAgICAgIGxldCBsaW5lcyA9IFtdLFxuICAgICAgICAgICAgc3BsaXRMaW5lID0gW10sXG4gICAgICAgICAgICBjaGFyYWN0ZXIsXG4gICAgICAgICAgICBjaGFyQmVmb3JlLFxuICAgICAgICAgICAgY2hhckFmdGVyLFxuICAgICAgICAgICAgbmV4dE5DaGFyLFxuICAgICAgICAgICAgbGFzdENoYXJhY3RlckluZGV4ID0gY3N2Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBlb2xEZWxpbWl0ZXJMZW5ndGggPSBvcHRpb25zLmRlbGltaXRlci5lb2wubGVuZ3RoLFxuICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMgPSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlV3JhcERlbGltaXRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFyc2luZ1ZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGp1c3RQYXJzZWREb3VibGVRdW90ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZGV4ID0gMDtcblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIGxpbmUgdG8gaWRlbnRpZnkgd2hlcmUgdG8gc3BsaXQgdGhlIHZhbHVlc1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBjc3YubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBDdXJyZW50IGNoYXJhY3RlclxuICAgICAgICAgICAgY2hhcmFjdGVyID0gY3N2W2luZGV4XTtcbiAgICAgICAgICAgIC8vIFByZXZpb3VzIGNoYXJhY3RlclxuICAgICAgICAgICAgY2hhckJlZm9yZSA9IGluZGV4ID8gY3N2W2luZGV4IC0gMV0gOiAnJztcbiAgICAgICAgICAgIC8vIE5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICBjaGFyQWZ0ZXIgPSBpbmRleCA8IGxhc3RDaGFyYWN0ZXJJbmRleCA/IGNzdltpbmRleCArIDFdIDogJyc7XG4gICAgICAgICAgICAvLyBOZXh0IG4gY2hhcmFjdGVycywgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGNoYXJhY3Rlciwgd2hlcmUgbiA9IGxlbmd0aChFT0wgZGVsaW1pdGVyKVxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgZm9yIHRoZSBjaGVja2luZyBvZiBhbiBFT0wgZGVsaW1pdGVyIHdoZW4gaWYgaXQgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIGNoYXJhY3RlciAoZWcuICdcXHJcXG4nKVxuICAgICAgICAgICAgbmV4dE5DaGFyID0gdXRpbHMuZ2V0TkNoYXJhY3RlcnMoY3N2LCBpbmRleCwgZW9sRGVsaW1pdGVyTGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKChuZXh0TkNoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCAmJiAhc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciB8fFxuICAgICAgICAgICAgICAgIGluZGV4ID09PSBsYXN0Q2hhcmFjdGVySW5kZXgpICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhbiBFT0wgZGVsaW1pdGVyIG9yIHRoZSBlbmQgb2YgdGhlIGNzdiBhbmQgdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpcyBhIGZpZWxkIGRlbGltaXRlci4uLlxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN0YXJ0IGluZGV4IGlzIHRoZSBjdXJyZW50IGluZGV4IChhbmQgc2luY2UgdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpcyBhIGNvbW1hKSxcbiAgICAgICAgICAgICAgICAvLyAgIHRoZW4gdGhlIHZhbHVlIGJlaW5nIHBhcnNlZCBpcyBhbiBlbXB0eSB2YWx1ZSBhY2NvcmRpbmdseSwgYWRkIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRWYWx1ZSA9IG5leHROQ2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sICYmIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPT09IGluZGV4XG4gICAgICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGVyZSdzIGEgdmFsaWQgdmFsdWUsIGFuZCB0aGUgc3RhcnQgaW5kZXggaXNuJ3QgdGhlIGN1cnJlbnQgaW5kZXgsIGdyYWIgdGhlIHdob2xlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogY3N2LnN1YnN0cihzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4KTtcblxuICAgICAgICAgICAgICAgIC8vIFB1c2ggdGhlIHZhbHVlIGZvciB0aGUgZmllbGQgdGhhdCB3ZSB3ZXJlIHBhcnNpbmdcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChwYXJzZWRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgYSBjb21tYSwgdGhlcmUncyBzdGlsbCBhbiBhZGRpdGlvbmFsIGltcGxpZWQgZmllbGQgdmFsdWUgdHJhaWxpbmcgdGhlIGNvbW1hLlxuICAgICAgICAgICAgICAgIC8vICAgU2luY2UgdGhpcyB2YWx1ZSBpcyBlbXB0eSwgd2UgcHVzaCBhbiBleHRyYSBlbXB0eSB2YWx1ZVxuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKCcnKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIHB1c2ggdGhlIHNwbGl0IGxpbmUgdmFsdWVzIGludG8gdGhlIGxpbmVzIGFycmF5IGFuZCBjbGVhciB0aGUgc3BsaXQgbGluZVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goc3BsaXRMaW5lKTtcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUgPSBbXTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXggKyBlb2xEZWxpbWl0ZXJMZW5ndGg7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gbGFzdENoYXJhY3RlckluZGV4IHx8IG5leHROQ2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sICYmXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlbid0IGluc2lkZSB3cmFwIGRlbGltaXRlcnMgb3IgaWYgd2UgYXJlIGJ1dCB0aGUgY2hhcmFjdGVyIGJlZm9yZSB3YXMgYSB3cmFwIGRlbGltaXRlciBhbmQgd2UgZGlkbid0IGp1c3Qgc2VlIHR3b1xuICAgICAgICAgICAgICAgICghc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgIXN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBsaW5lIG9yIGNzdiAoYW5kIGN1cnJlbnQgY2hhcmFjdGVyIGlzIG5vdCBhIGZpZWxkIGRlbGltaXRlcilcblxuICAgICAgICAgICAgICAgIGxldCB0b0luZGV4ID0gaW5kZXggIT09IGxhc3RDaGFyYWN0ZXJJbmRleCB8fCBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwID8gaW5kZXggOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgcmVtYWluaW5nIHZhbHVlIGFuZCBhZGQgaXQgdG8gdGhlIHNwbGl0IGxpbmUgbGlzdCBvZiB2YWx1ZXNcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIHRvSW5kZXgpKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIHB1c2ggdGhlIHNwbGl0IGxpbmUgdmFsdWVzIGludG8gdGhlIGxpbmVzIGFycmF5IGFuZCBjbGVhciB0aGUgc3BsaXQgbGluZVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goc3BsaXRMaW5lKTtcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUgPSBbXTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXggKyBlb2xEZWxpbWl0ZXJMZW5ndGg7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoY2hhckJlZm9yZSAhPT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCB8fCBzdGF0ZVZhcmlhYmxlcy5qdXN0UGFyc2VkRG91YmxlUXVvdGUgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCkgJiZcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgdXRpbHMuZ2V0TkNoYXJhY3RlcnMoY3N2LCBpbmRleCArIDEsIGVvbERlbGltaXRlckxlbmd0aCkgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoIGEgd3JhcCB3aGljaCBpcyBub3QgcHJlY2VkZWQgYnkgYSB3cmFwIGRlbGltIGFuZCB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgYW4gRU9MIGRlbGltIChpZS4gKlwiXFxuKVxuXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIE5leHQgaXRlcmF0aW9uIHdpbGwgc3Vic3RyaW5nLCBhZGQgdGhlIHZhbHVlIHRvIHRoZSBsaW5lLCBhbmQgcHVzaCB0aGUgbGluZSBvbnRvIHRoZSBhcnJheSBvZiBsaW5lc1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgKGluZGV4ID09PSAwIHx8IHV0aWxzLmdldE5DaGFyYWN0ZXJzKGNzdiwgaW5kZXggLSAxLCBlb2xEZWxpbWl0ZXJMZW5ndGgpID09PSBvcHRpb25zLmRlbGltaXRlci5lb2wpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSB3cmFwIGRlbGltaXRlciAoaWUuIFwiKilcblxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSB3cmFwIGRlbGltaXRlciB3aXRoIGEgZmllbGQgZGVsaW1pdGVyIGFmdGVyIGl0IChpZS4gKlwiLClcblxuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKGNzdi5zdWJzdHJpbmcoc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCwgaW5kZXggKyAxKSk7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4ICsgMjsgLy8gbmV4dCB2YWx1ZSBzdGFydHMgYWZ0ZXIgdGhlIGZpZWxkIGRlbGltaXRlclxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkICYmXG4gICAgICAgICAgICAgICAgIXN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgJiYgIXN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSB3cmFwIGRlbGltaXRlciBhZnRlciBhIGNvbW1hIGFuZCB3ZSBhcmVuJ3QgaW5zaWRlIGEgd3JhcCBkZWxpbWl0ZXJcblxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiZcbiAgICAgICAgICAgICAgICAhc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciAmJiBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgd3JhcCBkZWxpbWl0ZXIgd2l0aCBhIGZpZWxkIGRlbGltaXRlciBhZnRlciBpdCAoaWUuICxcIiopXG5cbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIGluZGV4IC0gMSkpO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcnVuIGludG8gYW4gZXNjYXBlZCBxdW90ZSAoaWUuIFwiXCIpIHNraXAgcGFzdCB0aGUgc2Vjb25kIHF1b3RlXG5cbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiYgY2hhckJlZm9yZSAhPT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJlxuICAgICAgICAgICAgICAgIGNoYXJBZnRlciAhPT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiAhc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciAmJlxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBmaWVsZCBkZWxpbWl0ZXIgYW5kIGFyZSBub3QgaW5zaWRlIHRoZSB3cmFwIGRlbGltaXRlcnMgKGllLiAqLCopXG5cbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIGluZGV4KSk7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCAmJiBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmXG4gICAgICAgICAgICAgICAgY2hhckFmdGVyICE9PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmICFzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgZmllbGQgZGVsaW1pdGVyLCB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIHdhcyBhIHdyYXAgZGVsaW1pdGVyLCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBuZXh0IGNoYXJhY3RlciBpcyBub3QgYSB3cmFwIGRlbGltaXRlciAoaWUuIFwiLCopXG5cbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZG91YmxlIHF1b3RlIHN0YXRlIHZhcmlhYmxlXG4gICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5qdXN0UGFyc2VkRG91YmxlUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHJlY29yZCBsaW5lcyBmcm9tIHRoZSBzcGxpdCBDU1YgbGluZXMgYW5kIHNldHMgaXQgb24gdGhlIHBhcmFtcyBvYmplY3RcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmVSZWNvcmRMaW5lcyhwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLnJlY29yZExpbmVzID0gcGFyYW1zLmxpbmVzLnNwbGljZSgxKTsgLy8gQWxsIGxpbmVzIGV4Y2VwdCBmb3IgdGhlIGhlYWRlciBsaW5lXG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIGZvciB0aGUgcmVjb3JkIGZyb20gdGhlIGxpbmUgYXQgdGhlIHByb3ZpZGVkIGtleS5cbiAgICAgKiBAcGFyYW0gbGluZSB7U3RyaW5nW119IHNwbGl0IGxpbmUgdmFsdWVzIGZvciB0aGUgcmVjb3JkXG4gICAgICogQHBhcmFtIGtleSB7T2JqZWN0fSB7aW5kZXg6IE51bWJlciwgdmFsdWU6IFN0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZVJlY29yZFZhbHVlRnJvbUxpbmUobGluZSwga2V5KSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdmFsdWUgYXQgdGhlIGtleSdzIGluZGV4LCB1c2UgaXQ7IG90aGVyd2lzZSwgbnVsbFxuICAgICAgICBsZXQgdmFsdWUgPSBsaW5lW2tleS5pbmRleF07XG5cbiAgICAgICAgLy8gUGVyZm9ybSBhbnkgbmVjZXNzYXJ5IHZhbHVlIGNvbnZlcnNpb25zIG9uIHRoZSByZWNvcmQgdmFsdWVcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSZWNvcmRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSByZWNvcmQncyB2YWx1ZSBieSBwYXJzaW5nIHRoZSBkYXRhIHRvIGVuc3VyZSB0aGUgQ1NWIGlzXG4gICAgICogY29udmVydGVkIHRvIHRoZSBKU09OIHRoYXQgY3JlYXRlZCBpdC5cbiAgICAgKiBAcGFyYW0gZmllbGRWYWx1ZSB7U3RyaW5nfVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZWNvcmRWYWx1ZShmaWVsZFZhbHVlKSB7XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheSByZXByZXNlbnRhdGlvbiwgY29udmVydCBpdFxuICAgICAgICBsZXQgcGFyc2VkSnNvbiA9IHBhcnNlVmFsdWUoZmllbGRWYWx1ZSk7XG4gICAgICAgIC8vIElmIHBhcnNlZEpzb24gaXMgYW55dGhpbmcgYXNpZGUgZnJvbSBhbiBlcnJvciwgdGhlbiB3ZSB3YW50IHRvIHVzZSB0aGUgcGFyc2VkIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIGludGVycHJldCB2YWx1ZXMgbGlrZSAnbnVsbCcgLS0+IG51bGwsICdmYWxzZScgLS0+IGZhbHNlXG4gICAgICAgIGlmICghXy5pc0Vycm9yKHBhcnNlZEpzb24pKSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlID0gcGFyc2VkSnNvbjtcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSByZWNvcmQgdmFsdWUsIGlmIHNwZWNpZmllZCBieSB0aGUgdXNlciB2aWEgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIGZpZWxkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVJlY29yZFZhbHVlKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudHJpbUZpZWxkVmFsdWVzICYmICFfLmlzTnVsbChmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEpTT04gZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4ga2V5cyAoZGVzaWduYXRlZCBieSB0aGUgQ1NWIGhlYWRlcilcbiAgICAgKiAgIGFuZCB0aGUgdmFsdWVzIChmcm9tIHRoZSBnaXZlbiBsaW5lKVxuICAgICAqIEBwYXJhbSBrZXlzIFN0cmluZ1tdXG4gICAgICogQHBhcmFtIGxpbmUgU3RyaW5nXG4gICAgICogQHJldHVybnMge09iamVjdH0gY3JlYXRlZCBqc29uIGRvY3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQoa2V5cywgbGluZSkge1xuICAgICAgICAvLyBSZWR1Y2UgdGhlIGtleXMgaW50byBhIEpTT04gZG9jdW1lbnQgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBsaW5lXG4gICAgICAgIHJldHVybiBrZXlzLnJlZHVjZSgoZG9jdW1lbnQsIGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB2YWx1ZSBhdCB0aGUga2V5J3MgaW5kZXggaW4gdGhlIGxpbmUsIHNldCB0aGUgdmFsdWU7IG90aGVyd2lzZSBudWxsXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSByZXRyaWV2ZVJlY29yZFZhbHVlRnJvbUxpbmUobGluZSwga2V5KTtcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCB0aGUga2V5IGFuZCB2YWx1ZSB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgIHJldHVybiBwYXRoLnNldFBhdGgoZG9jdW1lbnQsIGtleS52YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgb3V0ZXJtb3N0IHdyYXAgZGVsaW1pdGVycyBmcm9tIGEgdmFsdWUsIGlmIHRoZXkgYXJlIHByZXNlbnRcbiAgICAgKiBPdGhlcndpc2UsIHRoZSBub24td3JhcHBlZCB2YWx1ZSBpcyByZXR1cm5lZCBhcyBpc1xuICAgICAqIEBwYXJhbSBmaWVsZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVXcmFwRGVsaW1pdGVyc0Zyb21WYWx1ZShmaWVsZFZhbHVlKSB7XG4gICAgICAgIGxldCBmaXJzdENoYXIgPSBmaWVsZFZhbHVlWzBdLFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gZmllbGRWYWx1ZS5sZW5ndGggLSAxLFxuICAgICAgICAgICAgbGFzdENoYXIgPSBmaWVsZFZhbHVlW2xhc3RJbmRleF07XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCBzdGFydHMgYW5kIGVuZHMgd2l0aCBhIHdyYXAgZGVsaW1pdGVyXG4gICAgICAgIGlmIChmaXJzdENoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgbGFzdENoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXApIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLnN1YnN0cigxLCBsYXN0SW5kZXggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmVzY2FwZXMgd3JhcCBkZWxpbWl0ZXJzIGJ5IHJlcGxhY2luZyBkdXBsaWNhdGVzIHdpdGggYSBzaW5nbGUgKGVnLiBcIlwiIC0+IFwiKVxuICAgICAqIFRoaXMgaXMgZG9uZSBpbiBvcmRlciB0byBwYXJzZSBSRkMgNDE4MCBjb21wbGlhbnQgQ1NWIGJhY2sgdG8gSlNPTlxuICAgICAqIEBwYXJhbSBmaWVsZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZVdyYXBEZWxpbWl0ZXJJbkZpZWxkKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUucmVwbGFjZShlc2NhcGVkV3JhcERlbGltaXRlclJlZ2V4LCBvcHRpb25zLmRlbGltaXRlci53cmFwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWluIGhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IHRoZSBDU1YgdG8gdGhlIEpTT04gZG9jdW1lbnQgYXJyYXlcbiAgICAgKiBAcGFyYW0gcGFyYW1zIHtPYmplY3R9IHtsaW5lczogW1N0cmluZ10sIGNhbGxiYWNrOiBGdW5jdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUmVjb3JkTGluZXMocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcy5qc29uID0gcGFyYW1zLnJlY29yZExpbmVzLnJlZHVjZSgoZ2VuZXJhdGVkSnNvbk9iamVjdHMsIGxpbmUpID0+IHsgLy8gRm9yIGVhY2ggbGluZSwgY3JlYXRlIHRoZSBkb2N1bWVudCBhbmQgYWRkIGl0IHRvIHRoZSBhcnJheSBvZiBkb2N1bWVudHNcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLm1hcCgoZmllbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIG5lY2Vzc2FyeSBvcGVyYXRpb25zIG9uIGVhY2ggbGluZVxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSByZW1vdmVXcmFwRGVsaW1pdGVyc0Zyb21WYWx1ZShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gdW5lc2NhcGVXcmFwRGVsaW1pdGVySW5GaWVsZChmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gdHJpbVJlY29yZFZhbHVlKGZpZWxkVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGV0IGdlbmVyYXRlZERvY3VtZW50ID0gY3JlYXRlRG9jdW1lbnQocGFyYW1zLmhlYWRlckZpZWxkcywgbGluZSk7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSnNvbk9iamVjdHMuY29uY2F0KGdlbmVyYXRlZERvY3VtZW50KTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcGFyc2UgdGhlIHByb3ZpZGVkIHZhbHVlLiBJZiBpdCBpcyBub3QgcGFyc2FibGUsIHRoZW4gYW4gZXJyb3IgaXMgcmV0dXJuZWRcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmdSZXByZXNlbnRhdGlvbih2YWx1ZSwgb3B0aW9ucykgJiYgIXV0aWxzLmlzRGF0ZVJlcHJlc2VudGF0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHBhcnNlZEpzb24gPSBKU09OLnBhcnNlKHZhbHVlKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHBhcnNlZCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlbiB3ZSBhbHNvIG5lZWQgdG8gdHJpbSByZWNvcmQgdmFsdWVzLCBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocGFyc2VkSnNvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkSnNvbi5tYXAodHJpbVJlY29yZFZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEpzb247XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgZXhwb3J0ZWQgY3N2Mmpzb24gZnVuY3Rpb25cbiAgICAgKiBUYWtlcyBvcHRpb25zIGFzIGEgZG9jdW1lbnQsIGRhdGEgYXMgYSBDU1Ygc3RyaW5nLCBhbmQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgdXNlZCB0byByZXBvcnQgdGhlIHJlc3VsdHNcbiAgICAgKiBAcGFyYW0gZGF0YSBTdHJpbmcgY3N2IHN0cmluZ1xuICAgICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnQoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gU3BsaXQgdGhlIENTViBpbnRvIGxpbmVzIHVzaW5nIHRoZSBzcGVjaWZpZWQgRU9MIG9wdGlvblxuICAgICAgICAvLyB2YWxpZGF0ZUNzdihkYXRhLCBjYWxsYmFjaylcbiAgICAgICAgLy8gICAgIC50aGVuKHN0cmlwRXhjZWxCT00pXG4gICAgICAgIHN0cmlwRXhjZWxCT00oZGF0YSlcbiAgICAgICAgICAgIC50aGVuKHNwbGl0Q3N2TGluZXMpXG4gICAgICAgICAgICAudGhlbihyZXRyaWV2ZUhlYWRpbmcpIC8vIFJldHJpZXZlIHRoZSBoZWFkaW5ncyBmcm9tIHRoZSBDU1YsIHVubGVzcyB0aGUgdXNlciBzcGVjaWZpZWQgdGhlIGtleXNcbiAgICAgICAgICAgIC50aGVuKHJldHJpZXZlUmVjb3JkTGluZXMpIC8vIFJldHJpZXZlIHRoZSByZWNvcmQgbGluZXMgZnJvbSB0aGUgQ1NWXG4gICAgICAgICAgICAudGhlbih0cmFuc2Zvcm1SZWNvcmRMaW5lcykgLy8gUmV0cmlldmUgdGhlIEpTT04gZG9jdW1lbnQgYXJyYXlcbiAgICAgICAgICAgIC50aGVuKChwYXJhbXMpID0+IGNhbGxiYWNrKG51bGwsIHBhcmFtcy5qc29uKSkgLy8gU2VuZCB0aGUgZGF0YSBiYWNrIHRvIHRoZSBjYWxsZXJcbiAgICAgICAgICAgIC5jYXRjaChjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udmVydCxcbiAgICAgICAgdmFsaWRhdGlvbkZuOiBfLmlzU3RyaW5nLFxuICAgICAgICB2YWxpZGF0aW9uTWVzc2FnZXM6IGNvbnN0YW50cy5lcnJvcnMuY3N2Mmpzb25cbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IENzdjJKc29uIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/json-2-csv/src/csv2json.js\n");

/***/ }),

/***/ "./node_modules/json-2-csv/src/json2csv.js":
/*!*************************************************!*\
  !*** ./node_modules/json-2-csv/src/json2csv.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nlet constants = __webpack_require__(/*! ./constants.json */ \"./node_modules/json-2-csv/src/constants.json\"),\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/json-2-csv/src/utils.js\"),\n    _ = __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js\"),\n    path = __webpack_require__(/*! doc-path */ \"./node_modules/doc-path/src/path.js\"),\n    deeks = __webpack_require__(/*! deeks */ \"./node_modules/deeks/src/deeks.js\");\n\nconst Json2Csv = function(options) {\n    const wrapDelimiterCheckRegex = new RegExp(options.delimiter.wrap, 'g'),\n        crlfSearchRegex = /\\r?\\n|\\r/,\n        deeksOptions = {\n            expandArrayObjects: options.expandArrayObjects,\n            ignoreEmptyArraysWhenExpanding: options.expandArrayObjects\n        };\n\n    /** HEADER FIELD FUNCTIONS **/\n\n    /**\n     * Returns the list of data field names of all documents in the provided list\n     * @param data {Array<Object>} Data to be converted\n     * @returns {Promise.<Array[String]>}\n     */\n    function getFieldNameList(data) {\n        // If keys weren't specified, then we'll use the list of keys generated by the deeks module\n        return Promise.resolve(deeks.deepKeysFromList(data, deeksOptions));\n    }\n\n    /**\n     * Processes the schemas by checking for schema differences, if so desired.\n     * If schema differences are not to be checked, then it resolves the unique\n     * list of field names.\n     * @param documentSchemas\n     * @returns {Promise.<Array[String]>}\n     */\n    function processSchemas(documentSchemas) {\n        // If the user wants to check for the same schema (regardless of schema ordering)\n        if (options.checkSchemaDifferences) {\n            return checkSchemaDifferences(documentSchemas);\n        } else {\n            // Otherwise, we do not care if the schemas are different, so we should get the unique list of keys\n            let uniqueFieldNames = _.uniq(_.flatten(documentSchemas));\n            return Promise.resolve(uniqueFieldNames);\n        }\n    }\n\n    /**\n     * This function performs the schema difference check, if the user specifies that it should be checked.\n     * If there are no field names, then there are no differences.\n     * Otherwise, we get the first schema and the remaining list of schemas\n     * @param documentSchemas\n     * @returns {*}\n     */\n    function checkSchemaDifferences(documentSchemas) {\n        // have multiple documents - ensure only one schema (regardless of field ordering)\n        let firstDocSchema = documentSchemas[0],\n            restOfDocumentSchemas = documentSchemas.slice(1),\n            schemaDifferences = computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas);\n\n        // If there are schema inconsistencies, throw a schema not the same error\n        if (schemaDifferences) {\n            return Promise.reject(new Error(constants.errors.json2csv.notSameSchema));\n        }\n\n        return Promise.resolve(firstDocSchema);\n    }\n\n    /**\n     * Computes the number of schema differences\n     * @param firstDocSchema\n     * @param restOfDocumentSchemas\n     * @returns {*}\n     */\n    function computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas) {\n        return restOfDocumentSchemas.reduce((schemaDifferences, documentSchema) => {\n            // If there is a difference between the schemas, increment the counter of schema inconsistencies\n            let numberOfDifferences = utils.computeSchemaDifferences(firstDocSchema, documentSchema).length;\n            return numberOfDifferences > 0\n                ? schemaDifferences + 1\n                : schemaDifferences;\n        }, 0);\n    }\n\n    /**\n     * If so specified, this sorts the header field names alphabetically\n     * @param fieldNames {Array<String>}\n     * @returns {Array<String>} sorted field names, or unsorted if sorting not specified\n     */\n    function sortHeaderFields(fieldNames) {\n        if (options.sortHeader) {\n            return fieldNames.sort();\n        }\n        return fieldNames;\n    }\n\n    /**\n     * Trims the header fields, if the user desires them to be trimmed.\n     * @param params\n     * @returns {*}\n     */\n    function trimHeaderFields(params) {\n        if (options.trimHeaderFields) {\n            params.headerFields = params.headerFields.map((field) => field.split('.')\n                .map((component) => component.trim())\n                .join('.')\n            );\n        }\n        return params;\n    }\n\n    /**\n     * Wrap the headings, if desired by the user.\n     * @param params\n     * @returns {*}\n     */\n    function wrapHeaderFields(params) {\n        // only perform this if we are actually prepending the header\n        if (options.prependHeader) {\n            params.headerFields = params.headerFields.map(function(headingKey) {\n                return wrapFieldValueIfNecessary(headingKey);\n            });\n        }\n        return params;\n    }\n\n    /**\n     * Generates the CSV header string by joining the headerFields by the field delimiter\n     * @param params\n     * @returns {*}\n     */\n    function generateCsvHeader(params) {\n        params.header = params.headerFields.join(options.delimiter.field);\n        return params;\n    }\n\n    /**\n     * Retrieve the headings for all documents and return it.\n     * This checks that all documents have the same schema.\n     * @param data\n     * @returns {Promise}\n     */\n    function retrieveHeaderFields(data) {\n        if (options.keys) {\n            return Promise.resolve(options.keys)\n                .then(sortHeaderFields);\n        }\n\n        return getFieldNameList(data)\n            .then(processSchemas)\n            .then(sortHeaderFields);\n    }\n\n    /** RECORD FIELD FUNCTIONS **/\n\n    /**\n     * Main function which handles the processing of a record, or document to be converted to CSV format\n     * This function specifies and performs the necessary operations in the necessary order\n     * in order to obtain the data and convert it to CSV form while maintaining RFC 4180 compliance.\n     * * Order of operations:\n     * - Get fields from provided key list (as array of actual values)\n     * - Convert the values to csv/string representation [possible option here for custom converters?]\n     * - Trim fields\n     * - Determine if they need to be wrapped (& wrap if necessary)\n     * - Combine values for each line (by joining by field delimiter)\n     * @param params\n     * @returns {*}\n     */\n    function processRecords(params) {\n        params.records = params.records.map((record) => {\n            // Retrieve data for each of the headerFields from this record\n            let recordFieldData = retrieveRecordFieldData(record, params.headerFields),\n\n                // Process the data in this record and return the\n                processedRecordData = recordFieldData.map((fieldValue) => {\n                    fieldValue = trimRecordFieldValue(fieldValue);\n                    fieldValue = recordFieldValueToString(fieldValue);\n                    fieldValue = wrapFieldValueIfNecessary(fieldValue);\n\n                    return fieldValue;\n                });\n\n            // Join the record data by the field delimiter\n            return generateCsvRowFromRecord(processedRecordData);\n        }).join(options.delimiter.eol);\n\n        return params;\n    }\n\n    /**\n     * Helper function intended to process *just* array values when the expandArrayObjects setting is set to true\n     * @param recordFieldValue\n     * @returns {*} processed array value\n     */\n    function processRecordFieldDataForExpandedArrayObject(recordFieldValue) {\n        let filteredRecordFieldValue = utils.removeEmptyFields(recordFieldValue);\n\n        // If we have an array and it's either empty of full of empty values, then use an empty value representation\n        if (!recordFieldValue.length || !filteredRecordFieldValue.length) {\n            return options.emptyFieldValue || '';\n        } else if (filteredRecordFieldValue.length === 1) {\n            // Otherwise, we have an array of actual values...\n            // Since we are expanding array objects, we will want to key in on values of objects.\n            return filteredRecordFieldValue[0]; // Extract the single value in the array\n        }\n\n        return recordFieldValue;\n    }\n\n    /**\n     * Gets all field values from a particular record for the given list of fields\n     * @param record\n     * @param fields\n     * @returns {Array}\n     */\n    function retrieveRecordFieldData(record, fields) {\n        let recordValues = [];\n\n        fields.forEach((field) => {\n            let recordFieldValue = path.evaluatePath(record, field);\n\n            if (!_.isUndefined(options.emptyFieldValue) && utils.isEmptyField(recordFieldValue)) {\n                recordFieldValue = options.emptyFieldValue;\n            } else if (options.expandArrayObjects && Array.isArray(recordFieldValue)) {\n                recordFieldValue = processRecordFieldDataForExpandedArrayObject(recordFieldValue);\n            }\n\n            recordValues.push(recordFieldValue);\n        });\n\n        return recordValues;\n    }\n\n    /**\n     * Converts a record field value to its string representation\n     * @param fieldValue\n     * @returns {*}\n     */\n    function recordFieldValueToString(fieldValue) {\n        if (_.isArray(fieldValue) || _.isObject(fieldValue) && !_.isDate(fieldValue)) {\n            return JSON.stringify(fieldValue);\n        } else if (_.isUndefined(fieldValue)) {\n            return 'undefined';\n        } else if (_.isNull(fieldValue)) {\n            return 'null';\n        } else {\n            return fieldValue.toString();\n        }\n    }\n\n    /**\n     * Trims the record field value, if specified by the user's provided options\n     * @param fieldValue\n     * @returns {*}\n     */\n    function trimRecordFieldValue(fieldValue) {\n        if (options.trimFieldValues) {\n            if (_.isArray(fieldValue)) {\n                return fieldValue.map(trimRecordFieldValue);\n            } else if (_.isString(fieldValue)) {\n                return fieldValue.trim();\n            }\n            return fieldValue;\n        }\n        return fieldValue;\n    }\n\n    /**\n     * Escapes quotation marks in the field value, if necessary, and appropriately\n     * wraps the record field value if it contains a comma (field delimiter),\n     * quotation mark (wrap delimiter), or a line break (CRLF)\n     * @param fieldValue\n     * @returns {*}\n     */\n    function wrapFieldValueIfNecessary(fieldValue) {\n        const wrapDelimiter = options.delimiter.wrap;\n\n        // eg. includes quotation marks (default delimiter)\n        if (fieldValue.includes(options.delimiter.wrap)) {\n            // add an additional quotation mark before each quotation mark appearing in the field value\n            fieldValue = fieldValue.replace(wrapDelimiterCheckRegex, wrapDelimiter + wrapDelimiter);\n        }\n        // if the field contains a comma (field delimiter), quotation mark (wrap delimiter), line break, or CRLF\n        //   then enclose it in quotation marks (wrap delimiter)\n        if (fieldValue.includes(options.delimiter.field) ||\n            fieldValue.includes(options.delimiter.wrap) ||\n            fieldValue.match(crlfSearchRegex)) {\n            // wrap the field's value in a wrap delimiter (quotation marks by default)\n            fieldValue = wrapDelimiter + fieldValue + wrapDelimiter;\n        }\n\n        return fieldValue;\n    }\n\n    /**\n     * Generates the CSV record string by joining the field values together by the field delimiter\n     * @param recordFieldValues\n     */\n    function generateCsvRowFromRecord(recordFieldValues) {\n        return recordFieldValues.join(options.delimiter.field);\n    }\n\n    /** CSV COMPONENT COMBINER/FINAL PROCESSOR **/\n    /**\n     * Performs the final CSV construction by combining the fields in the appropriate\n     * order depending on the provided options values and sends the generated CSV\n     * back to the user\n     * @param params\n     */\n    function generateCsvFromComponents(params) {\n        let header = params.header,\n            records = params.records,\n\n            // If we are prepending the header, then add an EOL, otherwise just return the records\n            csv = (options.excelBOM ? constants.values.excelBOM : '') +\n                (options.prependHeader ? header + options.delimiter.eol : '') +\n                records;\n\n        return params.callback(null, csv);\n    }\n\n    /** MAIN CONVERTER FUNCTION **/\n\n    /**\n     * Internally exported json2csv function\n     * Takes data as either a document or array of documents and a callback that will be used to report the results\n     * @param data {Object|Array<Object>} documents to be converted to csv\n     * @param callback {Function} callback function\n     */\n    function convert(data, callback) {\n        // Single document, not an array\n        if (_.isObject(data) && !data.length) {\n            data = [data]; // Convert to an array of the given document\n        }\n\n        // Retrieve the heading and then generate the CSV with the keys that are identified\n        retrieveHeaderFields(data)\n            .then((headerFields) => ({\n                headerFields,\n                callback,\n                records: data\n            }))\n            .then(processRecords)\n            .then(wrapHeaderFields)\n            .then(trimHeaderFields)\n            .then(generateCsvHeader)\n            .then(generateCsvFromComponents)\n            .catch(callback);\n    }\n\n    return {\n        convert,\n        validationFn: _.isObject,\n        validationMessages: constants.errors.json2csv\n    };\n};\n\nmodule.exports = { Json2Csv };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9zcmMvanNvbjJjc3YuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9zcmMvanNvbjJjc3YuanM/YjkwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmxldCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy5qc29uJyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyksXG4gICAgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSxcbiAgICBwYXRoID0gcmVxdWlyZSgnZG9jLXBhdGgnKSxcbiAgICBkZWVrcyA9IHJlcXVpcmUoJ2RlZWtzJyk7XG5cbmNvbnN0IEpzb24yQ3N2ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGNvbnN0IHdyYXBEZWxpbWl0ZXJDaGVja1JlZ2V4ID0gbmV3IFJlZ0V4cChvcHRpb25zLmRlbGltaXRlci53cmFwLCAnZycpLFxuICAgICAgICBjcmxmU2VhcmNoUmVnZXggPSAvXFxyP1xcbnxcXHIvLFxuICAgICAgICBkZWVrc09wdGlvbnMgPSB7XG4gICAgICAgICAgICBleHBhbmRBcnJheU9iamVjdHM6IG9wdGlvbnMuZXhwYW5kQXJyYXlPYmplY3RzLFxuICAgICAgICAgICAgaWdub3JlRW1wdHlBcnJheXNXaGVuRXhwYW5kaW5nOiBvcHRpb25zLmV4cGFuZEFycmF5T2JqZWN0c1xuICAgICAgICB9O1xuXG4gICAgLyoqIEhFQURFUiBGSUVMRCBGVU5DVElPTlMgKiovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGRhdGEgZmllbGQgbmFtZXMgb2YgYWxsIGRvY3VtZW50cyBpbiB0aGUgcHJvdmlkZWQgbGlzdFxuICAgICAqIEBwYXJhbSBkYXRhIHtBcnJheTxPYmplY3Q+fSBEYXRhIHRvIGJlIGNvbnZlcnRlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheVtTdHJpbmddPn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGaWVsZE5hbWVMaXN0KGRhdGEpIHtcbiAgICAgICAgLy8gSWYga2V5cyB3ZXJlbid0IHNwZWNpZmllZCwgdGhlbiB3ZSdsbCB1c2UgdGhlIGxpc3Qgb2Yga2V5cyBnZW5lcmF0ZWQgYnkgdGhlIGRlZWtzIG1vZHVsZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlZWtzLmRlZXBLZXlzRnJvbUxpc3QoZGF0YSwgZGVla3NPcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSBzY2hlbWFzIGJ5IGNoZWNraW5nIGZvciBzY2hlbWEgZGlmZmVyZW5jZXMsIGlmIHNvIGRlc2lyZWQuXG4gICAgICogSWYgc2NoZW1hIGRpZmZlcmVuY2VzIGFyZSBub3QgdG8gYmUgY2hlY2tlZCwgdGhlbiBpdCByZXNvbHZlcyB0aGUgdW5pcXVlXG4gICAgICogbGlzdCBvZiBmaWVsZCBuYW1lcy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRTY2hlbWFzXG4gICAgICogQHJldHVybnMge1Byb21pc2UuPEFycmF5W1N0cmluZ10+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NTY2hlbWFzKGRvY3VtZW50U2NoZW1hcykge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciB3YW50cyB0byBjaGVjayBmb3IgdGhlIHNhbWUgc2NoZW1hIChyZWdhcmRsZXNzIG9mIHNjaGVtYSBvcmRlcmluZylcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hlY2tTY2hlbWFEaWZmZXJlbmNlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrU2NoZW1hRGlmZmVyZW5jZXMoZG9jdW1lbnRTY2hlbWFzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgZG8gbm90IGNhcmUgaWYgdGhlIHNjaGVtYXMgYXJlIGRpZmZlcmVudCwgc28gd2Ugc2hvdWxkIGdldCB0aGUgdW5pcXVlIGxpc3Qgb2Yga2V5c1xuICAgICAgICAgICAgbGV0IHVuaXF1ZUZpZWxkTmFtZXMgPSBfLnVuaXEoXy5mbGF0dGVuKGRvY3VtZW50U2NoZW1hcykpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmlxdWVGaWVsZE5hbWVzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgdGhlIHNjaGVtYSBkaWZmZXJlbmNlIGNoZWNrLCBpZiB0aGUgdXNlciBzcGVjaWZpZXMgdGhhdCBpdCBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gZmllbGQgbmFtZXMsIHRoZW4gdGhlcmUgYXJlIG5vIGRpZmZlcmVuY2VzLlxuICAgICAqIE90aGVyd2lzZSwgd2UgZ2V0IHRoZSBmaXJzdCBzY2hlbWEgYW5kIHRoZSByZW1haW5pbmcgbGlzdCBvZiBzY2hlbWFzXG4gICAgICogQHBhcmFtIGRvY3VtZW50U2NoZW1hc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrU2NoZW1hRGlmZmVyZW5jZXMoZG9jdW1lbnRTY2hlbWFzKSB7XG4gICAgICAgIC8vIGhhdmUgbXVsdGlwbGUgZG9jdW1lbnRzIC0gZW5zdXJlIG9ubHkgb25lIHNjaGVtYSAocmVnYXJkbGVzcyBvZiBmaWVsZCBvcmRlcmluZylcbiAgICAgICAgbGV0IGZpcnN0RG9jU2NoZW1hID0gZG9jdW1lbnRTY2hlbWFzWzBdLFxuICAgICAgICAgICAgcmVzdE9mRG9jdW1lbnRTY2hlbWFzID0gZG9jdW1lbnRTY2hlbWFzLnNsaWNlKDEpLFxuICAgICAgICAgICAgc2NoZW1hRGlmZmVyZW5jZXMgPSBjb21wdXRlTnVtYmVyT2ZTY2hlbWFEaWZmZXJlbmNlcyhmaXJzdERvY1NjaGVtYSwgcmVzdE9mRG9jdW1lbnRTY2hlbWFzKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgc2NoZW1hIGluY29uc2lzdGVuY2llcywgdGhyb3cgYSBzY2hlbWEgbm90IHRoZSBzYW1lIGVycm9yXG4gICAgICAgIGlmIChzY2hlbWFEaWZmZXJlbmNlcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihjb25zdGFudHMuZXJyb3JzLmpzb24yY3N2Lm5vdFNhbWVTY2hlbWEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmlyc3REb2NTY2hlbWEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBudW1iZXIgb2Ygc2NoZW1hIGRpZmZlcmVuY2VzXG4gICAgICogQHBhcmFtIGZpcnN0RG9jU2NoZW1hXG4gICAgICogQHBhcmFtIHJlc3RPZkRvY3VtZW50U2NoZW1hc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVOdW1iZXJPZlNjaGVtYURpZmZlcmVuY2VzKGZpcnN0RG9jU2NoZW1hLCByZXN0T2ZEb2N1bWVudFNjaGVtYXMpIHtcbiAgICAgICAgcmV0dXJuIHJlc3RPZkRvY3VtZW50U2NoZW1hcy5yZWR1Y2UoKHNjaGVtYURpZmZlcmVuY2VzLCBkb2N1bWVudFNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNjaGVtYXMsIGluY3JlbWVudCB0aGUgY291bnRlciBvZiBzY2hlbWEgaW5jb25zaXN0ZW5jaWVzXG4gICAgICAgICAgICBsZXQgbnVtYmVyT2ZEaWZmZXJlbmNlcyA9IHV0aWxzLmNvbXB1dGVTY2hlbWFEaWZmZXJlbmNlcyhmaXJzdERvY1NjaGVtYSwgZG9jdW1lbnRTY2hlbWEpLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJPZkRpZmZlcmVuY2VzID4gMFxuICAgICAgICAgICAgICAgID8gc2NoZW1hRGlmZmVyZW5jZXMgKyAxXG4gICAgICAgICAgICAgICAgOiBzY2hlbWFEaWZmZXJlbmNlcztcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgc28gc3BlY2lmaWVkLCB0aGlzIHNvcnRzIHRoZSBoZWFkZXIgZmllbGQgbmFtZXMgYWxwaGFiZXRpY2FsbHlcbiAgICAgKiBAcGFyYW0gZmllbGROYW1lcyB7QXJyYXk8U3RyaW5nPn1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8U3RyaW5nPn0gc29ydGVkIGZpZWxkIG5hbWVzLCBvciB1bnNvcnRlZCBpZiBzb3J0aW5nIG5vdCBzcGVjaWZpZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0SGVhZGVyRmllbGRzKGZpZWxkTmFtZXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc29ydEhlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkTmFtZXMuc29ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZE5hbWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSBoZWFkZXIgZmllbGRzLCBpZiB0aGUgdXNlciBkZXNpcmVzIHRoZW0gdG8gYmUgdHJpbW1lZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUhlYWRlckZpZWxkcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudHJpbUhlYWRlckZpZWxkcykge1xuICAgICAgICAgICAgcGFyYW1zLmhlYWRlckZpZWxkcyA9IHBhcmFtcy5oZWFkZXJGaWVsZHMubWFwKChmaWVsZCkgPT4gZmllbGQuc3BsaXQoJy4nKVxuICAgICAgICAgICAgICAgIC5tYXAoKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LnRyaW0oKSlcbiAgICAgICAgICAgICAgICAuam9pbignLicpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JhcCB0aGUgaGVhZGluZ3MsIGlmIGRlc2lyZWQgYnkgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBIZWFkZXJGaWVsZHMocGFyYW1zKSB7XG4gICAgICAgIC8vIG9ubHkgcGVyZm9ybSB0aGlzIGlmIHdlIGFyZSBhY3R1YWxseSBwcmVwZW5kaW5nIHRoZSBoZWFkZXJcbiAgICAgICAgaWYgKG9wdGlvbnMucHJlcGVuZEhlYWRlcikge1xuICAgICAgICAgICAgcGFyYW1zLmhlYWRlckZpZWxkcyA9IHBhcmFtcy5oZWFkZXJGaWVsZHMubWFwKGZ1bmN0aW9uKGhlYWRpbmdLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcEZpZWxkVmFsdWVJZk5lY2Vzc2FyeShoZWFkaW5nS2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBDU1YgaGVhZGVyIHN0cmluZyBieSBqb2luaW5nIHRoZSBoZWFkZXJGaWVsZHMgYnkgdGhlIGZpZWxkIGRlbGltaXRlclxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNzdkhlYWRlcihwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLmhlYWRlciA9IHBhcmFtcy5oZWFkZXJGaWVsZHMuam9pbihvcHRpb25zLmRlbGltaXRlci5maWVsZCk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGhlYWRpbmdzIGZvciBhbGwgZG9jdW1lbnRzIGFuZCByZXR1cm4gaXQuXG4gICAgICogVGhpcyBjaGVja3MgdGhhdCBhbGwgZG9jdW1lbnRzIGhhdmUgdGhlIHNhbWUgc2NoZW1hLlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmVIZWFkZXJGaWVsZHMoZGF0YSkge1xuICAgICAgICBpZiAob3B0aW9ucy5rZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMua2V5cylcbiAgICAgICAgICAgICAgICAudGhlbihzb3J0SGVhZGVyRmllbGRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRGaWVsZE5hbWVMaXN0KGRhdGEpXG4gICAgICAgICAgICAudGhlbihwcm9jZXNzU2NoZW1hcylcbiAgICAgICAgICAgIC50aGVuKHNvcnRIZWFkZXJGaWVsZHMpO1xuICAgIH1cblxuICAgIC8qKiBSRUNPUkQgRklFTEQgRlVOQ1RJT05TICoqL1xuXG4gICAgLyoqXG4gICAgICogTWFpbiBmdW5jdGlvbiB3aGljaCBoYW5kbGVzIHRoZSBwcm9jZXNzaW5nIG9mIGEgcmVjb3JkLCBvciBkb2N1bWVudCB0byBiZSBjb252ZXJ0ZWQgdG8gQ1NWIGZvcm1hdFxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3BlY2lmaWVzIGFuZCBwZXJmb3JtcyB0aGUgbmVjZXNzYXJ5IG9wZXJhdGlvbnMgaW4gdGhlIG5lY2Vzc2FyeSBvcmRlclxuICAgICAqIGluIG9yZGVyIHRvIG9idGFpbiB0aGUgZGF0YSBhbmQgY29udmVydCBpdCB0byBDU1YgZm9ybSB3aGlsZSBtYWludGFpbmluZyBSRkMgNDE4MCBjb21wbGlhbmNlLlxuICAgICAqICogT3JkZXIgb2Ygb3BlcmF0aW9uczpcbiAgICAgKiAtIEdldCBmaWVsZHMgZnJvbSBwcm92aWRlZCBrZXkgbGlzdCAoYXMgYXJyYXkgb2YgYWN0dWFsIHZhbHVlcylcbiAgICAgKiAtIENvbnZlcnQgdGhlIHZhbHVlcyB0byBjc3Yvc3RyaW5nIHJlcHJlc2VudGF0aW9uIFtwb3NzaWJsZSBvcHRpb24gaGVyZSBmb3IgY3VzdG9tIGNvbnZlcnRlcnM/XVxuICAgICAqIC0gVHJpbSBmaWVsZHNcbiAgICAgKiAtIERldGVybWluZSBpZiB0aGV5IG5lZWQgdG8gYmUgd3JhcHBlZCAoJiB3cmFwIGlmIG5lY2Vzc2FyeSlcbiAgICAgKiAtIENvbWJpbmUgdmFsdWVzIGZvciBlYWNoIGxpbmUgKGJ5IGpvaW5pbmcgYnkgZmllbGQgZGVsaW1pdGVyKVxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVjb3JkcyhwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLnJlY29yZHMgPSBwYXJhbXMucmVjb3Jkcy5tYXAoKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgZGF0YSBmb3IgZWFjaCBvZiB0aGUgaGVhZGVyRmllbGRzIGZyb20gdGhpcyByZWNvcmRcbiAgICAgICAgICAgIGxldCByZWNvcmRGaWVsZERhdGEgPSByZXRyaWV2ZVJlY29yZEZpZWxkRGF0YShyZWNvcmQsIHBhcmFtcy5oZWFkZXJGaWVsZHMpLFxuXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgZGF0YSBpbiB0aGlzIHJlY29yZCBhbmQgcmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZFJlY29yZERhdGEgPSByZWNvcmRGaWVsZERhdGEubWFwKChmaWVsZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSB0cmltUmVjb3JkRmllbGRWYWx1ZShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHJlY29yZEZpZWxkVmFsdWVUb1N0cmluZyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHdyYXBGaWVsZFZhbHVlSWZOZWNlc3NhcnkoZmllbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEpvaW4gdGhlIHJlY29yZCBkYXRhIGJ5IHRoZSBmaWVsZCBkZWxpbWl0ZXJcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUNzdlJvd0Zyb21SZWNvcmQocHJvY2Vzc2VkUmVjb3JkRGF0YSk7XG4gICAgICAgIH0pLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIuZW9sKTtcblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBpbnRlbmRlZCB0byBwcm9jZXNzICpqdXN0KiBhcnJheSB2YWx1ZXMgd2hlbiB0aGUgZXhwYW5kQXJyYXlPYmplY3RzIHNldHRpbmcgaXMgc2V0IHRvIHRydWVcbiAgICAgKiBAcGFyYW0gcmVjb3JkRmllbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfSBwcm9jZXNzZWQgYXJyYXkgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVjb3JkRmllbGREYXRhRm9yRXhwYW5kZWRBcnJheU9iamVjdChyZWNvcmRGaWVsZFZhbHVlKSB7XG4gICAgICAgIGxldCBmaWx0ZXJlZFJlY29yZEZpZWxkVmFsdWUgPSB1dGlscy5yZW1vdmVFbXB0eUZpZWxkcyhyZWNvcmRGaWVsZFZhbHVlKTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFycmF5IGFuZCBpdCdzIGVpdGhlciBlbXB0eSBvZiBmdWxsIG9mIGVtcHR5IHZhbHVlcywgdGhlbiB1c2UgYW4gZW1wdHkgdmFsdWUgcmVwcmVzZW50YXRpb25cbiAgICAgICAgaWYgKCFyZWNvcmRGaWVsZFZhbHVlLmxlbmd0aCB8fCAhZmlsdGVyZWRSZWNvcmRGaWVsZFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW1wdHlGaWVsZFZhbHVlIHx8ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlcmVkUmVjb3JkRmllbGRWYWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgaGF2ZSBhbiBhcnJheSBvZiBhY3R1YWwgdmFsdWVzLi4uXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBhcmUgZXhwYW5kaW5nIGFycmF5IG9iamVjdHMsIHdlIHdpbGwgd2FudCB0byBrZXkgaW4gb24gdmFsdWVzIG9mIG9iamVjdHMuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRSZWNvcmRGaWVsZFZhbHVlWzBdOyAvLyBFeHRyYWN0IHRoZSBzaW5nbGUgdmFsdWUgaW4gdGhlIGFycmF5XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjb3JkRmllbGRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBmaWVsZCB2YWx1ZXMgZnJvbSBhIHBhcnRpY3VsYXIgcmVjb3JkIGZvciB0aGUgZ2l2ZW4gbGlzdCBvZiBmaWVsZHNcbiAgICAgKiBAcGFyYW0gcmVjb3JkXG4gICAgICogQHBhcmFtIGZpZWxkc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZVJlY29yZEZpZWxkRGF0YShyZWNvcmQsIGZpZWxkcykge1xuICAgICAgICBsZXQgcmVjb3JkVmFsdWVzID0gW107XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVjb3JkRmllbGRWYWx1ZSA9IHBhdGguZXZhbHVhdGVQYXRoKHJlY29yZCwgZmllbGQpO1xuXG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5lbXB0eUZpZWxkVmFsdWUpICYmIHV0aWxzLmlzRW1wdHlGaWVsZChyZWNvcmRGaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlY29yZEZpZWxkVmFsdWUgPSBvcHRpb25zLmVtcHR5RmllbGRWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5leHBhbmRBcnJheU9iamVjdHMgJiYgQXJyYXkuaXNBcnJheShyZWNvcmRGaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlY29yZEZpZWxkVmFsdWUgPSBwcm9jZXNzUmVjb3JkRmllbGREYXRhRm9yRXhwYW5kZWRBcnJheU9iamVjdChyZWNvcmRGaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVjb3JkVmFsdWVzLnB1c2gocmVjb3JkRmllbGRWYWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWNvcmRWYWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSByZWNvcmQgZmllbGQgdmFsdWUgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSBmaWVsZFZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjb3JkRmllbGRWYWx1ZVRvU3RyaW5nKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgaWYgKF8uaXNBcnJheShmaWVsZFZhbHVlKSB8fCBfLmlzT2JqZWN0KGZpZWxkVmFsdWUpICYmICFfLmlzRGF0ZShmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGZpZWxkVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNVbmRlZmluZWQoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzTnVsbChmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgcmVjb3JkIGZpZWxkIHZhbHVlLCBpZiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIncyBwcm92aWRlZCBvcHRpb25zXG4gICAgICogQHBhcmFtIGZpZWxkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltUmVjb3JkRmllbGRWYWx1ZShmaWVsZFZhbHVlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnRyaW1GaWVsZFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLm1hcCh0cmltUmVjb3JkRmllbGRWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHF1b3RhdGlvbiBtYXJrcyBpbiB0aGUgZmllbGQgdmFsdWUsIGlmIG5lY2Vzc2FyeSwgYW5kIGFwcHJvcHJpYXRlbHlcbiAgICAgKiB3cmFwcyB0aGUgcmVjb3JkIGZpZWxkIHZhbHVlIGlmIGl0IGNvbnRhaW5zIGEgY29tbWEgKGZpZWxkIGRlbGltaXRlciksXG4gICAgICogcXVvdGF0aW9uIG1hcmsgKHdyYXAgZGVsaW1pdGVyKSwgb3IgYSBsaW5lIGJyZWFrIChDUkxGKVxuICAgICAqIEBwYXJhbSBmaWVsZFZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcEZpZWxkVmFsdWVJZk5lY2Vzc2FyeShmaWVsZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHdyYXBEZWxpbWl0ZXIgPSBvcHRpb25zLmRlbGltaXRlci53cmFwO1xuXG4gICAgICAgIC8vIGVnLiBpbmNsdWRlcyBxdW90YXRpb24gbWFya3MgKGRlZmF1bHQgZGVsaW1pdGVyKVxuICAgICAgICBpZiAoZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25zLmRlbGltaXRlci53cmFwKSkge1xuICAgICAgICAgICAgLy8gYWRkIGFuIGFkZGl0aW9uYWwgcXVvdGF0aW9uIG1hcmsgYmVmb3JlIGVhY2ggcXVvdGF0aW9uIG1hcmsgYXBwZWFyaW5nIGluIHRoZSBmaWVsZCB2YWx1ZVxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGZpZWxkVmFsdWUucmVwbGFjZSh3cmFwRGVsaW1pdGVyQ2hlY2tSZWdleCwgd3JhcERlbGltaXRlciArIHdyYXBEZWxpbWl0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBmaWVsZCBjb250YWlucyBhIGNvbW1hIChmaWVsZCBkZWxpbWl0ZXIpLCBxdW90YXRpb24gbWFyayAod3JhcCBkZWxpbWl0ZXIpLCBsaW5lIGJyZWFrLCBvciBDUkxGXG4gICAgICAgIC8vICAgdGhlbiBlbmNsb3NlIGl0IGluIHF1b3RhdGlvbiBtYXJrcyAod3JhcCBkZWxpbWl0ZXIpXG4gICAgICAgIGlmIChmaWVsZFZhbHVlLmluY2x1ZGVzKG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKSB8fFxuICAgICAgICAgICAgZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25zLmRlbGltaXRlci53cmFwKSB8fFxuICAgICAgICAgICAgZmllbGRWYWx1ZS5tYXRjaChjcmxmU2VhcmNoUmVnZXgpKSB7XG4gICAgICAgICAgICAvLyB3cmFwIHRoZSBmaWVsZCdzIHZhbHVlIGluIGEgd3JhcCBkZWxpbWl0ZXIgKHF1b3RhdGlvbiBtYXJrcyBieSBkZWZhdWx0KVxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHdyYXBEZWxpbWl0ZXIgKyBmaWVsZFZhbHVlICsgd3JhcERlbGltaXRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgQ1NWIHJlY29yZCBzdHJpbmcgYnkgam9pbmluZyB0aGUgZmllbGQgdmFsdWVzIHRvZ2V0aGVyIGJ5IHRoZSBmaWVsZCBkZWxpbWl0ZXJcbiAgICAgKiBAcGFyYW0gcmVjb3JkRmllbGRWYWx1ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNzdlJvd0Zyb21SZWNvcmQocmVjb3JkRmllbGRWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZEZpZWxkVmFsdWVzLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpO1xuICAgIH1cblxuICAgIC8qKiBDU1YgQ09NUE9ORU5UIENPTUJJTkVSL0ZJTkFMIFBST0NFU1NPUiAqKi9cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgZmluYWwgQ1NWIGNvbnN0cnVjdGlvbiBieSBjb21iaW5pbmcgdGhlIGZpZWxkcyBpbiB0aGUgYXBwcm9wcmlhdGVcbiAgICAgKiBvcmRlciBkZXBlbmRpbmcgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMgdmFsdWVzIGFuZCBzZW5kcyB0aGUgZ2VuZXJhdGVkIENTVlxuICAgICAqIGJhY2sgdG8gdGhlIHVzZXJcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDc3ZGcm9tQ29tcG9uZW50cyhwYXJhbXMpIHtcbiAgICAgICAgbGV0IGhlYWRlciA9IHBhcmFtcy5oZWFkZXIsXG4gICAgICAgICAgICByZWNvcmRzID0gcGFyYW1zLnJlY29yZHMsXG5cbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBwcmVwZW5kaW5nIHRoZSBoZWFkZXIsIHRoZW4gYWRkIGFuIEVPTCwgb3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSByZWNvcmRzXG4gICAgICAgICAgICBjc3YgPSAob3B0aW9ucy5leGNlbEJPTSA/IGNvbnN0YW50cy52YWx1ZXMuZXhjZWxCT00gOiAnJykgK1xuICAgICAgICAgICAgICAgIChvcHRpb25zLnByZXBlbmRIZWFkZXIgPyBoZWFkZXIgKyBvcHRpb25zLmRlbGltaXRlci5lb2wgOiAnJykgK1xuICAgICAgICAgICAgICAgIHJlY29yZHM7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jYWxsYmFjayhudWxsLCBjc3YpO1xuICAgIH1cblxuICAgIC8qKiBNQUlOIENPTlZFUlRFUiBGVU5DVElPTiAqKi9cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgZXhwb3J0ZWQganNvbjJjc3YgZnVuY3Rpb25cbiAgICAgKiBUYWtlcyBkYXRhIGFzIGVpdGhlciBhIGRvY3VtZW50IG9yIGFycmF5IG9mIGRvY3VtZW50cyBhbmQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgdXNlZCB0byByZXBvcnQgdGhlIHJlc3VsdHNcbiAgICAgKiBAcGFyYW0gZGF0YSB7T2JqZWN0fEFycmF5PE9iamVjdD59IGRvY3VtZW50cyB0byBiZSBjb252ZXJ0ZWQgdG8gY3N2XG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0KGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFNpbmdsZSBkb2N1bWVudCwgbm90IGFuIGFycmF5XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGRhdGEpICYmICFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTsgLy8gQ29udmVydCB0byBhbiBhcnJheSBvZiB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBoZWFkaW5nIGFuZCB0aGVuIGdlbmVyYXRlIHRoZSBDU1Ygd2l0aCB0aGUga2V5cyB0aGF0IGFyZSBpZGVudGlmaWVkXG4gICAgICAgIHJldHJpZXZlSGVhZGVyRmllbGRzKGRhdGEpXG4gICAgICAgICAgICAudGhlbigoaGVhZGVyRmllbGRzKSA9PiAoe1xuICAgICAgICAgICAgICAgIGhlYWRlckZpZWxkcyxcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICByZWNvcmRzOiBkYXRhXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50aGVuKHByb2Nlc3NSZWNvcmRzKVxuICAgICAgICAgICAgLnRoZW4od3JhcEhlYWRlckZpZWxkcylcbiAgICAgICAgICAgIC50aGVuKHRyaW1IZWFkZXJGaWVsZHMpXG4gICAgICAgICAgICAudGhlbihnZW5lcmF0ZUNzdkhlYWRlcilcbiAgICAgICAgICAgIC50aGVuKGdlbmVyYXRlQ3N2RnJvbUNvbXBvbmVudHMpXG4gICAgICAgICAgICAuY2F0Y2goY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnZlcnQsXG4gICAgICAgIHZhbGlkYXRpb25GbjogXy5pc09iamVjdCxcbiAgICAgICAgdmFsaWRhdGlvbk1lc3NhZ2VzOiBjb25zdGFudHMuZXJyb3JzLmpzb24yY3N2XG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBKc29uMkNzdiB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/json-2-csv/src/json2csv.js\n");

/***/ }),

/***/ "./node_modules/json-2-csv/src/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/json-2-csv/src/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nlet constants = __webpack_require__(/*! ./constants.json */ \"./node_modules/json-2-csv/src/constants.json\"),\n    _ = __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js\");\n\nconst dateStringRegex = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/;\n\nmodule.exports = {\n    isStringRepresentation,\n    isDateRepresentation,\n    computeSchemaDifferences,\n    deepCopy,\n    convert,\n    isEmptyField,\n    removeEmptyFields,\n    getNCharacters\n};\n\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n * @param opts {Object} options object\n * @return {Object} options object\n */\nfunction buildOptions(opts) {\n    opts = _.defaults(opts || {}, constants.defaultOptions);\n\n    // Note: _.defaults does a shallow default, we need to deep copy the DELIMITER object\n    opts.delimiter = _.defaults(opts.delimiter, constants.defaultOptions.delimiter);\n\n    // Otherwise, send the options back\n    return opts;\n}\n\n/**\n * When promisified, the callback and options argument ordering is swapped, so\n * this function is intended to determine which argument is which and return\n * them in the correct order\n * @param arg1 {Object|Function} options or callback\n * @param arg2 {Object|Function} options or callback\n */\nfunction parseArguments(arg1, arg2) {\n    // If this was promisified (callback and opts are swapped) then fix the argument order.\n    if (_.isObject(arg1) && !_.isFunction(arg1)) {\n        return {\n            options: arg1,\n            callback: arg2\n        };\n    }\n    // Regular ordering where the callback is provided before the options object\n    return {\n        options: arg2,\n        callback: arg1\n    };\n}\n\n/**\n * Validates the parameters passed in to json2csv and csv2json\n * @param config {Object} of the form: { data: {Any}, callback: {Function}, dataCheckFn: Function, errorMessages: {Object} }\n */\nfunction validateParameters(config) {\n    // If a callback wasn't provided, throw an error\n    if (!config.callback) {\n        throw new Error(constants.errors.callbackRequired);\n    }\n\n    // If we don't receive data, report an error\n    if (!config.data) {\n        config.callback(new Error(config.errorMessages.cannotCallOn + config.data + '.'));\n        return false;\n    }\n\n    // The data provided data does not meet the type check requirement\n    if (!config.dataCheckFn(config.data)) {\n        config.callback(new Error(config.errorMessages.dataCheckFailure));\n        return false;\n    }\n\n    // If we didn't hit any known error conditions, then the data is so far determined to be valid\n    // Note: json2csv/csv2json may perform additional validity checks on the data\n    return true;\n}\n\n/**\n * Abstracted function to perform the conversion of json-->csv or csv-->json\n * depending on the converter class that is passed via the params object\n * @param params {Object}\n */\nfunction convert(params) {\n    let {options, callback} = parseArguments(params.callback, params.options);\n    options = buildOptions(options);\n\n    let converter = new params.converter(options),\n\n        // Validate the parameters before calling the converter's convert function\n        valid = validateParameters({\n            data: params.data,\n            callback,\n            errorMessages: converter.validationMessages,\n            dataCheckFn: converter.validationFn\n        });\n\n    if (valid) converter.convert(params.data, callback);\n}\n\n/**\n * Utility function to deep copy an object, used by the module tests\n * @param obj\n * @returns {any}\n */\nfunction deepCopy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a string. Given the RFC4180 requirements, that means that the value is\n *   wrapped in value wrap delimiters (usually a quotation mark on each side).\n * @param fieldValue\n * @param options\n * @returns {boolean}\n */\nfunction isStringRepresentation(fieldValue, options) {\n    const firstChar = fieldValue[0],\n        lastIndex = fieldValue.length - 1,\n        lastChar = fieldValue[lastIndex];\n\n    // If the field starts and ends with a wrap delimiter\n    return firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap;\n}\n\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a date.\n * @param fieldValue\n * @returns {boolean}\n */\nfunction isDateRepresentation(fieldValue) {\n    return dateStringRegex.test(fieldValue);\n}\n\n/**\n * Helper function that determines the schema differences between two objects.\n * @param schemaA\n * @param schemaB\n * @returns {*}\n */\nfunction computeSchemaDifferences(schemaA, schemaB) {\n    return _.difference(schemaA, schemaB)\n        .concat(_.difference(schemaB, schemaA));\n}\n\n/**\n * Utility function to check if a field is considered empty so that the emptyFieldValue can be used instead\n * @param fieldValue\n * @returns {boolean}\n */\nfunction isEmptyField(fieldValue) {\n    return _.isUndefined(fieldValue) || _.isNull(fieldValue) || fieldValue === '';\n}\n\n/**\n * Helper function that removes empty field values from an array.\n * @param fields\n * @returns {Array}\n */\nfunction removeEmptyFields(fields) {\n    return _.filter(fields, (field) => !isEmptyField(field));\n}\n\n/**\n * Helper function that retrieves the next n characters from the start index in\n *   the string including the character at the start index. This is used to\n *   check if are currently at an EOL value, since it could be multiple\n *   characters in length (eg. '\\r\\n')\n * @param str\n * @param start\n * @param n\n * @returns {string}\n */\nfunction getNCharacters(str, start, n) {\n    return str.substring(start, start + n);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9zcmMvdXRpbHMuanM/N2MxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmxldCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy5qc29uJyksXG4gICAgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuY29uc3QgZGF0ZVN0cmluZ1JlZ2V4ID0gL1xcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9LlxcZHszfVovO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpc1N0cmluZ1JlcHJlc2VudGF0aW9uLFxuICAgIGlzRGF0ZVJlcHJlc2VudGF0aW9uLFxuICAgIGNvbXB1dGVTY2hlbWFEaWZmZXJlbmNlcyxcbiAgICBkZWVwQ29weSxcbiAgICBjb252ZXJ0LFxuICAgIGlzRW1wdHlGaWVsZCxcbiAgICByZW1vdmVFbXB0eUZpZWxkcyxcbiAgICBnZXROQ2hhcmFjdGVyc1xufTtcblxuLyoqXG4gKiBCdWlsZCB0aGUgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGZ1bmN0aW9uXG4gKiBJZiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBjdXN0b20gb3B0aW9ucywgdGhlbiB3ZSB1c2Ugb3VyIGRlZmF1bHRcbiAqIElmIG9wdGlvbnMgYXJlIHByb3ZpZGVkLCB0aGVuIHdlIHNldCBlYWNoIHZhbGlkIGtleSB0aGF0IHdhcyBwYXNzZWRcbiAqIEBwYXJhbSBvcHRzIHtPYmplY3R9IG9wdGlvbnMgb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9IG9wdGlvbnMgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkT3B0aW9ucyhvcHRzKSB7XG4gICAgb3B0cyA9IF8uZGVmYXVsdHMob3B0cyB8fCB7fSwgY29uc3RhbnRzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIC8vIE5vdGU6IF8uZGVmYXVsdHMgZG9lcyBhIHNoYWxsb3cgZGVmYXVsdCwgd2UgbmVlZCB0byBkZWVwIGNvcHkgdGhlIERFTElNSVRFUiBvYmplY3RcbiAgICBvcHRzLmRlbGltaXRlciA9IF8uZGVmYXVsdHMob3B0cy5kZWxpbWl0ZXIsIGNvbnN0YW50cy5kZWZhdWx0T3B0aW9ucy5kZWxpbWl0ZXIpO1xuXG4gICAgLy8gT3RoZXJ3aXNlLCBzZW5kIHRoZSBvcHRpb25zIGJhY2tcbiAgICByZXR1cm4gb3B0cztcbn1cblxuLyoqXG4gKiBXaGVuIHByb21pc2lmaWVkLCB0aGUgY2FsbGJhY2sgYW5kIG9wdGlvbnMgYXJndW1lbnQgb3JkZXJpbmcgaXMgc3dhcHBlZCwgc29cbiAqIHRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGFyZ3VtZW50IGlzIHdoaWNoIGFuZCByZXR1cm5cbiAqIHRoZW0gaW4gdGhlIGNvcnJlY3Qgb3JkZXJcbiAqIEBwYXJhbSBhcmcxIHtPYmplY3R8RnVuY3Rpb259IG9wdGlvbnMgb3IgY2FsbGJhY2tcbiAqIEBwYXJhbSBhcmcyIHtPYmplY3R8RnVuY3Rpb259IG9wdGlvbnMgb3IgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoYXJnMSwgYXJnMikge1xuICAgIC8vIElmIHRoaXMgd2FzIHByb21pc2lmaWVkIChjYWxsYmFjayBhbmQgb3B0cyBhcmUgc3dhcHBlZCkgdGhlbiBmaXggdGhlIGFyZ3VtZW50IG9yZGVyLlxuICAgIGlmIChfLmlzT2JqZWN0KGFyZzEpICYmICFfLmlzRnVuY3Rpb24oYXJnMSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IGFyZzEsXG4gICAgICAgICAgICBjYWxsYmFjazogYXJnMlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBSZWd1bGFyIG9yZGVyaW5nIHdoZXJlIHRoZSBjYWxsYmFjayBpcyBwcm92aWRlZCBiZWZvcmUgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW9uczogYXJnMixcbiAgICAgICAgY2FsbGJhY2s6IGFyZzFcbiAgICB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgcGFyYW1ldGVycyBwYXNzZWQgaW4gdG8ganNvbjJjc3YgYW5kIGNzdjJqc29uXG4gKiBAcGFyYW0gY29uZmlnIHtPYmplY3R9IG9mIHRoZSBmb3JtOiB7IGRhdGE6IHtBbnl9LCBjYWxsYmFjazoge0Z1bmN0aW9ufSwgZGF0YUNoZWNrRm46IEZ1bmN0aW9uLCBlcnJvck1lc3NhZ2VzOiB7T2JqZWN0fSB9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1ldGVycyhjb25maWcpIHtcbiAgICAvLyBJZiBhIGNhbGxiYWNrIHdhc24ndCBwcm92aWRlZCwgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiAoIWNvbmZpZy5jYWxsYmFjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29uc3RhbnRzLmVycm9ycy5jYWxsYmFja1JlcXVpcmVkKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBkb24ndCByZWNlaXZlIGRhdGEsIHJlcG9ydCBhbiBlcnJvclxuICAgIGlmICghY29uZmlnLmRhdGEpIHtcbiAgICAgICAgY29uZmlnLmNhbGxiYWNrKG5ldyBFcnJvcihjb25maWcuZXJyb3JNZXNzYWdlcy5jYW5ub3RDYWxsT24gKyBjb25maWcuZGF0YSArICcuJykpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhlIGRhdGEgcHJvdmlkZWQgZGF0YSBkb2VzIG5vdCBtZWV0IHRoZSB0eXBlIGNoZWNrIHJlcXVpcmVtZW50XG4gICAgaWYgKCFjb25maWcuZGF0YUNoZWNrRm4oY29uZmlnLmRhdGEpKSB7XG4gICAgICAgIGNvbmZpZy5jYWxsYmFjayhuZXcgRXJyb3IoY29uZmlnLmVycm9yTWVzc2FnZXMuZGF0YUNoZWNrRmFpbHVyZSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZGlkbid0IGhpdCBhbnkga25vd24gZXJyb3IgY29uZGl0aW9ucywgdGhlbiB0aGUgZGF0YSBpcyBzbyBmYXIgZGV0ZXJtaW5lZCB0byBiZSB2YWxpZFxuICAgIC8vIE5vdGU6IGpzb24yY3N2L2NzdjJqc29uIG1heSBwZXJmb3JtIGFkZGl0aW9uYWwgdmFsaWRpdHkgY2hlY2tzIG9uIHRoZSBkYXRhXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQWJzdHJhY3RlZCBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBjb252ZXJzaW9uIG9mIGpzb24tLT5jc3Ygb3IgY3N2LS0+anNvblxuICogZGVwZW5kaW5nIG9uIHRoZSBjb252ZXJ0ZXIgY2xhc3MgdGhhdCBpcyBwYXNzZWQgdmlhIHRoZSBwYXJhbXMgb2JqZWN0XG4gKiBAcGFyYW0gcGFyYW1zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnQocGFyYW1zKSB7XG4gICAgbGV0IHtvcHRpb25zLCBjYWxsYmFja30gPSBwYXJzZUFyZ3VtZW50cyhwYXJhbXMuY2FsbGJhY2ssIHBhcmFtcy5vcHRpb25zKTtcbiAgICBvcHRpb25zID0gYnVpbGRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgbGV0IGNvbnZlcnRlciA9IG5ldyBwYXJhbXMuY29udmVydGVyKG9wdGlvbnMpLFxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBwYXJhbWV0ZXJzIGJlZm9yZSBjYWxsaW5nIHRoZSBjb252ZXJ0ZXIncyBjb252ZXJ0IGZ1bmN0aW9uXG4gICAgICAgIHZhbGlkID0gdmFsaWRhdGVQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIGRhdGE6IHBhcmFtcy5kYXRhLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzOiBjb252ZXJ0ZXIudmFsaWRhdGlvbk1lc3NhZ2VzLFxuICAgICAgICAgICAgZGF0YUNoZWNrRm46IGNvbnZlcnRlci52YWxpZGF0aW9uRm5cbiAgICAgICAgfSk7XG5cbiAgICBpZiAodmFsaWQpIGNvbnZlcnRlci5jb252ZXJ0KHBhcmFtcy5kYXRhLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBkZWVwIGNvcHkgYW4gb2JqZWN0LCB1c2VkIGJ5IHRoZSBtb2R1bGUgdGVzdHNcbiAqIEBwYXJhbSBvYmpcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGRlZXBDb3B5KG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSByZXByZXNlbnRhdGlvblxuICogICBvZiBhIHN0cmluZy4gR2l2ZW4gdGhlIFJGQzQxODAgcmVxdWlyZW1lbnRzLCB0aGF0IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGlzXG4gKiAgIHdyYXBwZWQgaW4gdmFsdWUgd3JhcCBkZWxpbWl0ZXJzICh1c3VhbGx5IGEgcXVvdGF0aW9uIG1hcmsgb24gZWFjaCBzaWRlKS5cbiAqIEBwYXJhbSBmaWVsZFZhbHVlXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nUmVwcmVzZW50YXRpb24oZmllbGRWYWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZpcnN0Q2hhciA9IGZpZWxkVmFsdWVbMF0sXG4gICAgICAgIGxhc3RJbmRleCA9IGZpZWxkVmFsdWUubGVuZ3RoIC0gMSxcbiAgICAgICAgbGFzdENoYXIgPSBmaWVsZFZhbHVlW2xhc3RJbmRleF07XG5cbiAgICAvLyBJZiB0aGUgZmllbGQgc3RhcnRzIGFuZCBlbmRzIHdpdGggYSB3cmFwIGRlbGltaXRlclxuICAgIHJldHVybiBmaXJzdENoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgbGFzdENoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXA7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIHJlcHJlc2VudGF0aW9uXG4gKiAgIG9mIGEgZGF0ZS5cbiAqIEBwYXJhbSBmaWVsZFZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEYXRlUmVwcmVzZW50YXRpb24oZmllbGRWYWx1ZSkge1xuICAgIHJldHVybiBkYXRlU3RyaW5nUmVnZXgudGVzdChmaWVsZFZhbHVlKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHRoZSBzY2hlbWEgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gb2JqZWN0cy5cbiAqIEBwYXJhbSBzY2hlbWFBXG4gKiBAcGFyYW0gc2NoZW1hQlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTY2hlbWFEaWZmZXJlbmNlcyhzY2hlbWFBLCBzY2hlbWFCKSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShzY2hlbWFBLCBzY2hlbWFCKVxuICAgICAgICAuY29uY2F0KF8uZGlmZmVyZW5jZShzY2hlbWFCLCBzY2hlbWFBKSk7XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBjaGVjayBpZiBhIGZpZWxkIGlzIGNvbnNpZGVyZWQgZW1wdHkgc28gdGhhdCB0aGUgZW1wdHlGaWVsZFZhbHVlIGNhbiBiZSB1c2VkIGluc3RlYWRcbiAqIEBwYXJhbSBmaWVsZFZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbXB0eUZpZWxkKGZpZWxkVmFsdWUpIHtcbiAgICByZXR1cm4gXy5pc1VuZGVmaW5lZChmaWVsZFZhbHVlKSB8fCBfLmlzTnVsbChmaWVsZFZhbHVlKSB8fCBmaWVsZFZhbHVlID09PSAnJztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZW1vdmVzIGVtcHR5IGZpZWxkIHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICogQHBhcmFtIGZpZWxkc1xuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiByZW1vdmVFbXB0eUZpZWxkcyhmaWVsZHMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoZmllbGRzLCAoZmllbGQpID0+ICFpc0VtcHR5RmllbGQoZmllbGQpKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXRyaWV2ZXMgdGhlIG5leHQgbiBjaGFyYWN0ZXJzIGZyb20gdGhlIHN0YXJ0IGluZGV4IGluXG4gKiAgIHRoZSBzdHJpbmcgaW5jbHVkaW5nIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIHN0YXJ0IGluZGV4LiBUaGlzIGlzIHVzZWQgdG9cbiAqICAgY2hlY2sgaWYgYXJlIGN1cnJlbnRseSBhdCBhbiBFT0wgdmFsdWUsIHNpbmNlIGl0IGNvdWxkIGJlIG11bHRpcGxlXG4gKiAgIGNoYXJhY3RlcnMgaW4gbGVuZ3RoIChlZy4gJ1xcclxcbicpXG4gKiBAcGFyYW0gc3RyXG4gKiBAcGFyYW0gc3RhcnRcbiAqIEBwYXJhbSBuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXROQ2hhcmFjdGVycyhzdHIsIHN0YXJ0LCBuKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQsIHN0YXJ0ICsgbik7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/json-2-csv/src/utils.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : undefined\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz85NmNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIGJ0b2EpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/underscore/underscore.js":
/*!***********************************************!*\
  !*** ./node_modules/underscore/underscore.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.9.1\n//     http://underscorejs.org\n//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n            typeof global == 'object' && global.global === global && global ||\n            this ||\n            {};\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for their old module API. If we're in\n  // the browser, add `_` as a global object.\n  // (`nodeType` is checked to ensure that `module`\n  // and `exports` are not HTML elements.)\n  if ( true && !exports.nodeType) {\n    if ( true && !module.nodeType && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.9.1';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-argument case is omitted because were not using it.\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  var builtinIteratee;\n\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result  either `identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);\n    return _.property(value);\n  };\n\n  // External wrapper for our callback generator. Users may customize\n  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.\n  // This abstraction hides the internal-only argCount argument.\n  _.iteratee = builtinIteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // Some functions take a variable number of arguments, or a few expected\n  // arguments at the beginning and then a variable number of values to operate\n  // on. This helper accumulates all remaining arguments past the functions\n  // argument length (or an explicit `startIndex`), into an array that becomes\n  // the last argument. Similar to ES6s \"rest parameter\".\n  var restArguments = function(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var shallowProperty = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  var has = function(obj, path) {\n    return obj != null && hasOwnProperty.call(obj, path);\n  }\n\n  var deepGet = function(obj, path) {\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      if (obj == null) return void 0;\n      obj = obj[path[i]];\n    }\n    return length ? obj : void 0;\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object.\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = shallowProperty('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  var createReduce = function(dir) {\n    // Wrap code that reassigns argument variables in a separate function than\n    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)\n    var reducer = function(obj, iteratee, memo, initial) {\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      if (!initial) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    };\n\n    return function(obj, iteratee, memo, context) {\n      var initial = arguments.length >= 3;\n      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n    };\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;\n    var key = keyFinder(obj, predicate, context);\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = restArguments(function(obj, path, args) {\n    var contextPath, func;\n    if (_.isFunction(path)) {\n      func = path;\n    } else if (_.isArray(path)) {\n      contextPath = path.slice(0, -1);\n      path = path[path.length - 1];\n    }\n    return _.map(obj, function(context) {\n      var method = func;\n      if (!method) {\n        if (contextPath && contextPath.length) {\n          context = deepGet(context, contextPath);\n        }\n        if (context == null) return void 0;\n        method = context[path];\n      }\n      return method == null ? method : method.apply(context, args);\n    });\n  });\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection.\n  _.shuffle = function(obj) {\n    return _.sample(obj, Infinity);\n  };\n\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = _.random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    var index = 0;\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, key, list) {\n      return {\n        value: value,\n        index: index++,\n        criteria: iteratee(value, key, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior, partition) {\n    return function(obj, iteratee, context) {\n      var result = partition ? [[], []] : {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (_.isString(obj)) {\n      // Keep surrogate pair characters together\n      return obj.match(reStrSymbol);\n    }\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = group(function(result, value, pass) {\n    result[pass ? 0 : 1].push(value);\n  }, true);\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null || array.length < 1) return n == null ? void 0 : [];\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null || array.length < 1) return n == null ? void 0 : [];\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, Boolean);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, output) {\n    output = output || [];\n    var idx = output.length;\n    for (var i = 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        // Flatten current level of array or arguments object.\n        if (shallow) {\n          var j = 0, len = value.length;\n          while (j < len) output[idx++] = value[j++];\n        } else {\n          flatten(value, shallow, strict, output);\n          idx = output.length;\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = restArguments(function(array, otherArrays) {\n    return _.difference(array, otherArrays);\n  });\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // The faster algorithm will not work with an iteratee if the iteratee\n  // is not a one-to-one function, so providing an iteratee will disable\n  // the faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted && !iteratee) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = restArguments(function(arrays) {\n    return _.uniq(flatten(arrays, true, true));\n  });\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      var j;\n      for (j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = restArguments(function(array, rest) {\n    rest = flatten(rest, true, true);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  });\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices.\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = restArguments(_.unzip);\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values. Passing by pairs is the reverse of _.pairs.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions.\n  var createPredicateIndexFinder = function(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  };\n\n  // Returns the first index on an array-like that passes a predicate test.\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions.\n  var createIndexFinder = function(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n          i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    if (!step) {\n      step = stop < start ? -1 : 1;\n    }\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Chunk a single array into multiple arrays, each containing `count` or fewer\n  // items.\n  _.chunk = function(array, count) {\n    if (count == null || count < 1) return [];\n    var result = [];\n    var i = 0, length = array.length;\n    while (i < length) {\n      result.push(slice.call(array, i, i += count));\n    }\n    return result;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments.\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = restArguments(function(func, context, args) {\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var bound = restArguments(function(callArgs) {\n      return executeBound(func, bound, context, this, args.concat(callArgs));\n    });\n    return bound;\n  });\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder by default, allowing any combination of arguments to be\n  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.\n  _.partial = restArguments(function(func, boundArgs) {\n    var placeholder = _.partial.placeholder;\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  });\n\n  _.partial.placeholder = _;\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = restArguments(function(obj, keys) {\n    keys = flatten(keys, false, false);\n    var index = keys.length;\n    if (index < 1) throw new Error('bindAll must be passed function names');\n    while (index--) {\n      var key = keys[index];\n      obj[key] = _.bind(obj[key], obj);\n    }\n  });\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = restArguments(function(func, wait, args) {\n    return setTimeout(function() {\n      return func.apply(null, args);\n    }, wait);\n  });\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n\n    var later = function(context, args) {\n      timeout = null;\n      if (args) result = func.apply(context, args);\n    };\n\n    var debounced = restArguments(function(args) {\n      if (timeout) clearTimeout(timeout);\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n        if (callNow) result = func.apply(this, args);\n      } else {\n        timeout = _.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  _.restArguments = restArguments;\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  var collectNonEnumProps = function(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  };\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`.\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object.\n  // In contrast to _.map it returns an object.\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = _.keys(obj),\n        length = keys.length,\n        results = {};\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys[index];\n      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  // The opposite of _.object.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`.\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, defaults) {\n    return function(obj) {\n      var length = arguments.length;\n      if (defaults) obj = Object(obj);\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!defaults || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s).\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test.\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Internal pick helper function to determine if `obj` has key `key`.\n  var keyInObj = function(value, key, obj) {\n    return key in obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = restArguments(function(obj, keys) {\n    var result = {}, iteratee = keys[0];\n    if (obj == null) return result;\n    if (_.isFunction(iteratee)) {\n      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n      keys = _.allKeys(obj);\n    } else {\n      iteratee = keyInObj;\n      keys = flatten(keys, false, false);\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  });\n\n  // Return a copy of the object without the blacklisted properties.\n  _.omit = restArguments(function(obj, keys) {\n    var iteratee = keys[0], context;\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n      if (keys.length > 1) context = keys[1];\n    } else {\n      keys = _.map(flatten(keys, false, false), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  });\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq, deepEq;\n  eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) return false;\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) return b !== b;\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\n    return deepEq(a, b, aStack, bStack);\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  deepEq = function(a, b, aStack, bStack) {\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN.\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n      case '[object Symbol]':\n        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).\n  var nodelist = root.document && root.document.childNodes;\n  if ( true && typeof Int8Array != 'object' && typeof nodelist != 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && isNaN(obj);\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, path) {\n    if (!_.isArray(path)) {\n      return has(obj, path);\n    }\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      var key = path[i];\n      if (obj == null || !hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n      obj = obj[key];\n    }\n    return !!length;\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  // Creates a function that, when passed an object, will traverse that objects\n  // properties down the given `path`, specified as an array of keys or indexes.\n  _.property = function(path) {\n    if (!_.isArray(path)) {\n      return shallowProperty(path);\n    }\n    return function(obj) {\n      return deepGet(obj, path);\n    };\n  };\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    if (obj == null) {\n      return function(){};\n    }\n    return function(path) {\n      return !_.isArray(path) ? obj[path] : deepGet(obj, path);\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n  // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // Traverses the children of `obj` along `path`. If a child is a function, it\n  // is invoked with its parent as context. Returns the value of the final\n  // child, or `fallback` if any child is undefined.\n  _.result = function(obj, path, fallback) {\n    if (!_.isArray(path)) path = [path];\n    var length = path.length;\n    if (!length) {\n      return _.isFunction(fallback) ? fallback.call(obj) : fallback;\n    }\n    for (var i = 0; i < length; i++) {\n      var prop = obj == null ? void 0 : obj[path[i]];\n      if (prop === void 0) {\n        prop = fallback;\n        i = length; // Ensure we don't continue iterating.\n      }\n      obj = _.isFunction(prop) ? prop.call(obj) : prop;\n    }\n    return obj;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offset.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    var render;\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var chainResult = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return chainResult(this, func.apply(_, args));\n      };\n    });\n    return _;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return chainResult(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return chainResult(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return String(this._wrapped);\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}());\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcz8xN2ZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOS4xXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE4IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgKGBzZWxmYCkgaW4gdGhlIGJyb3dzZXIsIGBnbG9iYWxgXG4gIC8vIG9uIHRoZSBzZXJ2ZXIsIG9yIGB0aGlzYCBpbiBzb21lIHZpcnR1YWwgbWFjaGluZXMuIFdlIHVzZSBgc2VsZmBcbiAgLy8gaW5zdGVhZCBvZiBgd2luZG93YCBmb3IgYFdlYldvcmtlcmAgc3VwcG9ydC5cbiAgdmFyIHJvb3QgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZiB8fFxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsIHx8XG4gICAgICAgICAgICB0aGlzIHx8XG4gICAgICAgICAgICB7fTtcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBTeW1ib2xQcm90byA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sLnByb3RvdHlwZSA6IG51bGw7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhciBwdXNoID0gQXJyYXlQcm90by5wdXNoLFxuICAgICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgICAgdG9TdHJpbmcgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXIgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgICBuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMsXG4gICAgICBuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGVpciBvbGQgbW9kdWxlIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICAvLyAoYG5vZGVUeXBlYCBpcyBjaGVja2VkIHRvIGVuc3VyZSB0aGF0IGBtb2R1bGVgXG4gIC8vIGFuZCBgZXhwb3J0c2AgYXJlIG5vdCBIVE1MIGVsZW1lbnRzLilcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmICFleHBvcnRzLm5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS45LjEnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICAvLyBUaGUgMi1hcmd1bWVudCBjYXNlIGlzIG9taXR0ZWQgYmVjYXVzZSB3ZeKAmXJlIG5vdCB1c2luZyBpdC5cbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBidWlsdGluSXRlcmF0ZWU7XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gZWFjaFxuICAvLyBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyIGBpZGVudGl0eWAsXG4gIC8vIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoXy5pdGVyYXRlZSAhPT0gYnVpbHRpbkl0ZXJhdGVlKSByZXR1cm4gXy5pdGVyYXRlZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSAmJiAhXy5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuXG4gIC8vIEV4dGVybmFsIHdyYXBwZXIgZm9yIG91ciBjYWxsYmFjayBnZW5lcmF0b3IuIFVzZXJzIG1heSBjdXN0b21pemVcbiAgLy8gYF8uaXRlcmF0ZWVgIGlmIHRoZXkgd2FudCBhZGRpdGlvbmFsIHByZWRpY2F0ZS9pdGVyYXRlZSBzaG9ydGhhbmQgc3R5bGVzLlxuICAvLyBUaGlzIGFic3RyYWN0aW9uIGhpZGVzIHRoZSBpbnRlcm5hbC1vbmx5IGFyZ0NvdW50IGFyZ3VtZW50LlxuICBfLml0ZXJhdGVlID0gYnVpbHRpbkl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBTb21lIGZ1bmN0aW9ucyB0YWtlIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgb3IgYSBmZXcgZXhwZWN0ZWRcbiAgLy8gYXJndW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgYW5kIHRoZW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgdmFsdWVzIHRvIG9wZXJhdGVcbiAgLy8gb24uIFRoaXMgaGVscGVyIGFjY3VtdWxhdGVzIGFsbCByZW1haW5pbmcgYXJndW1lbnRzIHBhc3QgdGhlIGZ1bmN0aW9u4oCZc1xuICAvLyBhcmd1bWVudCBsZW5ndGggKG9yIGFuIGV4cGxpY2l0IGBzdGFydEluZGV4YCksIGludG8gYW4gYXJyYXkgdGhhdCBiZWNvbWVzXG4gIC8vIHRoZSBsYXN0IGFyZ3VtZW50LiBTaW1pbGFyIHRvIEVTNuKAmXMgXCJyZXN0IHBhcmFtZXRlclwiLlxuICB2YXIgcmVzdEFyZ3VtZW50cyA9IGZ1bmN0aW9uKGZ1bmMsIHN0YXJ0SW5kZXgpIHtcbiAgICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCA9PSBudWxsID8gZnVuYy5sZW5ndGggLSAxIDogK3N0YXJ0SW5kZXg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KGFyZ3VtZW50cy5sZW5ndGggLSBzdGFydEluZGV4LCAwKSxcbiAgICAgICAgICByZXN0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXggKyBzdGFydEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoc3RhcnRJbmRleCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0sIHJlc3QpO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIHJlc3QpO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShzdGFydEluZGV4ICsgMSk7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBzdGFydEluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGFyZ3Nbc3RhcnRJbmRleF0gPSByZXN0O1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgc2hhbGxvd1Byb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGFzID0gZnVuY3Rpb24ob2JqLCBwYXRoKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwYXRoKTtcbiAgfVxuXG4gIHZhciBkZWVwR2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aCA/IG9iaiA6IHZvaWQgMDtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdC5cbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgLy8gQXZvaWRzIGEgdmVyeSBuYXN0eSBpT1MgOCBKSVQgYnVnIG9uIEFSTS02NC4gIzIwOTRcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBnZXRMZW5ndGggPSBzaGFsbG93UHJvcGVydHkoJ2xlbmd0aCcpO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgdmFyIGNyZWF0ZVJlZHVjZSA9IGZ1bmN0aW9uKGRpcikge1xuICAgIC8vIFdyYXAgY29kZSB0aGF0IHJlYXNzaWducyBhcmd1bWVudCB2YXJpYWJsZXMgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbiB0aGFuXG4gICAgLy8gdGhlIG9uZSB0aGF0IGFjY2Vzc2VzIGBhcmd1bWVudHMubGVuZ3RoYCB0byBhdm9pZCBhIHBlcmYgaGl0LiAoIzE5OTEpXG4gICAgdmFyIHJlZHVjZXIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBpbml0aWFsKSB7XG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+PSAzO1xuICAgICAgcmV0dXJuIHJlZHVjZXIob2JqLCBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KSwgbWVtbywgaW5pdGlhbCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleUZpbmRlciA9IGlzQXJyYXlMaWtlKG9iaikgPyBfLmZpbmRJbmRleCA6IF8uZmluZEtleTtcbiAgICB2YXIga2V5ID0ga2V5RmluZGVyKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwgcGF0aCwgYXJncykge1xuICAgIHZhciBjb250ZXh0UGF0aCwgZnVuYztcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHBhdGgpKSB7XG4gICAgICBmdW5jID0gcGF0aDtcbiAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShwYXRoKSkge1xuICAgICAgY29udGV4dFBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgIHBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBtZXRob2QgPSBmdW5jO1xuICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgaWYgKGNvbnRleHRQYXRoICYmIGNvbnRleHRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRleHQgPSBkZWVwR2V0KGNvbnRleHQsIGNvbnRleHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICBtZXRob2QgPSBjb250ZXh0W3BhdGhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGhvZCA9PSBudWxsID8gbWV0aG9kIDogbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsIHx8IHR5cGVvZiBpdGVyYXRlZSA9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqWzBdICE9ICdvYmplY3QnICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2LCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHYsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCB8fCB0eXBlb2YgaXRlcmF0ZWUgPT0gJ251bWJlcicgJiYgdHlwZW9mIG9ialswXSAhPSAnb2JqZWN0JyAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odiwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2LCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHY7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5zYW1wbGUob2JqLCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24gdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgdmFyIHNhbXBsZSA9IGlzQXJyYXlMaWtlKG9iaikgPyBfLmNsb25lKG9iaikgOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoc2FtcGxlKTtcbiAgICBuID0gTWF0aC5tYXgoTWF0aC5taW4obiwgbGVuZ3RoKSwgMCk7XG4gICAgdmFyIGxhc3QgPSBsZW5ndGggLSAxO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBuOyBpbmRleCsrKSB7XG4gICAgICB2YXIgcmFuZCA9IF8ucmFuZG9tKGluZGV4LCBsYXN0KTtcbiAgICAgIHZhciB0ZW1wID0gc2FtcGxlW2luZGV4XTtcbiAgICAgIHNhbXBsZVtpbmRleF0gPSBzYW1wbGVbcmFuZF07XG4gICAgICBzYW1wbGVbcmFuZF0gPSB0ZW1wO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxlLnNsaWNlKDAsIG4pO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4KyssXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwga2V5LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IsIHBhcnRpdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcGFydGl0aW9uID8gW1tdLCBbXV0gOiB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChoYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgdmFyIHJlU3RyU3ltYm9sID0gL1teXFx1ZDgwMC1cXHVkZmZmXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdfFtcXHVkODAwLVxcdWRmZmZdL2c7XG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChfLmlzU3RyaW5nKG9iaikpIHtcbiAgICAgIC8vIEtlZXAgc3Vycm9nYXRlIHBhaXIgY2hhcmFjdGVycyB0b2dldGhlclxuICAgICAgcmV0dXJuIG9iai5tYXRjaChyZVN0clN5bWJvbCk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIHBhc3MpIHtcbiAgICByZXN1bHRbcGFzcyA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgfSwgdHJ1ZSk7XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsIHx8IGFycmF5Lmxlbmd0aCA8IDEpIHJldHVybiBuID09IG51bGwgPyB2b2lkIDAgOiBbXTtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgcmV0dXJuIF8uaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCB8fCBhcnJheS5sZW5ndGggPCAxKSByZXR1cm4gbiA9PSBudWxsID8gdm9pZCAwIDogW107XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBCb29sZWFuKTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0ID0gb3V0cHV0IHx8IFtdO1xuICAgIHZhciBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy8gRmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3QuXG4gICAgICAgIGlmIChzaGFsbG93KSB7XG4gICAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGogPCBsZW4pIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KTtcbiAgICAgICAgICBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5LCBvdGhlckFycmF5cykge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIG90aGVyQXJyYXlzKTtcbiAgfSk7XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBUaGUgZmFzdGVyIGFsZ29yaXRobSB3aWxsIG5vdCB3b3JrIHdpdGggYW4gaXRlcmF0ZWUgaWYgdGhlIGl0ZXJhdGVlXG4gIC8vIGlzIG5vdCBhIG9uZS10by1vbmUgZnVuY3Rpb24sIHNvIHByb3ZpZGluZyBhbiBpdGVyYXRlZSB3aWxsIGRpc2FibGVcbiAgLy8gdGhlIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQgJiYgIWl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheXMpIHtcbiAgICByZXR1cm4gXy51bmlxKGZsYXR0ZW4oYXJyYXlzLCB0cnVlLCB0cnVlKSk7XG4gIH0pO1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGo7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJyYXksIHJlc3QpIHtcbiAgICByZXN0ID0gZmxhdHRlbihyZXN0LCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzLlxuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gcmVzdEFyZ3VtZW50cyhfLnVuemlwKTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuIFBhc3NpbmcgYnkgcGFpcnMgaXMgdGhlIHJldmVyc2Ugb2YgXy5wYWlycy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyID0gZnVuY3Rpb24oZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdC5cbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUluZGV4RmluZGVyID0gZnVuY3Rpb24oZGlyLCBwcmVkaWNhdGVGaW5kLCBzb3J0ZWRJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgaXRlbSwgaWR4KSB7XG4gICAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigxLCBfLmZpbmRJbmRleCwgXy5zb3J0ZWRJbmRleCk7XG4gIF8ubGFzdEluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigtMSwgXy5maW5kTGFzdEluZGV4KTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChzdG9wID09IG51bGwpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAoIXN0ZXApIHtcbiAgICAgIHN0ZXAgPSBzdG9wIDwgc3RhcnQgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBDaHVuayBhIHNpbmdsZSBhcnJheSBpbnRvIG11bHRpcGxlIGFycmF5cywgZWFjaCBjb250YWluaW5nIGBjb3VudGAgb3IgZmV3ZXJcbiAgLy8gaXRlbXMuXG4gIF8uY2h1bmsgPSBmdW5jdGlvbihhcnJheSwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCB8fCBjb3VudCA8IDEpIHJldHVybiBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNsaWNlLmNhbGwoYXJyYXksIGksIGkgKz0gY291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvclxuICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGJvdW5kID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihjYWxsQXJncykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoY2FsbEFyZ3MpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH0pO1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyIGJ5IGRlZmF1bHQsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmVcbiAgLy8gcHJlLWZpbGxlZC4gU2V0IGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIGZvciBhIGN1c3RvbSBwbGFjZWhvbGRlciBhcmd1bWVudC5cbiAgXy5wYXJ0aWFsID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCBib3VuZEFyZ3MpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBfLnBhcnRpYWwucGxhY2Vob2xkZXI7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBib3VuZEFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYm91bmRBcmdzW2ldID09PSBwbGFjZWhvbGRlciA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH0pO1xuXG4gIF8ucGFydGlhbC5wbGFjZWhvbGRlciA9IF87XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAga2V5cyA9IGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKTtcbiAgICB2YXIgaW5kZXggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPCAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICB9KTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFoYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH0pO1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGltZW91dCwgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciB0aHJvdHRsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB0aHJvdHRsZWQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBwcmV2aW91cyA9IDA7XG4gICAgICB0aW1lb3V0ID0gY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhyb3R0bGVkO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmIChhcmdzKSByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICB2YXIgZGVib3VuY2VkID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcmdzKSB7XG4gICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICB2YXIgY2FsbE5vdyA9ICF0aW1lb3V0O1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IF8uZGVsYXkobGF0ZXIsIHdhaXQsIHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgZGVib3VuY2VkLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICBfLnJlc3RBcmd1bWVudHMgPSByZXN0QXJndW1lbnRzO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgdmFyIGNvbGxlY3ROb25FbnVtUHJvcHMgPSBmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChoYXMob2JqLCBwcm9wKSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkga2V5cy5wdXNoKHByb3ApO1xuXG4gICAgd2hpbGUgKG5vbkVudW1JZHgtLSkge1xuICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tub25FbnVtSWR4XTtcbiAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XG4gICAgICAgIGtleXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgLlxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKGhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICBfLmFsbEtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdC5cbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3QuXG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0ge307XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICAvLyBUaGUgb3Bwb3NpdGUgb2YgXy5vYmplY3QuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgLlxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoZGVmYXVsdHMpIG9iaiA9IE9iamVjdChvYmopO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCFkZWZhdWx0cyB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKS5cbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdC5cbiAgXy5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcGljayBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGBvYmpgIGhhcyBrZXkgYGtleWAuXG4gIHZhciBrZXlJbk9iaiA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgIHJldHVybiBrZXkgaW4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBpdGVyYXRlZSA9IGtleXNbMF07XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGtleXNbMV0pO1xuICAgICAga2V5cyA9IF8uYWxsS2V5cyhvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGtleUluT2JqO1xuICAgICAga2V5cyA9IGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICB2YXIgaXRlcmF0ZWUgPSBrZXlzWzBdLCBjb250ZXh0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIGNvbnRleHQgPSBrZXlzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gXy5tYXAoZmxhdHRlbihrZXlzLCBmYWxzZSwgZmFsc2UpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfSk7XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIF8uZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxLCBkZWVwRXE7XG4gIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgb25seSBlcXVhbCB0byBpdHNlbGYgKHN0cmljdCBjb21wYXJpc29uKS5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgaWYgKGEgIT09IGEpIHJldHVybiBiICE9PSBiO1xuICAgIC8vIEV4aGF1c3QgcHJpbWl0aXZlIGNoZWNrc1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGE7XG4gICAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZGVlcEVxKGEsIGIsIGFTdGFjaywgYlN0YWNrKTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICBkZWVwRXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU4uXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBTeW1ib2xdJzpcbiAgICAgICAgcmV0dXJuIFN5bWJvbFByb3RvLnZhbHVlT2YuY2FsbChhKSA9PT0gU3ltYm9sUHJvdG8udmFsdWVPZi5jYWxsKGIpO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IsIGlzTWFwLCBpc1dlYWtNYXAsIGlzU2V0LCBpc1dlYWtTZXQuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJywgJ1N5bWJvbCcsICdNYXAnLCAnV2Vha01hcCcsICdTZXQnLCAnV2Vha1NldCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBTYWZhcmkgOCAoIzE5MjkpLCBhbmQgUGhhbnRvbUpTICgjMjIzNikuXG4gIHZhciBub2RlbGlzdCA9IHJvb3QuZG9jdW1lbnQgJiYgcm9vdC5kb2N1bWVudC5jaGlsZE5vZGVzO1xuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcgJiYgdHlwZW9mIG5vZGVsaXN0ICE9ICdmdW5jdGlvbicpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhXy5pc1N5bWJvbChvYmopICYmIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gP1xuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBpc05hTihvYmopO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBwYXRoKSB7XG4gICAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIHJldHVybiBoYXMob2JqLCBwYXRoKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwYXRoW2ldO1xuICAgICAgaWYgKG9iaiA9PSBudWxsIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuICEhbGVuZ3RoO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gcGFzc2VkIGFuIG9iamVjdCwgd2lsbCB0cmF2ZXJzZSB0aGF0IG9iamVjdOKAmXNcbiAgLy8gcHJvcGVydGllcyBkb3duIHRoZSBnaXZlbiBgcGF0aGAsIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBrZXlzIG9yIGluZGV4ZXMuXG4gIF8ucHJvcGVydHkgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIHJldHVybiBzaGFsbG93UHJvcGVydHkocGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBkZWVwR2V0KG9iaiwgcGF0aCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXG4gIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7fTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiAhXy5pc0FycmF5KHBhdGgpID8gb2JqW3BhdGhdIDogZGVlcEdldChvYmosIHBhdGgpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXIgPSBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5pc01hdGNoKG9iaiwgYXR0cnMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkLlxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIFRyYXZlcnNlcyB0aGUgY2hpbGRyZW4gb2YgYG9iamAgYWxvbmcgYHBhdGhgLiBJZiBhIGNoaWxkIGlzIGEgZnVuY3Rpb24sIGl0XG4gIC8vIGlzIGludm9rZWQgd2l0aCBpdHMgcGFyZW50IGFzIGNvbnRleHQuIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaW5hbFxuICAvLyBjaGlsZCwgb3IgYGZhbGxiYWNrYCBpZiBhbnkgY2hpbGQgaXMgdW5kZWZpbmVkLlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgZmFsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNBcnJheShwYXRoKSkgcGF0aCA9IFtwYXRoXTtcbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybiBfLmlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2suY2FsbChvYmopIDogZmFsbGJhY2s7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpbcGF0aFtpXV07XG4gICAgICBpZiAocHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByb3AgPSBmYWxsYmFjaztcbiAgICAgICAgaSA9IGxlbmd0aDsgLy8gRW5zdXJlIHdlIGRvbid0IGNvbnRpbnVlIGl0ZXJhdGluZy5cbiAgICAgIH1cbiAgICAgIG9iaiA9IF8uaXNGdW5jdGlvbihwcm9wKSA/IHByb3AuY2FsbChvYmopIDogcHJvcDtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGU6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZVJlZ0V4cCA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2Zmc2V0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHZhciByZW5kZXI7XG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgY2hhaW5SZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBfO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLl93cmFwcGVkKTtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufSgpKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/underscore/underscore.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/Y2VkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./src/components/BlackBoxPlusExport.js":
/*!**********************************************!*\
  !*** ./src/components/BlackBoxPlusExport.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BlackBoxPlusExport; });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\");\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _BlackBoxPlusInfo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BlackBoxPlusInfo */ \"./src/components/BlackBoxPlusInfo.js\");\n\n\n\n\n\n\n\n// @todo import zepto?\n\n\nvar BlackBoxPlusExport =\n/*#__PURE__*/\nfunction (_BlackBoxPlusInfo) {\n  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default()(BlackBoxPlusExport, _BlackBoxPlusInfo);\n\n  function BlackBoxPlusExport() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this, BlackBoxPlusExport);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, (_getPrototypeOf2 = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(BlackBoxPlusExport)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.countInTabs = void 0;\n    _this.urlBaseCache = void 0;\n    return _this;\n  }\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(BlackBoxPlusExport, [{\n    key: \"getCountInTabs\",\n\n    /**\n     * getCountInTabs()\n     *\n     * @returns {Promise<*>}\n     * Example this.countInTabs = {\"countContributeFootages\":115,\"countCurationFootages\":0,\"countContentFootages\":658}\n     */\n    value: function () {\n      var _getCountInTabs = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {\n        var force,\n            _args = arguments;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                force = _args.length > 0 && _args[0] !== undefined ? _args[0] : false;\n\n                if (!(!this.countInTabs || true === force)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                this.setStatusLoading(\"the count of items\");\n                _context.next = 5;\n                return this.callAPI(\"/footage/count_in_tabs\");\n\n              case 5:\n                this.countInTabs = _context.sent;\n\n              case 6:\n                return _context.abrupt(\"return\", this.countInTabs);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getCountInTabs() {\n        return _getCountInTabs.apply(this, arguments);\n      }\n\n      return getCountInTabs;\n    }()\n    /**\n     * Gather Footage Info\n     * @param type Type can be one of: contribute, curation, content\n     * @returns {Promise<[]>}\n     */\n\n  }, {\n    key: \"gatherFootageData\",\n    value: function () {\n      var _gatherFootageData = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2() {\n        var type,\n            memberId,\n            limit,\n            headers,\n            footage,\n            typeMapping,\n            totalRecords,\n            apiType,\n            pagesNeeded,\n            page,\n            index,\n            url,\n            request,\n            requestContent,\n            _args2 = arguments;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                type = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 'contribute';\n                memberId = this.getMemberId();\n                limit = 200; // How many results at a time\n\n                headers = this.getAPICallHeaders('GET');\n                footage = [];\n                this.setStatusLoading(\"the \".concat(type, \" results\"));\n                _context2.next = 8;\n                return this.getCountInTabs();\n\n              case 8:\n                // Ensure the count is set\n                // Example count_in_tabs response = {\"countContributeFootages\":115,\"countCurationFootages\":0,\"countContentFootages\":658}\n                typeMapping = {\n                  contribute: {\n                    totalRecords: this.countInTabs.countContributeFootages,\n                    apiType: 'contribute/footage',\n                    apiPost: ''\n                  },\n                  curation: {\n                    totalRecords: this.countInTabs.countCurationFootages,\n                    apiType: 'curationFootage',\n                    apiPost: ''\n                  },\n                  content: {\n                    totalRecords: this.countInTabs.countContentFootages,\n                    apiType: 'content/footage',\n                    apiPost: '&contentFilter=A' // Get ALL the footage\n\n                  }\n                };\n                totalRecords = typeMapping[type].totalRecords;\n                apiType = typeMapping[type].apiType; // let apiPost = typeMapping[type].apiPost;\n\n                pagesNeeded = Math.ceil(totalRecords / limit); // console.debug({type, totalRecords, apiType, pagesNeeded});\n\n                page = 1;\n\n              case 13:\n                if (!(page <= pagesNeeded)) {\n                  _context2.next = 33;\n                  break;\n                }\n\n                index = (page - 1) * limit + 1;\n                this.setStatusLoading(\"the \".concat(type, \" items. Page \").concat(page, \" of \").concat(pagesNeeded));\n                url = \"https://portal.blackbox.global/api/member/\".concat(memberId, \"/\").concat(apiType, \"?index=\").concat(index, \"&limit=\").concat(limit).concat(typeMapping[type].apiPost);\n                _context2.next = 19;\n                return fetch(url, headers);\n\n              case 19:\n                request = _context2.sent;\n\n                if (!request.ok) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                _context2.next = 23;\n                return request.json();\n\n              case 23:\n                requestContent = _context2.sent;\n\n                // NB: The Workspace response includes success: true and the rest inside a data object. But the content results don't do this\n                // if (requestContent.success !== true) {\n                //     this.setStatusError(`API said it was not successful when trying to get your ${type} footage information. Page ${page} of ${pagesNeeded}`);\n                //     console.error({error: 'Success is not true in the API response', url, requestContent});\n                //     return footage;\n                // }\n                if (requestContent && requestContent.data && requestContent.data.list && requestContent.data.list.length) {\n                  // console.debug(`Adding the ${requestContent.data.list.length} ${type} footage entries to the list. Page ${page} of ${pagesNeeded}`, requestContent);\n                  footage = [].concat(footage, requestContent.data.list);\n                } else if (requestContent && requestContent.list && requestContent.list.length) {\n                  // console.debug(`Adding the ${requestContent.list.length} ${type} footage entries to the list. Page ${page} of ${pagesNeeded}`, requestContent);\n                  footage = [].concat(footage, requestContent.list);\n                }\n\n                _context2.next = 30;\n                break;\n\n              case 27:\n                this.setStatusError(\"Unable to access a copy of your \".concat(type, \" footage information\"));\n                console.error(\"Unable to access a copy of your \".concat(type, \" footage information. Page \").concat(page, \" of \").concat(pagesNeeded, \". URL: \").concat(url), request);\n                return _context2.abrupt(\"return\", footage);\n\n              case 30:\n                page++;\n                _context2.next = 13;\n                break;\n\n              case 33:\n                this.setStatusProcessing(\"the \".concat(footage.length, \" \").concat(type, \" entries\"));\n                return _context2.abrupt(\"return\", footage);\n\n              case 35:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function gatherFootageData() {\n        return _gatherFootageData.apply(this, arguments);\n      }\n\n      return gatherFootageData;\n    }()\n  }, {\n    key: \"getAllFootage\",\n    value: function () {\n      var _getAllFootage = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3() {\n        var _this2 = this;\n\n        var blackBoxPlusFootage;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                blackBoxPlusFootage = {};\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this2.getCountInTabs().then(function () {\n                    var contributePromise = _this2.gatherFootageData('contribute').then(function (data) {\n                      blackBoxPlusFootage.contribute = data; // console.debug(`The contribue footage contains ${data.length} entries`);\n                    });\n\n                    var curationPromise = _this2.gatherFootageData('curation').then(function (data) {\n                      blackBoxPlusFootage.curation = data;\n                    });\n\n                    var contentPromise = _this2.gatherFootageData('content').then(function (data) {\n                      blackBoxPlusFootage.content = data;\n                    }); // When all completed\n\n\n                    Promise.all([contributePromise, curationPromise, contentPromise]).then(function (data) {\n                      // console.debug('The footages data is: ', blackBoxPlusFootage);\n                      _this2.addMessage(\"<p>All Footage data loaded</p>\");\n\n                      resolve(blackBoxPlusFootage);\n                    });\n                  });\n                }));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function getAllFootage() {\n        return _getAllFootage.apply(this, arguments);\n      }\n\n      return getAllFootage;\n    }()\n  }, {\n    key: \"getAllFinancials\",\n    value: function () {\n      var _getAllFinancials = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee4() {\n        var _this3 = this;\n\n        var blackBoxPlusFinancials;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                blackBoxPlusFinancials = {};\n                this.setStatusLoading(\"financial data\");\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var financialSummaryInfoPromise = _this3.getFinancialSummaryInfo().then(function (data) {\n                    blackBoxPlusFinancials.financialSummaryInfo = data; // console.debug(`The financialSummaryInfo contains ${data.length} entries`);\n                  });\n\n                  var financialEarningsSummaryPromise = _this3.getFinancialEarningsSummary().then(function (data) {\n                    blackBoxPlusFinancials.financialEarningsSummary = data; // console.debug(`The getFinancialEarningsSummary contains ${data.length} entries`);\n                  });\n\n                  var getUnpaidEarningsPromise = _this3.getUnpaidEarnings().then(function (data) {\n                    blackBoxPlusFinancials.unpaidEarnings = data;\n                  });\n\n                  var getFinancialPaymentHistoryPromise = _this3.getFinancialPaymentHistory().then(function (data) {\n                    blackBoxPlusFinancials.financialPaymentHistory = data;\n                  });\n\n                  var getFinancialTotalEarningsReportPromise = _this3.getFinancialTotalEarningsReport().then(function (data) {\n                    blackBoxPlusFinancials.financialTotalEarningsReport = data;\n                  }); // When all completed\n\n\n                  Promise.all([financialSummaryInfoPromise, financialEarningsSummaryPromise, getUnpaidEarningsPromise, getFinancialPaymentHistoryPromise, getFinancialTotalEarningsReportPromise]).then(function (data) {\n                    console.debug('The blackBoxPlusFinancials data char length is ', JSON.stringify(blackBoxPlusFinancials).length);\n\n                    _this3.addMessage(\"<p>All Financial data loaded</p>\");\n\n                    resolve(blackBoxPlusFinancials);\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getAllFinancials() {\n        return _getAllFinancials.apply(this, arguments);\n      }\n\n      return getAllFinancials;\n    }()\n    /**\n     *\n     * @returns {Promise<*|undefined>}\n     */\n\n  }, {\n    key: \"getFinancialSummaryInfo\",\n    value: function () {\n      var _getFinancialSummaryInfo = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee5() {\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.callAPI(\"/summaryInfo\"));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getFinancialSummaryInfo() {\n        return _getFinancialSummaryInfo.apply(this, arguments);\n      }\n\n      return getFinancialSummaryInfo;\n    }()\n  }, {\n    key: \"getFinancialEarningsSummary\",\n    value: function () {\n      var _getFinancialEarningsSummary = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee6() {\n        var toDate,\n            fromDate,\n            _args6 = arguments;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                toDate = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : null;\n                fromDate = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : '2017-01-01%2000:00:00';\n                toDate = toDate || this.getFormattedDate(\"{Y}-{M}-{D}\") + '%2023:59:59'; // Until the end of today\n                // Example URL https://portal.blackbox.global/api/member/5afd6163-a82a-4079-8e3b-592c349ae72d/earningSummary?fromDate=2019-11-12%2000:00:00&toDate=2020-02-10%2023:59:59\n\n                return _context6.abrupt(\"return\", this.callAPI(\"/earningSummary?fromDate=\".concat(fromDate, \"&toDate=\").concat(toDate)));\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getFinancialEarningsSummary() {\n        return _getFinancialEarningsSummary.apply(this, arguments);\n      }\n\n      return getFinancialEarningsSummary;\n    }()\n    /**\n     * Unpaid Earnings Summary\n     *\n     * 'My Revenue' page\n     * Described as 'A list of footage have been sold recently but have not been paid'\n     *\n     * You shouldn't need to use the provided values but if you do it\n     * expects toDate and fromDate to be fully formed strings\n     * @param toDate\n     * @param fromDate\n     * @returns {Promise<*|undefined>}\n     */\n\n  }, {\n    key: \"getUnpaidEarnings\",\n    value: function () {\n      var _getUnpaidEarnings = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee7() {\n        var toDate,\n            fromDate,\n            dateMonthAgo,\n            _args7 = arguments;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                toDate = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : null;\n                fromDate = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : null;\n                dateMonthAgo = fromDate || new Date(); // Set it to one month ago\n\n                dateMonthAgo.setMonth(dateMonthAgo.getMonth() - 1); // This works for January as well and goes back to the previous year\n\n                dateMonthAgo.setDate(0); // This will actually from the last day of the month before, just to be sure\n\n                toDate = toDate || this.getFormattedDate(\"{Y}-{M}-{D}\") + '%2023:59:59'; // Until the end of today\n\n                fromDate = fromDate || this.getFormattedDate(\"{Y}-{M}-{D}\", dateMonthAgo) + '%2000:00:00'; // Until the end of today\n                // e.g https://portal.blackbox.global/api/member/5afd6163-a82a-4079-8e3b-592c349ae72d/revenue?fromDate=2019-12-10%2000:00:00&toDate=2020-02-10%2023:59:59&index=1&limit=10\n\n                return _context7.abrupt(\"return\", this.callAPI(\"/revenue?fromDate=\".concat(fromDate, \"&toDate=\").concat(toDate, \"&index=1&limit=500\")));\n\n              case 8:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getUnpaidEarnings() {\n        return _getUnpaidEarnings.apply(this, arguments);\n      }\n\n      return getUnpaidEarnings;\n    }()\n    /**\n     * Payment History (months)\n     *\n     * Note that this deals with the pagination\n     * Also note that the \"totalEarning\" field is lost,\n     * but people using this as CSV can re-created that themselves very easily and\n     * it's on a per request basis so will be wrong if there's multiple API calls\n     *\n     * @returns {Promise<*|undefined>}\n     */\n\n  }, {\n    key: \"getFinancialPaymentHistory\",\n    value: function () {\n      var _getFinancialPaymentHistory = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee8() {\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", this.callPaginatedAPI(\"/paymentHistory?\"));\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getFinancialPaymentHistory() {\n        return _getFinancialPaymentHistory.apply(this, arguments);\n      }\n\n      return getFinancialPaymentHistory;\n    }()\n    /**\n     * Total Earnings Report (Individual sales)\n     *\n     * Note that this deals with the pagination and date ranges\n     *\n     * @returns {Promise<*|undefined>}\n     */\n\n  }, {\n    key: \"getFinancialTotalEarningsReport\",\n    value: function () {\n      var _getFinancialTotalEarningsReport = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee9() {\n        var toDate,\n            fromDate,\n            _args9 = arguments;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                toDate = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : null;\n                fromDate = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : '2017-01-01%2000:00:00';\n                // Total Earnings Report (Individual sales)\n                // https://portal.blackbox.global/api/member/5afd6163-a82a-4079-8e3b-592c349ae72d/earningsReport?fromDate=2019-12-10%2000:00:00&toDate=2020-02-10%2023:59:59&index=1&limit=10\n                // Example {\"items\":[{\"footageId\":\"54e4043f-39eb-4ced-a663-e10745ac2260\",\"footageName\":\"2019-05-16th Oasis One Flight #2 - 14 Sunset descending-.mp4\",\"earning\":18.55,\"totalDownloads\":1,\"dateSold\":\"2020-01-23T00:00:00.000Z\"},{\"footageId\":\"74eab76b-a4b5-4e69-a7e8-afe77b182b1e\",\"footageName\":\"2019-04-21st Manila Bay and StarCity Theme Park - _V1-0022.mp4\",\"earning\":65.46,\"totalDownloads\":1,\"dateSold\":\"2019-12-18T00:00:00.000Z\"}],\"totalEarning\":84.01,\"pageInfo\":{\"totalRecords\":2,\"totalDisplayRecords\":2}}\n                toDate = toDate || this.getFormattedDate(\"{Y}-{M}-{D}\") + '%2023:59:59'; // Until the end of today\n\n                return _context9.abrupt(\"return\", this.callPaginatedAPI(\"/earningsReport?fromDate=\".concat(fromDate, \"&toDate=\").concat(toDate, \"&\")));\n\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getFinancialTotalEarningsReport() {\n        return _getFinancialTotalEarningsReport.apply(this, arguments);\n      }\n\n      return getFinancialTotalEarningsReport;\n    }()\n    /**\n     * Mainly for getting the email address of curation owners, their names are already output in the footage json\n     * @returns {Promise<*|undefined>}\n     *\n     * NB: This isn't used at the moment.\n     */\n\n  }, {\n    key: \"getCurationOwners\",\n    value: function () {\n      var _getCurationOwners = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee10() {\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                return _context10.abrupt(\"return\", this.callAPI(\"curationFootage/getCurationOwners\"));\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getCurationOwners() {\n        return _getCurationOwners.apply(this, arguments);\n      }\n\n      return getCurationOwners;\n    }()\n  }, {\n    key: \"callAPI\",\n    value: function () {\n      var _callAPI = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee11(uri) {\n        var method,\n            headers,\n            url,\n            response,\n            errorMessage,\n            _args11 = arguments;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                method = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : 'GET';\n                this.setStatusLoading(\"Making a call to \".concat(uri));\n                headers = this.getAPICallHeaders(method);\n                url = \"\".concat(this.urlBase).concat(uri);\n                _context11.next = 6;\n                return fetch(url, headers);\n\n              case 6:\n                response = _context11.sent;\n\n                if (!response.ok) {\n                  _context11.next = 13;\n                  break;\n                }\n\n                _context11.next = 10;\n                return response.json();\n\n              case 10:\n                return _context11.abrupt(\"return\", _context11.sent);\n\n              case 13:\n                this.setStatusError(\"trying to make an API call to \".concat(uri));\n                this.addFlashMessage(\"Error trying to make an API call to \".concat(uri));\n                errorMessage = \"No OK response from the API. Got the HTTP status \".concat(response.status, \" when doing a \").concat(method, \" request to \").concat(url);\n                console.log(errorMessage, {\n                  url: url,\n                  uri: uri,\n                  response: response,\n                  headers: headers\n                });\n                throw new Error(errorMessage);\n\n              case 18:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function callAPI(_x) {\n        return _callAPI.apply(this, arguments);\n      }\n\n      return callAPI;\n    }()\n    /**\n     * Call Paginated API\n     *\n     * This deals with the pagination, if needed.\n     *\n     * NB: The ? or & last char of the uri should be provided by the calling method.\n     * @param uri\n     * @param method\n     * @param limit\n     * @returns {Promise<[]>}\n     */\n\n  }, {\n    key: \"callPaginatedAPI\",\n    value: function () {\n      var _callPaginatedAPI = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee12(uri) {\n        var method,\n            limit,\n            index,\n            page,\n            paginatedUri,\n            response,\n            items,\n            pagesNeeded,\n            totalRecords,\n            _index,\n            _args12 = arguments;\n\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                method = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : 'GET';\n                limit = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : 200;\n                index = 1;\n                page = 1;\n                this.setStatusLoading(\"items from \".concat(uri, \". Page \").concat(page));\n                paginatedUri = \"\".concat(uri, \"index=\").concat(index, \"&limit=\").concat(limit); // Add pagination query\n\n                _context12.next = 8;\n                return this.callAPI(paginatedUri, method);\n\n              case 8:\n                response = _context12.sent;\n                // console.debug(`The first paginated call to ${uri}`, {uri, paginatedUri, method, response});\n                items = [];\n                pagesNeeded = 1;\n                totalRecords = 0; // Add the items (or list entries, because their API isn't consistent)\n\n                if (response.items) {\n                  items = [].concat(items, response.items);\n                }\n\n                if (response.list) {\n                  items = [].concat(items, response.list);\n                }\n\n                if (response.pageInfo && response.pageInfo.totalRecords) {\n                  totalRecords = response.pageInfo.totalRecords;\n                  pagesNeeded = Math.ceil(totalRecords / limit);\n                }\n\n                if (!(pagesNeeded < 2)) {\n                  _context12.next = 17;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", items);\n\n              case 17:\n                page = 2;\n\n              case 18:\n                if (!(page <= pagesNeeded)) {\n                  _context12.next = 30;\n                  break;\n                }\n\n                _index = (page - 1) * limit + 1;\n                this.setStatusLoading(\"items from \".concat(uri, \". Page \").concat(page, \" of \").concat(pagesNeeded));\n                paginatedUri = \"\".concat(uri, \"index=\").concat(_index, \"&limit=\").concat(limit); // Add pagination query\n                // console.debug(`About to make the ${page} paginated call to ${uri}`, {paginatedUri, pagesNeeded, totalRecords});\n\n                _context12.next = 24;\n                return this.callAPI(paginatedUri, method);\n\n              case 24:\n                response = _context12.sent;\n\n                if (response.items) {\n                  // Add the entries\n                  items = [].concat(items, response.items);\n                }\n\n                if (response.list) {\n                  // Add the entries\n                  items = [].concat(items, response.list);\n                }\n\n              case 27:\n                page++;\n                _context12.next = 18;\n                break;\n\n              case 30:\n                return _context12.abrupt(\"return\", items);\n\n              case 31:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function callPaginatedAPI(_x2) {\n        return _callPaginatedAPI.apply(this, arguments);\n      }\n\n      return callPaginatedAPI;\n    }() // -- Testing the pagination logic\n    // e.g unitTestablePagination(1802, 200); returns 10 pages worth\n    // unitTestablePagination(totalRecords, limit) {\n    //     let uri = 'test';\n    //     let index = 1;\n    //     let page = 1;\n    //     let pagesNeeded = Math.ceil(totalRecords / limit);\n    //     let paginationInfo = [];\n    //     paginationInfo.push({page, index, pagesNeeded, paginatedUri: `${uri}?index=${index}&limit=${limit}`});\n    //     for (page = 2; page <= pagesNeeded; page++) {\n    //         let index = (page - 1) * limit + 1;\n    //         // this.setStatusLoading(`items from ${uri}. Page ${page} of ${pagesNeeded}`);\n    //         paginationInfo.push({page, index, pagesNeeded, paginatedUri: `${uri}?index=${index}&limit=${limit}`}); // Add pagination query\n    //     }\n    //     return paginationInfo;\n    // }\n\n    /**\n     * Make Link Element Download\n     *\n     * Give it an existing A Href element and turn it into a link to a file download\n     *\n     * @param element\n     * @param content\n     * @param fileName\n     * @param contentType\n     * @returns {*}\n     */\n\n  }, {\n    key: \"makeLinkElementDownload\",\n    value: function makeLinkElementDownload(element, content, fileName, contentType) {\n      var file = new Blob([content], {\n        type: contentType\n      });\n      element.href = URL.createObjectURL(file);\n      element.download = fileName;\n      return element; // Don't actually need the returned element\n    }\n    /**\n     * Make Link Element Download Json\n     *\n     * Give it a link element, the array, object or whatever, plus the filename\n     * @param element\n     * @param jsonContent\n     * @param fileName\n     */\n\n  }, {\n    key: \"makeLinkElementDownloadJson\",\n    value: function makeLinkElementDownloadJson(element, jsonContent) {\n      var fileName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'BlackBox.json';\n      return this.makeLinkElementDownload(element, JSON.stringify(jsonContent, null, 2), fileName + '.json', 'application/json');\n    }\n    /**\n     * Make Link Element Download CSV\n     *\n     * Give it a link element, the array, object or whatever, plus the filename\n     * @param element\n     * @param csvContent\n     * @param fileName\n     */\n\n  }, {\n    key: \"makeLinkElementDownloadCsv\",\n    value: function makeLinkElementDownloadCsv(element, csvContent) {\n      var fileName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'BlackBox.json';\n      return this.makeLinkElementDownload(element, csvContent, fileName + '.csv', 'text/csv');\n    }\n    /**\n     *\n     * If you want a new A link element\n     * But mostly so you can have it automatically clicked and start the download\n     * @param content\n     * @param fileName\n     * @param contentType\n     * @param downloadAutomatically\n     * @returns {HTMLAnchorElement}\n     */\n\n  }, {\n    key: \"createDownloadLinkElement\",\n    value: function createDownloadLinkElement(content, fileName, contentType) {\n      var downloadAutomatically = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var a = document.createElement(\"a\");\n      var file = new Blob([content], {\n        type: contentType\n      });\n      a.href = URL.createObjectURL(file);\n      a.download = fileName;\n      a.innerText = fileName;\n\n      if (true === downloadAutomatically) {\n        a.click(); // Automatically try to download the file cc\n      }\n\n      return a;\n    }\n  }, {\n    key: \"urlBase\",\n    get: function get() {\n      if (this.urlBaseCache) {\n        return this.urlBaseCache;\n      } else {\n        var memberId = this.getMemberId();\n        return this.urlBaseCache = \"https://portal.blackbox.global/api/member/\".concat(memberId);\n      }\n    }\n  }]);\n\n  return BlackBoxPlusExport;\n}(_BlackBoxPlusInfo__WEBPACK_IMPORTED_MODULE_7__[\"default\"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9CbGFja0JveFBsdXNFeHBvcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CbGFja0JveFBsdXNFeHBvcnQuanM/NDU0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdG9kbyBpbXBvcnQgemVwdG8/XG5pbXBvcnQgQmxhY2tCb3hQbHVzSW5mbyBmcm9tIFwiLi9CbGFja0JveFBsdXNJbmZvXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsYWNrQm94UGx1c0V4cG9ydCBleHRlbmRzIEJsYWNrQm94UGx1c0luZm8ge1xuXG4gICAgLy8gaHR0cHM6Ly9wb3J0YWwuYmxhY2tib3guZ2xvYmFsL2FwaS9tZW1iZXIvNWFmZDYxNjMtYTgyYS00MDc5LThlM2ItNTkyYzM0OWFlNzJkL2NvbnRyaWJ1dGUvZm9vdGFnZT9pbmRleD0xMSZsaW1pdD0xMFxuICAgIGNvdW50SW5UYWJzO1xuICAgIHVybEJhc2VDYWNoZTtcblxuICAgIC8qKlxuICAgICAqIGdldENvdW50SW5UYWJzKClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqIEV4YW1wbGUgdGhpcy5jb3VudEluVGFicyA9IHtcImNvdW50Q29udHJpYnV0ZUZvb3RhZ2VzXCI6MTE1LFwiY291bnRDdXJhdGlvbkZvb3RhZ2VzXCI6MCxcImNvdW50Q29udGVudEZvb3RhZ2VzXCI6NjU4fVxuICAgICAqL1xuICAgIGFzeW5jIGdldENvdW50SW5UYWJzKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvdW50SW5UYWJzIHx8IHRydWUgPT09IGZvcmNlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1c0xvYWRpbmcoYHRoZSBjb3VudCBvZiBpdGVtc2ApO1xuICAgICAgICAgICAgdGhpcy5jb3VudEluVGFicyA9IGF3YWl0IHRoaXMuY2FsbEFQSShgL2Zvb3RhZ2UvY291bnRfaW5fdGFic2ApO1xuICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhcIlRoZSBjb3VudEluVGFicyBpczogXCIsIHRoaXMuY291bnRJblRhYnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50SW5UYWJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdhdGhlciBGb290YWdlIEluZm9cbiAgICAgKiBAcGFyYW0gdHlwZSBUeXBlIGNhbiBiZSBvbmUgb2Y6IGNvbnRyaWJ1dGUsIGN1cmF0aW9uLCBjb250ZW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8W10+fVxuICAgICAqL1xuICAgIGFzeW5jIGdhdGhlckZvb3RhZ2VEYXRhKHR5cGUgPSAnY29udHJpYnV0ZScpIHtcbiAgICAgICAgbGV0IG1lbWJlcklkID0gdGhpcy5nZXRNZW1iZXJJZCgpO1xuICAgICAgICBsZXQgbGltaXQgPSAyMDA7IC8vIEhvdyBtYW55IHJlc3VsdHMgYXQgYSB0aW1lXG4gICAgICAgIGxldCBoZWFkZXJzID0gdGhpcy5nZXRBUElDYWxsSGVhZGVycygnR0VUJyk7XG4gICAgICAgIGxldCBmb290YWdlID0gW107XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzTG9hZGluZyhgdGhlICR7dHlwZX0gcmVzdWx0c2ApO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0Q291bnRJblRhYnMoKTsgLy8gRW5zdXJlIHRoZSBjb3VudCBpcyBzZXRcbiAgICAgICAgLy8gRXhhbXBsZSBjb3VudF9pbl90YWJzIHJlc3BvbnNlID0ge1wiY291bnRDb250cmlidXRlRm9vdGFnZXNcIjoxMTUsXCJjb3VudEN1cmF0aW9uRm9vdGFnZXNcIjowLFwiY291bnRDb250ZW50Rm9vdGFnZXNcIjo2NTh9XG4gICAgICAgIGxldCB0eXBlTWFwcGluZyA9IHtcbiAgICAgICAgICAgIGNvbnRyaWJ1dGU6IHtcbiAgICAgICAgICAgICAgICB0b3RhbFJlY29yZHM6IHRoaXMuY291bnRJblRhYnMuY291bnRDb250cmlidXRlRm9vdGFnZXMsXG4gICAgICAgICAgICAgICAgYXBpVHlwZTogJ2NvbnRyaWJ1dGUvZm9vdGFnZScsXG4gICAgICAgICAgICAgICAgYXBpUG9zdDogJycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICB0b3RhbFJlY29yZHM6IHRoaXMuY291bnRJblRhYnMuY291bnRDdXJhdGlvbkZvb3RhZ2VzLFxuICAgICAgICAgICAgICAgIGFwaVR5cGU6ICdjdXJhdGlvbkZvb3RhZ2UnLFxuICAgICAgICAgICAgICAgIGFwaVBvc3Q6ICcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICB0b3RhbFJlY29yZHM6IHRoaXMuY291bnRJblRhYnMuY291bnRDb250ZW50Rm9vdGFnZXMsXG4gICAgICAgICAgICAgICAgYXBpVHlwZTogJ2NvbnRlbnQvZm9vdGFnZScsXG4gICAgICAgICAgICAgICAgYXBpUG9zdDogJyZjb250ZW50RmlsdGVyPUEnLCAvLyBHZXQgQUxMIHRoZSBmb290YWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHRvdGFsUmVjb3JkcyA9IHR5cGVNYXBwaW5nW3R5cGVdLnRvdGFsUmVjb3JkcztcbiAgICAgICAgbGV0IGFwaVR5cGUgPSB0eXBlTWFwcGluZ1t0eXBlXS5hcGlUeXBlO1xuICAgICAgICAvLyBsZXQgYXBpUG9zdCA9IHR5cGVNYXBwaW5nW3R5cGVdLmFwaVBvc3Q7XG4gICAgICAgIGxldCBwYWdlc05lZWRlZCA9IE1hdGguY2VpbCh0b3RhbFJlY29yZHMgLyBsaW1pdCk7XG4gICAgICAgIC8vIGNvbnNvbGUuZGVidWcoe3R5cGUsIHRvdGFsUmVjb3JkcywgYXBpVHlwZSwgcGFnZXNOZWVkZWR9KTtcbiAgICAgICAgZm9yIChsZXQgcGFnZSA9IDE7IHBhZ2UgPD0gcGFnZXNOZWVkZWQ7IHBhZ2UrKykge1xuXG4gICAgICAgICAgICBsZXQgaW5kZXggPSAocGFnZSAtIDEpICogbGltaXQgKyAxO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXNMb2FkaW5nKGB0aGUgJHt0eXBlfSBpdGVtcy4gUGFnZSAke3BhZ2V9IG9mICR7cGFnZXNOZWVkZWR9YCk7XG4gICAgICAgICAgICBsZXQgdXJsID0gYGh0dHBzOi8vcG9ydGFsLmJsYWNrYm94Lmdsb2JhbC9hcGkvbWVtYmVyLyR7bWVtYmVySWR9LyR7YXBpVHlwZX0/aW5kZXg9JHtpbmRleH0mbGltaXQ9JHtsaW1pdH0ke3R5cGVNYXBwaW5nW3R5cGVdLmFwaVBvc3R9YDtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2godXJsLCBoZWFkZXJzKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm9rKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlcXVlc3RDb250ZW50ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgICAgICAgICAgICAgLy8gTkI6IFRoZSBXb3Jrc3BhY2UgcmVzcG9uc2UgaW5jbHVkZXMgc3VjY2VzczogdHJ1ZSBhbmQgdGhlIHJlc3QgaW5zaWRlIGEgZGF0YSBvYmplY3QuIEJ1dCB0aGUgY29udGVudCByZXN1bHRzIGRvbid0IGRvIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBpZiAocmVxdWVzdENvbnRlbnQuc3VjY2VzcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLnNldFN0YXR1c0Vycm9yKGBBUEkgc2FpZCBpdCB3YXMgbm90IHN1Y2Nlc3NmdWwgd2hlbiB0cnlpbmcgdG8gZ2V0IHlvdXIgJHt0eXBlfSBmb290YWdlIGluZm9ybWF0aW9uLiBQYWdlICR7cGFnZX0gb2YgJHtwYWdlc05lZWRlZH1gKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc29sZS5lcnJvcih7ZXJyb3I6ICdTdWNjZXNzIGlzIG5vdCB0cnVlIGluIHRoZSBBUEkgcmVzcG9uc2UnLCB1cmwsIHJlcXVlc3RDb250ZW50fSk7XG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiBmb290YWdlO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdENvbnRlbnQgJiYgcmVxdWVzdENvbnRlbnQuZGF0YSAmJiByZXF1ZXN0Q29udGVudC5kYXRhLmxpc3QgJiYgcmVxdWVzdENvbnRlbnQuZGF0YS5saXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmRlYnVnKGBBZGRpbmcgdGhlICR7cmVxdWVzdENvbnRlbnQuZGF0YS5saXN0Lmxlbmd0aH0gJHt0eXBlfSBmb290YWdlIGVudHJpZXMgdG8gdGhlIGxpc3QuIFBhZ2UgJHtwYWdlfSBvZiAke3BhZ2VzTmVlZGVkfWAsIHJlcXVlc3RDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZm9vdGFnZSA9IFtdLmNvbmNhdChmb290YWdlLCByZXF1ZXN0Q29udGVudC5kYXRhLmxpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0Q29udGVudCAmJiByZXF1ZXN0Q29udGVudC5saXN0ICYmIHJlcXVlc3RDb250ZW50Lmxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoYEFkZGluZyB0aGUgJHtyZXF1ZXN0Q29udGVudC5saXN0Lmxlbmd0aH0gJHt0eXBlfSBmb290YWdlIGVudHJpZXMgdG8gdGhlIGxpc3QuIFBhZ2UgJHtwYWdlfSBvZiAke3BhZ2VzTmVlZGVkfWAsIHJlcXVlc3RDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZm9vdGFnZSA9IFtdLmNvbmNhdChmb290YWdlLCByZXF1ZXN0Q29udGVudC5saXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzRXJyb3IoYFVuYWJsZSB0byBhY2Nlc3MgYSBjb3B5IG9mIHlvdXIgJHt0eXBlfSBmb290YWdlIGluZm9ybWF0aW9uYCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5hYmxlIHRvIGFjY2VzcyBhIGNvcHkgb2YgeW91ciAke3R5cGV9IGZvb3RhZ2UgaW5mb3JtYXRpb24uIFBhZ2UgJHtwYWdlfSBvZiAke3BhZ2VzTmVlZGVkfS4gVVJMOiAke3VybH1gLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9vdGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXR1c1Byb2Nlc3NpbmcoYHRoZSAke2Zvb3RhZ2UubGVuZ3RofSAke3R5cGV9IGVudHJpZXNgKTtcblxuICAgICAgICByZXR1cm4gZm9vdGFnZTtcblxuICAgICAgICAvLyBDb250cmlidXRlXG4gICAgICAgIC8vIGh0dHBzOi8vcG9ydGFsLmJsYWNrYm94Lmdsb2JhbC9hcGkvbWVtYmVyLyR7bWVtYmVySWR9L3Byb2plY3QvJHtlbGVtZW50LnByb2plY3RJZH0vYCwgaGVhZGVycyk7XG4gICAgICAgIC8vIGh0dHBzOi8vcG9ydGFsLmJsYWNrYm94Lmdsb2JhbC9hcGkvbWVtYmVyLzVhZmQ2MTYzLWE4MmEtNDA3OS04ZTNiLTU5MmMzNDlhZTcyZC9jb250cmlidXRlL2Zvb3RhZ2U/aW5kZXg9MTEmbGltaXQ9MTBcblxuICAgICAgICAvLyBFeGFtcGxlIFJlc3BvbnNlOiB7XCJzdWNjZXNzXCI6dHJ1ZSxcImRhdGFcIjp7XCJsaXN0XCI6W3tcImZvb3RhZ2VJZFwiOlwiNjI3NTQ0OTMtY2NjMS00NjcyLWJjZjctYWZkZDE0ODFlZTA5XCIsXCJtZW1iZXJJZFwiOlwiNWFmZDYxNjMtYTgyYS00MDc5LThlM2ItNTkyYzM0OWFlNzJkXCIsXCJ1cGxvYWRlZEJ5XCI6XCI1YWZkNjE2My1hODJhLTQwNzktOGUzYi01OTJjMzQ5YWU3MmRcIixcInByb2plY3RJZFwiOm51bGwsXCJvcmlnaW5hbEZpbGVOYW1lXCI6XCIyMDE5LTAzLTE1dGggQ2VidSBUcmlwIERheSAxIC0gSXNsYW5kLCBTYXJkaW5lcywgVHVydGxlLCBLYXdhc2FuIGZhbGxzIGNhbnlvbmVlcmluZyAoNEsgNTBmcHMgR29Qcm8pIC0gX1YxLTAwMjUubXA0XCIsXCJjcmVhdGVkQXRcIjpcIjIwMjAtMDEtMDJUMDU6NDk6MzYuMDAwWlwiLFwib3duZXJzaGlwXCI6NjAsXCJpc093bmVyXCI6dHJ1ZSxcImFwcHJvdmFsU3RhdHVzXCI6XCJhcHByb3ZlZFwiLFwiYmF0Y2hOYW1lXCI6XCJcIixcImNhblN1Ym1pdFwiOmZhbHNlLFwiZGVzY3JpcHRpb25cIjpudWxsLFwia2V5d29yZHNcIjpcIlwiLFwic3VibWlzc2lvbkRhdGVcIjpudWxsLFwib3duZXJGdWxsTmFtZVwiOlwiTWljaGFlbCBLdWJsZXJcIixcInRyYW5zaXRpb25TdGF0dXNcIjpcIlVwbG9hZGVkXCIsXCJyZXZpZXdTdGF0dXNcIjpudWxsLFwiY2FuRGVsZXRlXCI6dHJ1ZSxcInNoYXJlcnNcIjpbXSxcImVkaXRvcmlhbFwiOmZhbHNlLFwiZWRpdG9yaWFsQ2l0eVwiOm51bGwsXCJlZGl0b3JpYWxTdGF0ZVwiOm51bGwsXCJlZGl0b3JpYWxDb3VudHJ5XCI6bnVsbCxcImVkaXRvcmlhbFRleHRcIjpudWxsLFwiY2F0ZWdvcnlcIjpudWxsLFwiYmF0Y2hJZFwiOm51bGwsXCJjYW5QcmV2aWV3XCI6dHJ1ZSxcImNhbkFzc2lnbkN1cmF0b3JcIjpmYWxzZSxcImN1cmF0b3JzXCI6W3tcImlkXCI6XCIxYWQ2ZTg4Mi00MTQ2LTRhZjUtOGQzMy00NTg2YzZkZWI2MGJcIixcImZ1bGxOYW1lXCI6XCJKb3ZlbHluIENhYmFodWcgRG9taW5nb1wiLFwiY29sbGFiU2hhcmVcIjo0MCxcImNvbGxhYlR5cGVcIjpcImN1cmF0b3JcIixcImxvY2tlZFwiOmZhbHNlfV0sXCJkb2N1bWVudHNcIjp7XCJtb2RlbERvY3VtZW50c1wiOltdLFwicHJvcGVydHlEb2N1bWVudHNcIjpbXX0sXCJpc0F0dGFjaGVkUmVsZWFzZVwiOmZhbHNlLFwicmV2aWV3UmVxdWlyZWRcIjpmYWxzZSxcImN1cmF0aW9uU3RhdHVzXCI6XCJpbmNvbXBsZXRlXCIsXCJyZWplY3RlZFJlYXNvblwiOltdLFwibm90ZVRvT3duZXJcIjpudWxsfSx7XCJmb290YWdlSWRcIjpcIjljMGMwYmFhLWM3MTUtNGUyZS05MGIyLWU5MmIzMDU4MWI4Y1wiLFwibWVtYmVySWRcIjpcIjVhZmQ2MTYzLWE4MmEtNDA3OS04ZTNiLTU5MmMzNDlhZTcyZFwiLFwidXBsb2FkZWRCeVwiOlwiNWFmZDYxNjMtYTgyYS00MDc5LThlM2ItNTkyYzM0OWFlNzJkXCIsXCJwcm9qZWN0SWRcIjpudWxsLFwib3JpZ2luYWxGaWxlTmFtZVwiOlwiMjAxOS0wMy0xNXRoIENlYnUgVHJpcCBEYXkgMSAtIElzbGFuZCwgU2FyZGluZXMsIFR1cnRsZSwgS2F3YXNhbiBmYWxscyBjYW55b25lZXJpbmcgKDRLIDUwZnBzIEdvUHJvKSAtIF9WMS0wMDUwLm1wNFwiLFwiY3JlYXRlZEF0XCI6XCIyMDIwLTAxLTAyVDA1OjM5OjI0LjAwMFpcIixcIm93bmVyc2hpcFwiOjYwLFwiaXNPd25lclwiOnRydWUsXCJhcHByb3ZhbFN0YXR1c1wiOlwiYXBwcm92ZWRcIixcImJhdGNoTmFtZVwiOlwiXCIsXCJjYW5TdWJtaXRcIjpmYWxzZSxcImRlc2NyaXB0aW9uXCI6bnVsbCxcImtleXdvcmRzXCI6XCJcIixcInN1Ym1pc3Npb25EYXRlXCI6bnVsbCxcIm93bmVyRnVsbE5hbWVcIjpcIk1pY2hhZWwgS3VibGVyXCIsXCJ0cmFuc2l0aW9uU3RhdHVzXCI6XCJVcGxvYWRlZFwiLFwicmV2aWV3U3RhdHVzXCI6bnVsbCxcImNhbkRlbGV0ZVwiOnRydWUsXCJzaGFyZXJzXCI6W10sXCJlZGl0b3JpYWxcIjpmYWxzZSxcImVkaXRvcmlhbENpdHlcIjpudWxsLFwiZWRpdG9yaWFsU3RhdGVcIjpudWxsLFwiZWRpdG9yaWFsQ291bnRyeVwiOm51bGwsXCJlZGl0b3JpYWxUZXh0XCI6bnVsbCxcImNhdGVnb3J5XCI6bnVsbCxcImJhdGNoSWRcIjpudWxsLFwiY2FuUHJldmlld1wiOnRydWUsXCJjYW5Bc3NpZ25DdXJhdG9yXCI6ZmFsc2UsXCJjdXJhdG9yc1wiOlt7XCJpZFwiOlwiMWFkNmU4ODItNDE0Ni00YWY1LThkMzMtNDU4NmM2ZGViNjBiXCIsXCJmdWxsTmFtZVwiOlwiSm92ZWx5biBDYWJhaHVnIERvbWluZ29cIixcImNvbGxhYlNoYXJlXCI6NDAsXCJjb2xsYWJUeXBlXCI6XCJjdXJhdG9yXCIsXCJsb2NrZWRcIjpmYWxzZX1dLFwiZG9jdW1lbnRzXCI6e1wibW9kZWxEb2N1bWVudHNcIjpbXSxcInByb3BlcnR5RG9jdW1lbnRzXCI6W119LFwiaXNBdHRhY2hlZFJlbGVhc2VcIjpmYWxzZSxcInJldmlld1JlcXVpcmVkXCI6ZmFsc2UsXCJjdXJhdGlvblN0YXR1c1wiOlwiaW5jb21wbGV0ZVwiLFwicmVqZWN0ZWRSZWFzb25cIjpbXSxcIm5vdGVUb093bmVyXCI6bnVsbH0se1wiZm9vdGFnZUlkXCI6XCJhYzdhODk5Ny03OTc3LTQ4NjEtOGNkZC01NTNiNWQ3ZmMzNWJcIixcIm1lbWJlcklkXCI6XCI1YWZkNjE2My1hODJhLTQwNzktOGUzYi01OTJjMzQ5YWU3MmRcIixcInVwbG9hZGVkQnlcIjpcIjVhZmQ2MTYzLWE4MmEtNDA3OS04ZTNiLTU5MmMzNDlhZTcyZFwiLFwicHJvamVjdElkXCI6bnVsbCxcIm9yaWdpbmFsRmlsZU5hbWVcIjpcIjIwMTktMDMtMTV0aCBDZWJ1IFRyaXAgRGF5IDEgLSBJc2xhbmQsIFNhcmRpbmVzLCBUdXJ0bGUsIEthd2FzYW4gZmFsbHMgY2FueW9uZWVyaW5nICg0SyA1MGZwcyBHb1BybykgLSBfVjEtMDA0OS5tcDRcIixcImNyZWF0ZWRBdFwiOlwiMjAyMC0wMS0wMlQwNTozNzoyMC4wMDBaXCIsXCJvd25lcnNoaXBcIjo2MCxcImlzT3duZXJcIjp0cnVlLFwiYXBwcm92YWxTdGF0dXNcIjpcImFwcHJvdmVkXCIsXCJiYXRjaE5hbWVcIjpcIlwiLFwiY2FuU3VibWl0XCI6ZmFsc2UsXCJkZXNjcmlwdGlvblwiOm51bGwsXCJrZXl3b3Jkc1wiOlwiXCIsXCJzdWJtaXNzaW9uRGF0ZVwiOm51bGwsXCJvd25lckZ1bGxOYW1lXCI6XCJNaWNoYWVsIEt1YmxlclwiLFwidHJhbnNpdGlvblN0YXR1c1wiOlwiVXBsb2FkZWRcIixcInJldmlld1N0YXR1c1wiOm51bGwsXCJjYW5EZWxldGVcIjp0cnVlLFwic2hhcmVyc1wiOltdLFwiZWRpdG9yaWFsXCI6ZmFsc2UsXCJlZGl0b3JpYWxDaXR5XCI6bnVsbCxcImVkaXRvcmlhbFN0YXRlXCI6bnVsbCxcImVkaXRvcmlhbENvdW50cnlcIjpudWxsLFwiZWRpdG9yaWFsVGV4dFwiOm51bGwsXCJjYXRlZ29yeVwiOm51bGwsXCJiYXRjaElkXCI6bnVsbCxcImNhblByZXZpZXdcIjp0cnVlLFwiY2FuQXNzaWduQ3VyYXRvclwiOmZhbHNlLFwiY3VyYXRvcnNcIjpbe1wiaWRcIjpcIjFhZDZlODgyLTQxNDYtNGFmNS04ZDMzLTQ1ODZjNmRlYjYwYlwiLFwiZnVsbE5hbWVcIjpcIkpvdmVseW4gQ2FiYWh1ZyBEb21pbmdvXCIsXCJjb2xsYWJTaGFyZVwiOjQwLFwiY29sbGFiVHlwZVwiOlwiY3VyYXRvclwiLFwibG9ja2VkXCI6ZmFsc2V9XSxcImRvY3VtZW50c1wiOntcIm1vZGVsRG9jdW1lbnRzXCI6W10sXCJwcm9wZXJ0eURvY3VtZW50c1wiOltdfSxcImlzQXR0YWNoZWRSZWxlYXNlXCI6ZmFsc2UsXCJyZXZpZXdSZXF1aXJlZFwiOmZhbHNlLFwiY3VyYXRpb25TdGF0dXNcIjpcImluY29tcGxldGVcIixcInJlamVjdGVkUmVhc29uXCI6W10sXCJub3RlVG9Pd25lclwiOm51bGx9LHtcImZvb3RhZ2VJZFwiOlwiOTg2MTQyNDYtMmM0MC00YjlmLTg1NWItYTVhMjIwZjY2YTE4XCIsXCJtZW1iZXJJZFwiOlwiNWFmZDYxNjMtYTgyYS00MDc5LThlM2ItNTkyYzM0OWFlNzJkXCIsXCJ1cGxvYWRlZEJ5XCI6XCI1YWZkNjE2My1hODJhLTQwNzktOGUzYi01OTJjMzQ5YWU3MmRcIixcInByb2plY3RJZFwiOm51bGwsXCJvcmlnaW5hbEZpbGVOYW1lXCI6XCIyMDE5LTAzLTE1dGggQ2VidSBUcmlwIERheSAxIC0gSXNsYW5kLCBTYXJkaW5lcywgVHVydGxlLCBLYXdhc2FuIGZhbGxzIGNhbnlvbmVlcmluZyAoNEsgNTBmcHMgR29Qcm8pIC0gX1YxLTAwMjcubXA0XCIsXCJjcmVhdGVkQXRcIjpcIjIwMjAtMDEtMDJUMDU6MzE6MDAuMDAwWlwiLFwib3duZXJzaGlwXCI6NjAsXCJpc093bmVyXCI6dHJ1ZSxcImFwcHJvdmFsU3RhdHVzXCI6XCJhcHByb3ZlZFwiLFwiYmF0Y2hOYW1lXCI6XCJcIixcImNhblN1Ym1pdFwiOmZhbHNlLFwiZGVzY3JpcHRpb25cIjpudWxsLFwia2V5d29yZHNcIjpcIlwiLFwic3VibWlzc2lvbkRhdGVcIjpudWxsLFwib3duZXJGdWxsTmFtZVwiOlwiTWljaGFlbCBLdWJsZXJcIixcInRyYW5zaXRpb25TdGF0dXNcIjpcIlVwbG9hZGVkXCIsXCJyZXZpZXdTdGF0dXNcIjpudWxsLFwiY2FuRGVsZXRlXCI6dHJ1ZSxcInNoYXJlcnNcIjpbXSxcImVkaXRvcmlhbFwiOmZhbHNlLFwiZWRpdG9yaWFsQ2l0eVwiOm51bGwsXCJlZGl0b3JpYWxTdGF0ZVwiOm51bGwsXCJlZGl0b3JpYWxDb3VudHJ5XCI6bnVsbCxcImVkaXRvcmlhbFRleHRcIjpudWxsLFwiY2F0ZWdvcnlcIjpudWxsLFwiYmF0Y2hJZFwiOm51bGwsXCJjYW5QcmV2aWV3XCI6dHJ1ZSxcImNhbkFzc2lnbkN1cmF0b3JcIjpmYWxzZSxcImN1cmF0b3JzXCI6W3tcImlkXCI6XCIxYWQ2ZTg4Mi00MTQ2LTRhZjUtOGQzMy00NTg2YzZkZWI2MGJcIixcImZ1bGxOYW1lXCI6XCJKb3ZlbHluIENhYmFodWcgRG9taW5nb1wiLFwiY29sbGFiU2hhcmVcIjo0MCxcImNvbGxhYlR5cGVcIjpcImN1cmF0b3JcIixcImxvY2tlZFwiOmZhbHNlfV0sXCJkb2N1bWVudHNcIjp7XCJtb2RlbERvY3VtZW50c1wiOltdLFwicHJvcGVydHlEb2N1bWVudHNcIjpbXX0sXCJpc0F0dGFjaGVkUmVsZWFzZVwiOmZhbHNlLFwicmV2aWV3UmVxdWlyZWRcIjpmYWxzZSxcImN1cmF0aW9uU3RhdHVzXCI6XCJpbmNvbXBsZXRlXCIsXCJyZWplY3RlZFJlYXNvblwiOltdLFwibm90ZVRvT3duZXJcIjpudWxsfSx7XCJmb290YWdlSWRcIjpcIjcyYTAzOGFiLWM2ZDEtNDQxYS05YTQzLThmMjlhOTk0ZWIyNlwiLFwibWVtYmVySWRcIjpcIjVhZmQ2MTYzLWE4MmEtNDA3OS04ZTNiLTU5MmMzNDlhZTcyZFwiLFwidXBsb2FkZWRCeVwiOlwiNWFmZDYxNjMtYTgyYS00MDc5LThlM2ItNTkyYzM0OWFlNzJkXCIsXCJwcm9qZWN0SWRcIjpudWxsLFwib3JpZ2luYWxGaWxlTmFtZVwiOlwiMjAxOS0wMy0xNXRoIENlYnUgVHJpcCBEYXkgMSAtIElzbGFuZCwgU2FyZGluZXMsIFR1cnRsZSwgS2F3YXNhbiBmYWxscyBjYW55b25lZXJpbmcgKDRLIDUwZnBzIEdvUHJvKSAtIF9WMS0wMDQ4Lm1wNFwiLFwiY3JlYXRlZEF0XCI6XCIyMDIwLTAxLTAyVDA1OjI3OjIyLjAwMFpcIixcIm93bmVyc2hpcFwiOjYwLFwiaXNPd25lclwiOnRydWUsXCJhcHByb3ZhbFN0YXR1c1wiOlwiYXBwcm92ZWRcIixcImJhdGNoTmFtZVwiOlwiXCIsXCJjYW5TdWJtaXRcIjpmYWxzZSxcImRlc2NyaXB0aW9uXCI6bnVsbCxcImtleXdvcmRzXCI6XCJcIixcInN1Ym1pc3Npb25EYXRlXCI6bnVsbCxcIm93bmVyRnVsbE5hbWVcIjpcIk1pY2hhZWwgS3VibGVyXCIsXCJ0cmFuc2l0aW9uU3RhdHVzXCI6XCJVcGxvYWRlZFwiLFwicmV2aWV3U3RhdHVzXCI6bnVsbCxcImNhbkRlbGV0ZVwiOnRydWUsXCJzaGFyZXJzXCI6W10sXCJlZGl0b3JpYWxcIjpmYWxzZSxcImVkaXRvcmlhbENpdHlcIjpudWxsLFwiZWRpdG9yaWFsU3RhdGVcIjpudWxsLFwiZWRpdG9yaWFsQ291bnRyeVwiOm51bGwsXCJlZGl0b3JpYWxUZXh0XCI6bnVsbCxcImNhdGVnb3J5XCI6bnVsbCxcImJhdGNoSWRcIjpudWxsLFwiY2FuUHJldmlld1wiOnRydWUsXCJjYW5Bc3NpZ25DdXJhdG9yXCI6ZmFsc2UsXCJjdXJhdG9yc1wiOlt7XCJpZFwiOlwiMWFkNmU4ODItNDE0Ni00YWY1LThkMzMtNDU4NmM2ZGViNjBiXCIsXCJmdWxsTmFtZVwiOlwiSm92ZWx5biBDYWJhaHVnIERvbWluZ29cIixcImNvbGxhYlNoYXJlXCI6NDAsXCJjb2xsYWJUeXBlXCI6XCJjdXJhdG9yXCIsXCJsb2NrZWRcIjpmYWxzZX1dLFwiZG9jdW1lbnRzXCI6e1wibW9kZWxEb2N1bWVudHNcIjpbXSxcInByb3BlcnR5RG9jdW1lbnRzXCI6W119LFwiaXNBdHRhY2hlZFJlbGVhc2VcIjpmYWxzZSxcInJldmlld1JlcXVpcmVkXCI6ZmFsc2UsXCJjdXJhdGlvblN0YXR1c1wiOlwiaW5jb21wbGV0ZVwiLFwicmVqZWN0ZWRSZWFzb25cIjpbXSxcIm5vdGVUb093bmVyXCI6bnVsbH0se1wiZm9vdGFnZUlkXCI6XCIyMGQ0MTE1Mi1mYzcyLTQ4MjYtOTk5OS1jZDY4ZTI2NDY5MjdcIixcIm1lbWJlcklkXCI6XCI1YWZkNjE2My1hODJhLTQwNzktOGUzYi01OTJjMzQ5YWU3MmRcIixcInVwbG9hZGVkQnlcIjpcIjVhZmQ2MTYzLWE4MmEtNDA3OS04ZTNiLTU5MmMzNDlhZTcyZFwiLFwicHJvamVjdElkXCI6bnVsbCxcIm9yaWdpbmFsRmlsZU5hbWVcIjpcIjIwMTktMDMtMTV0aCBDZWJ1IFRyaXAgRGF5IDEgLSBJc2xhbmQsIFNhcmRpbmVzLCBUdXJ0bGUsIEthd2FzYW4gZmFsbHMgY2FueW9uZWVyaW5nICg0SyA1MGZwcyBHb1BybykgLSBfVjEtMDA0Ni5tcDRcIixcImNyZWF0ZWRBdFwiOlwiMjAyMC0wMS0wMlQwNToyNTowOS4wMDBaXCIsXCJvd25lcnNoaXBcIjo2MCxcImlzT3duZXJcIjp0cnVlLFwiYXBwcm92YWxTdGF0dXNcIjpcImFwcHJvdmVkXCIsXCJiYXRjaE5hbWVcIjpcIlwiLFwiY2FuU3VibWl0XCI6ZmFsc2UsXCJkZXNjcmlwdGlvblwiOm51bGwsXCJrZXl3b3Jkc1wiOlwiXCIsXCJzdWJtaXNzaW9uRGF0ZVwiOm51bGwsXCJvd25lckZ1bGxOYW1lXCI6XCJNaWNoYWVsIEt1YmxlclwiLFwidHJhbnNpdGlvblN0YXR1c1wiOlwiVXBsb2FkZWRcIixcInJldmlld1N0YXR1c1wiOm51bGwsXCJjYW5EZWxldGVcIjp0cnVlLFwic2hhcmVyc1wiOltdLFwiZWRpdG9yaWFsXCI6ZmFsc2UsXCJlZGl0b3JpYWxDaXR5XCI6bnVsbCxcImVkaXRvcmlhbFN0YXRlXCI6bnVsbCxcImVkaXRvcmlhbENvdW50cnlcIjpudWxsLFwiZWRpdG9yaWFsVGV4dFwiOm51bGwsXCJjYXRlZ29yeVwiOm51bGwsXCJiYXRjaElkXCI6bnVsbCxcImNhblByZXZpZXdcIjp0cnVlLFwiY2FuQXNzaWduQ3VyYXRvclwiOmZhbHNlLFwiY3VyYXRvcnNcIjpbe1wiaWRcIjpcIjFhZDZlODgyLTQxNDYtNGFmNS04ZDMzLTQ1ODZjNmRlYjYwYlwiLFwiZnVsbE5hbWVcIjpcIkpvdmVseW4gQ2FiYWh1ZyBEb21pbmdvXCIsXCJjb2xsYWJTaGFyZVwiOjQwLFwiY29sbGFiVHlwZVwiOlwiY3VyYXRvclwiLFwibG9ja2VkXCI6ZmFsc2V9XSxcImRvY3VtZW50c1wiOntcIm1vZGVsRG9jdW1lbnRzXCI6W10sXCJwcm9wZXJ0eURvY3VtZW50c1wiOltdfSxcImlzQXR0YWNoZWRSZWxlYXNlXCI6ZmFsc2UsXCJyZXZpZXdSZXF1aXJlZFwiOmZhbHNlLFwiY3VyYXRpb25TdGF0dXNcIjpcImluY29tcGxldGVcIixcInJlamVjdGVkUmVhc29uXCI6W10sXCJub3RlVG9Pd25lclwiOm51bGx9LHtcImZvb3RhZ2VJZFwiOlwiMzU3OGVjYjAtY2EyZS00NDYwLTkzZGYtZDdmZThhYmFjMjc1XCIsXCJtZW1iZXJJZFwiOlwiNWFmZDYxNjMtYTgyYS00MDc5LThlM2ItNTkyYzM0OWFlNzJkXCIsXCJ1cGxvYWRlZEJ5XCI6XCI1YWZkNjE2My1hODJhLTQwNzktOGUzYi01OTJjMzQ5YWU3MmRcIixcInByb2plY3RJZFwiOm51bGwsXCJvcmlnaW5hbEZpbGVOYW1lXCI6XCIyMDE5LTAzLTE1dGggQ2VidSBUcmlwIERheSAxIC0gSXNsYW5kLCBTYXJkaW5lcywgVHVydGxlLCBLYXdhc2FuIGZhbGxzIGNhbnlvbmVlcmluZyAoNEsgNTBmcHMgR29Qcm8pIC0gX1YxLTAwNDcubXA0XCIsXCJjcmVhdGVkQXRcIjpcIjIwMjAtMDEtMDJUMDU6MjE6NTcuMDAwWlwiLFwib3duZXJzaGlwXCI6NjAsXCJpc093bmVyXCI6dHJ1ZSxcImFwcHJvdmFsU3RhdHVzXCI6XCJhcHByb3ZlZFwiLFwiYmF0Y2hOYW1lXCI6XCJcIixcImNhblN1Ym1pdFwiOmZhbHNlLFwiZGVzY3JpcHRpb25cIjpudWxsLFwia2V5d29yZHNcIjpcIlwiLFwic3VibWlzc2lvbkRhdGVcIjpudWxsLFwib3duZXJGdWxsTmFtZVwiOlwiTWljaGFlbCBLdWJsZXJcIixcInRyYW5zaXRpb25TdGF0dXNcIjpcIlVwbG9hZGVkXCIsXCJyZXZpZXdTdGF0dXNcIjpudWxsLFwiY2FuRGVsZXRlXCI6dHJ1ZSxcInNoYXJlcnNcIjpbXSxcImVkaXRvcmlhbFwiOmZhbHNlLFwiZWRpdG9yaWFsQ2l0eVwiOm51bGwsXCJlZGl0b3JpYWxTdGF0ZVwiOm51bGwsXCJlZGl0b3JpYWxDb3VudHJ5XCI6bnVsbCxcImVkaXRvcmlhbFRleHRcIjpudWxsLFwiY2F0ZWdvcnlcIjpudWxsLFwiYmF0Y2hJZFwiOm51bGwsXCJjYW5QcmV2aWV3XCI6dHJ1ZSxcImNhbkFzc2lnbkN1cmF0b3JcIjpmYWxzZSxcImN1cmF0b3JzXCI6W3tcImlkXCI6XCIxYWQ2ZTg4Mi00MTQ2LTRhZjUtOGQzMy00NTg2YzZkZWI2MGJcIixcImZ1bGxOYW1lXCI6XCJKb3ZlbHluIENhYmFodWcgRG9taW5nb1wiLFwiY29sbGFiU2hhcmVcIjo0MCxcImNvbGxhYlR5cGVcIjpcImN1cmF0b3JcIixcImxvY2tlZFwiOmZhbHNlfV0sXCJkb2N1bWVudHNcIjp7XCJtb2RlbERvY3VtZW50c1wiOltdLFwicHJvcGVydHlEb2N1bWVudHNcIjpbXX0sXCJpc0F0dGFjaGVkUmVsZWFzZVwiOmZhbHNlLFwicmV2aWV3UmVxdWlyZWRcIjpmYWxzZSxcImN1cmF0aW9uU3RhdHVzXCI6XCJpbmNvbXBsZXRlXCIsXCJyZWplY3RlZFJlYXNvblwiOltdLFwibm90ZVRvT3duZXJcIjpudWxsfSx7XCJmb290YWdlSWRcIjpcIjJmM2I0MzY5LTZiYTAtNDc4YS04YjliLTExNDdkNTU1YzhjZlwiLFwibWVtYmVySWRcIjpcIjVhZmQ2MTYzLWE4MmEtNDA3OS04ZTNiLTU5MmMzNDlhZTcyZFwiLFwidXBsb2FkZWRCeVwiOlwiNWFmZDYxNjMtYTgyYS00MDc5LThlM2ItNTkyYzM0OWFlNzJkXCIsXCJwcm9qZWN0SWRcIjpudWxsLFwib3JpZ2luYWxGaWxlTmFtZVwiOlwiMjAxOS0wMy0xNXRoIENlYnUgVHJpcCBEYXkgMSAtIElzbGFuZCwgU2FyZGluZXMsIFR1cnRsZSwgS2F3YXNhbiBmYWxscyBjYW55b25lZXJpbmcgKDRLIDUwZnBzIEdvUHJvKSAtIF9WMS0wMDQyLm1wNFwiLFwiY3JlYXRlZEF0XCI6XCIyMDIwLTAxLTAyVDA1OjE2OjAzLjAwMFpcIixcIm93bmVyc2hpcFwiOjYwLFwiaXNPd25lclwiOnRydWUsXCJhcHByb3ZhbFN0YXR1c1wiOlwiYXBwcm92ZWRcIixcImJhdGNoTmFtZVwiOlwiXCIsXCJjYW5TdWJtaXRcIjpmYWxzZSxcImRlc2NyaXB0aW9uXCI6bnVsbCxcImtleXdvcmRzXCI6XCJcIixcInN1Ym1pc3Npb25EYXRlXCI6bnVsbCxcIm93bmVyRnVsbE5hbWVcIjpcIk1pY2hhZWwgS3VibGVyXCIsXCJ0cmFuc2l0aW9uU3RhdHVzXCI6XCJVcGxvYWRlZFwiLFwicmV2aWV3U3RhdHVzXCI6bnVsbCxcImNhbkRlbGV0ZVwiOnRydWUsXCJzaGFyZXJzXCI6W10sXCJlZGl0b3JpYWxcIjpmYWxzZSxcImVkaXRvcmlhbENpdHlcIjpudWxsLFwiZWRpdG9yaWFsU3RhdGVcIjpudWxsLFwiZWRpdG9yaWFsQ291bnRyeVwiOm51bGwsXCJlZGl0b3JpYWxUZXh0XCI6bnVsbCxcImNhdGVnb3J5XCI6bnVsbCxcImJhdGNoSWRcIjpudWxsLFwiY2FuUHJldmlld1wiOnRydWUsXCJjYW5Bc3NpZ25DdXJhdG9yXCI6ZmFsc2UsXCJjdXJhdG9yc1wiOlt7XCJpZFwiOlwiMWFkNmU4ODItNDE0Ni00YWY1LThkMzMtNDU4NmM2ZGViNjBiXCIsXCJmdWxsTmFtZVwiOlwiSm92ZWx5biBDYWJhaHVnIERvbWluZ29cIixcImNvbGxhYlNoYXJlXCI6NDAsXCJjb2xsYWJUeXBlXCI6XCJjdXJhdG9yXCIsXCJsb2NrZWRcIjpmYWxzZX1dLFwiZG9jdW1lbnRzXCI6e1wibW9kZWxEb2N1bWVudHNcIjpbXSxcInByb3BlcnR5RG9jdW1lbnRzXCI6W119LFwiaXNBdHRhY2hlZFJlbGVhc2VcIjpmYWxzZSxcInJldmlld1JlcXVpcmVkXCI6ZmFsc2UsXCJjdXJhdGlvblN0YXR1c1wiOlwiaW5jb21wbGV0ZVwiLFwicmVqZWN0ZWRSZWFzb25cIjpbXSxcIm5vdGVUb093bmVyXCI6bnVsbH0se1wiZm9vdGFnZUlkXCI6XCIwZTVmNzBkNy1hMzc4LTQ5MmMtOGIxZi05YjgwZmQxNTJkMzRcIixcIm1lbWJlcklkXCI6XCI1YWZkNjE2My1hODJhLTQwNzktOGUzYi01OTJjMzQ5YWU3MmRcIixcInVwbG9hZGVkQnlcIjpcIjVhZmQ2MTYzLWE4MmEtNDA3OS04ZTNiLTU5MmMzNDlhZTcyZFwiLFwicHJvamVjdElkXCI6bnVsbCxcIm9yaWdpbmFsRmlsZU5hbWVcIjpcIjIwMTktMDMtMTV0aCBDZWJ1IFRyaXAgRGF5IDEgLSBJc2xhbmQsIFNhcmRpbmVzLCBUdXJ0bGUsIEthd2FzYW4gZmFsbHMgY2FueW9uZWVyaW5nICg0SyA1MGZwcyBHb1BybykgLSBfVjEtMDA0NS5tcDRcIixcImNyZWF0ZWRBdFwiOlwiMjAyMC0wMS0wMlQwNToxMzo0My4wMDBaXCIsXCJvd25lcnNoaXBcIjo2MCxcImlzT3duZXJcIjp0cnVlLFwiYXBwcm92YWxTdGF0dXNcIjpcImFwcHJvdmVkXCIsXCJiYXRjaE5hbWVcIjpcIlwiLFwiY2FuU3VibWl0XCI6ZmFsc2UsXCJkZXNjcmlwdGlvblwiOm51bGwsXCJrZXl3b3Jkc1wiOlwiXCIsXCJzdWJtaXNzaW9uRGF0ZVwiOm51bGwsXCJvd25lckZ1bGxOYW1lXCI6XCJNaWNoYWVsIEt1YmxlclwiLFwidHJhbnNpdGlvblN0YXR1c1wiOlwiVXBsb2FkZWRcIixcInJldmlld1N0YXR1c1wiOm51bGwsXCJjYW5EZWxldGVcIjp0cnVlLFwic2hhcmVyc1wiOltdLFwiZWRpdG9yaWFsXCI6ZmFsc2UsXCJlZGl0b3JpYWxDaXR5XCI6bnVsbCxcImVkaXRvcmlhbFN0YXRlXCI6bnVsbCxcImVkaXRvcmlhbENvdW50cnlcIjpudWxsLFwiZWRpdG9yaWFsVGV4dFwiOm51bGwsXCJjYXRlZ29yeVwiOm51bGwsXCJiYXRjaElkXCI6bnVsbCxcImNhblByZXZpZXdcIjp0cnVlLFwiY2FuQXNzaWduQ3VyYXRvclwiOmZhbHNlLFwiY3VyYXRvcnNcIjpbe1wiaWRcIjpcIjFhZDZlODgyLTQxNDYtNGFmNS04ZDMzLTQ1ODZjNmRlYjYwYlwiLFwiZnVsbE5hbWVcIjpcIkpvdmVseW4gQ2FiYWh1ZyBEb21pbmdvXCIsXCJjb2xsYWJTaGFyZVwiOjQwLFwiY29sbGFiVHlwZVwiOlwiY3VyYXRvclwiLFwibG9ja2VkXCI6ZmFsc2V9XSxcImRvY3VtZW50c1wiOntcIm1vZGVsRG9jdW1lbnRzXCI6W10sXCJwcm9wZXJ0eURvY3VtZW50c1wiOltdfSxcImlzQXR0YWNoZWRSZWxlYXNlXCI6ZmFsc2UsXCJyZXZpZXdSZXF1aXJlZFwiOmZhbHNlLFwiY3VyYXRpb25TdGF0dXNcIjpcImluY29tcGxldGVcIixcInJlamVjdGVkUmVhc29uXCI6W10sXCJub3RlVG9Pd25lclwiOm51bGx9LHtcImZvb3RhZ2VJZFwiOlwiYzdiMWRlMzktYTY0ZS00YzQxLTkxY2YtZjZhMmQ5NmQxMzAxXCIsXCJtZW1iZXJJZFwiOlwiNWFmZDYxNjMtYTgyYS00MDc5LThlM2ItNTkyYzM0OWFlNzJkXCIsXCJ1cGxvYWRlZEJ5XCI6XCI1YWZkNjE2My1hODJhLTQwNzktOGUzYi01OTJjMzQ5YWU3MmRcIixcInByb2plY3RJZFwiOm51bGwsXCJvcmlnaW5hbEZpbGVOYW1lXCI6XCIyMDE5LTAzLTE1dGggQ2VidSBUcmlwIERheSAxIC0gSXNsYW5kLCBTYXJkaW5lcywgVHVydGxlLCBLYXdhc2FuIGZhbGxzIGNhbnlvbmVlcmluZyAoNEsgNTBmcHMgR29Qcm8pIC0gX1YxLTAwNDQubXA0XCIsXCJjcmVhdGVkQXRcIjpcIjIwMjAtMDEtMDJUMDU6MDc6MjcuMDAwWlwiLFwib3duZXJzaGlwXCI6NjAsXCJpc093bmVyXCI6dHJ1ZSxcImFwcHJvdmFsU3RhdHVzXCI6XCJhcHByb3ZlZFwiLFwiYmF0Y2hOYW1lXCI6XCJcIixcImNhblN1Ym1pdFwiOmZhbHNlLFwiZGVzY3JpcHRpb25cIjpudWxsLFwia2V5d29yZHNcIjpcIlwiLFwic3VibWlzc2lvbkRhdGVcIjpudWxsLFwib3duZXJGdWxsTmFtZVwiOlwiTWljaGFlbCBLdWJsZXJcIixcInRyYW5zaXRpb25TdGF0dXNcIjpcIlVwbG9hZGVkXCIsXCJyZXZpZXdTdGF0dXNcIjpudWxsLFwiY2FuRGVsZXRlXCI6dHJ1ZSxcInNoYXJlcnNcIjpbXSxcImVkaXRvcmlhbFwiOmZhbHNlLFwiZWRpdG9yaWFsQ2l0eVwiOm51bGwsXCJlZGl0b3JpYWxTdGF0ZVwiOm51bGwsXCJlZGl0b3JpYWxDb3VudHJ5XCI6bnVsbCxcImVkaXRvcmlhbFRleHRcIjpudWxsLFwiY2F0ZWdvcnlcIjpudWxsLFwiYmF0Y2hJZFwiOm51bGwsXCJjYW5QcmV2aWV3XCI6dHJ1ZSxcImNhbkFzc2lnbkN1cmF0b3JcIjpmYWxzZSxcImN1cmF0b3JzXCI6W3tcImlkXCI6XCIxYWQ2ZTg4Mi00MTQ2LTRhZjUtOGQzMy00NTg2YzZkZWI2MGJcIixcImZ1bGxOYW1lXCI6XCJKb3ZlbHluIENhYmFodWcgRG9taW5nb1wiLFwiY29sbGFiU2hhcmVcIjo0MCxcImNvbGxhYlR5cGVcIjpcImN1cmF0b3JcIixcImxvY2tlZFwiOmZhbHNlfV0sXCJkb2N1bWVudHNcIjp7XCJtb2RlbERvY3VtZW50c1wiOltdLFwicHJvcGVydHlEb2N1bWVudHNcIjpbXX0sXCJpc0F0dGFjaGVkUmVsZWFzZVwiOmZhbHNlLFwicmV2aWV3UmVxdWlyZWRcIjpmYWxzZSxcImN1cmF0aW9uU3RhdHVzXCI6XCJpbmNvbXBsZXRlXCIsXCJyZWplY3RlZFJlYXNvblwiOltdLFwibm90ZVRvT3duZXJcIjpudWxsfV0sXCJwYWdlSW5mb1wiOntcInRvdGFsUmVjb3Jkc1wiOjExNSxcInRvdGFsRGlzcGxheVJlY29yZHNcIjoxMH19fVxuICAgIH1cblxuICAgIGFzeW5jIGdldEFsbEZvb3RhZ2UoKSB7XG5cbiAgICAgICAgbGV0IGJsYWNrQm94UGx1c0Zvb3RhZ2UgPSB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5nZXRDb3VudEluVGFicygpLnRoZW4oKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRyaWJ1dGVQcm9taXNlID0gdGhpcy5nYXRoZXJGb290YWdlRGF0YSgnY29udHJpYnV0ZScpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tCb3hQbHVzRm9vdGFnZS5jb250cmlidXRlID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhgVGhlIGNvbnRyaWJ1ZSBmb290YWdlIGNvbnRhaW5zICR7ZGF0YS5sZW5ndGh9IGVudHJpZXNgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgY3VyYXRpb25Qcm9taXNlID0gdGhpcy5nYXRoZXJGb290YWdlRGF0YSgnY3VyYXRpb24nKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsYWNrQm94UGx1c0Zvb3RhZ2UuY3VyYXRpb24gPSBkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRQcm9taXNlID0gdGhpcy5nYXRoZXJGb290YWdlRGF0YSgnY29udGVudCcpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tCb3hQbHVzRm9vdGFnZS5jb250ZW50ID0gZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhbGwgY29tcGxldGVkXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW2NvbnRyaWJ1dGVQcm9taXNlLCBjdXJhdGlvblByb21pc2UsIGNvbnRlbnRQcm9taXNlXSkudGhlbigoZGF0YSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoJ1RoZSBmb290YWdlcyBkYXRhIGlzOiAnLCBibGFja0JveFBsdXNGb290YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKGA8cD5BbGwgRm9vdGFnZSBkYXRhIGxvYWRlZDwvcD5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShibGFja0JveFBsdXNGb290YWdlKTtcblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBhc3luYyBnZXRBbGxGaW5hbmNpYWxzKCkge1xuXG4gICAgICAgIGxldCBibGFja0JveFBsdXNGaW5hbmNpYWxzID0ge307XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzTG9hZGluZyhgZmluYW5jaWFsIGRhdGFgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgbGV0IGZpbmFuY2lhbFN1bW1hcnlJbmZvUHJvbWlzZSA9IHRoaXMuZ2V0RmluYW5jaWFsU3VtbWFyeUluZm8oKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgYmxhY2tCb3hQbHVzRmluYW5jaWFscy5maW5hbmNpYWxTdW1tYXJ5SW5mbyA9IGRhdGE7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhgVGhlIGZpbmFuY2lhbFN1bW1hcnlJbmZvIGNvbnRhaW5zICR7ZGF0YS5sZW5ndGh9IGVudHJpZXNgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZXQgZmluYW5jaWFsRWFybmluZ3NTdW1tYXJ5UHJvbWlzZSA9IHRoaXMuZ2V0RmluYW5jaWFsRWFybmluZ3NTdW1tYXJ5KCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGJsYWNrQm94UGx1c0ZpbmFuY2lhbHMuZmluYW5jaWFsRWFybmluZ3NTdW1tYXJ5ID0gZGF0YTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmRlYnVnKGBUaGUgZ2V0RmluYW5jaWFsRWFybmluZ3NTdW1tYXJ5IGNvbnRhaW5zICR7ZGF0YS5sZW5ndGh9IGVudHJpZXNgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGdldFVucGFpZEVhcm5pbmdzUHJvbWlzZSA9IHRoaXMuZ2V0VW5wYWlkRWFybmluZ3MoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgYmxhY2tCb3hQbHVzRmluYW5jaWFscy51bnBhaWRFYXJuaW5ncyA9IGRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBnZXRGaW5hbmNpYWxQYXltZW50SGlzdG9yeVByb21pc2UgPSB0aGlzLmdldEZpbmFuY2lhbFBheW1lbnRIaXN0b3J5KCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGJsYWNrQm94UGx1c0ZpbmFuY2lhbHMuZmluYW5jaWFsUGF5bWVudEhpc3RvcnkgPSBkYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZ2V0RmluYW5jaWFsVG90YWxFYXJuaW5nc1JlcG9ydFByb21pc2UgPSB0aGlzLmdldEZpbmFuY2lhbFRvdGFsRWFybmluZ3NSZXBvcnQoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgYmxhY2tCb3hQbHVzRmluYW5jaWFscy5maW5hbmNpYWxUb3RhbEVhcm5pbmdzUmVwb3J0ID0gZGF0YTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBXaGVuIGFsbCBjb21wbGV0ZWRcbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtmaW5hbmNpYWxTdW1tYXJ5SW5mb1Byb21pc2UsIGZpbmFuY2lhbEVhcm5pbmdzU3VtbWFyeVByb21pc2UsIGdldFVucGFpZEVhcm5pbmdzUHJvbWlzZSwgZ2V0RmluYW5jaWFsUGF5bWVudEhpc3RvcnlQcm9taXNlLCBnZXRGaW5hbmNpYWxUb3RhbEVhcm5pbmdzUmVwb3J0UHJvbWlzZV0pLnRoZW4oKGRhdGEpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1RoZSBibGFja0JveFBsdXNGaW5hbmNpYWxzIGRhdGEgY2hhciBsZW5ndGggaXMgJywgSlNPTi5zdHJpbmdpZnkoYmxhY2tCb3hQbHVzRmluYW5jaWFscykubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UoYDxwPkFsbCBGaW5hbmNpYWwgZGF0YSBsb2FkZWQ8L3A+YCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShibGFja0JveFBsdXNGaW5hbmNpYWxzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Knx1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZpbmFuY2lhbFN1bW1hcnlJbmZvKCkge1xuICAgICAgICAvLyBVUkwgZXhhbXBsZSBodHRwczovL3BvcnRhbC5ibGFja2JveC5nbG9iYWwvYXBpL21lbWJlci81YWZkNjE2My1hODJhLTQwNzktOGUzYi01OTJjMzQ5YWU3MmQvc3VtbWFyeUluZm9cbiAgICAgICAgLy8gRXhhbXBsZSByZXNwb25zZSA9IHtcIlJldmVudWVUb0RhdGVcIjoyMDQuMjUsXCJSZXZlbnVlVGhpc01vbnRoXCI6MCxcIlJlZmVycmFsVG9EYXRlXCI6MS4wOCxcIlJlZmVycmFsVGhpc01vbnRoXCI6MCxcIk1lbWJlclN0YXR1c1wiOlwiUmVndWxhclwiLFwiTWVtYmVyc2hpcER1ZVwiOlwiTi9BXCIsXCJPdXRzdGFuZGluZ0NvbGxhYm9yYXRpdmVJbnZpdGF0aW9uc1wiOjAsXCJBdmFpbGFibGVPcHBvcnR1bml0aWVzXCI6MSxcIlJlZmVycmFsTWVtYmVyc1wiOjF9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxBUEkoYC9zdW1tYXJ5SW5mb2ApO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEZpbmFuY2lhbEVhcm5pbmdzU3VtbWFyeSh0b0RhdGUgPSBudWxsLCBmcm9tRGF0ZSA9ICcyMDE3LTAxLTAxJTIwMDA6MDA6MDAnKSB7XG4gICAgICAgIHRvRGF0ZSA9IHRvRGF0ZSB8fCB0aGlzLmdldEZvcm1hdHRlZERhdGUoXCJ7WX0te019LXtEfVwiKSArICclMjAyMzo1OTo1OSc7IC8vIFVudGlsIHRoZSBlbmQgb2YgdG9kYXlcbiAgICAgICAgLy8gRXhhbXBsZSBVUkwgaHR0cHM6Ly9wb3J0YWwuYmxhY2tib3guZ2xvYmFsL2FwaS9tZW1iZXIvNWFmZDYxNjMtYTgyYS00MDc5LThlM2ItNTkyYzM0OWFlNzJkL2Vhcm5pbmdTdW1tYXJ5P2Zyb21EYXRlPTIwMTktMTEtMTIlMjAwMDowMDowMCZ0b0RhdGU9MjAyMC0wMi0xMCUyMDIzOjU5OjU5XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxBUEkoYC9lYXJuaW5nU3VtbWFyeT9mcm9tRGF0ZT0ke2Zyb21EYXRlfSZ0b0RhdGU9JHt0b0RhdGV9YCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBVbnBhaWQgRWFybmluZ3MgU3VtbWFyeVxuICAgICAqXG4gICAgICogJ015IFJldmVudWUnIHBhZ2VcbiAgICAgKiBEZXNjcmliZWQgYXMgJ0EgbGlzdCBvZiBmb290YWdlIGhhdmUgYmVlbiBzb2xkIHJlY2VudGx5IGJ1dCBoYXZlIG5vdCBiZWVuIHBhaWQnXG4gICAgICpcbiAgICAgKiBZb3Ugc2hvdWxkbid0IG5lZWQgdG8gdXNlIHRoZSBwcm92aWRlZCB2YWx1ZXMgYnV0IGlmIHlvdSBkbyBpdFxuICAgICAqIGV4cGVjdHMgdG9EYXRlIGFuZCBmcm9tRGF0ZSB0byBiZSBmdWxseSBmb3JtZWQgc3RyaW5nc1xuICAgICAqIEBwYXJhbSB0b0RhdGVcbiAgICAgKiBAcGFyYW0gZnJvbURhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqfHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgYXN5bmMgZ2V0VW5wYWlkRWFybmluZ3ModG9EYXRlID0gbnVsbCwgZnJvbURhdGUgPSBudWxsKSB7XG4gICAgICAgIGxldCBkYXRlTW9udGhBZ28gPSBmcm9tRGF0ZSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICAvLyBTZXQgaXQgdG8gb25lIG1vbnRoIGFnb1xuICAgICAgICBkYXRlTW9udGhBZ28uc2V0TW9udGgoZGF0ZU1vbnRoQWdvLmdldE1vbnRoKCkgLSAxKTsgLy8gVGhpcyB3b3JrcyBmb3IgSmFudWFyeSBhcyB3ZWxsIGFuZCBnb2VzIGJhY2sgdG8gdGhlIHByZXZpb3VzIHllYXJcbiAgICAgICAgZGF0ZU1vbnRoQWdvLnNldERhdGUoMCk7IC8vIFRoaXMgd2lsbCBhY3R1YWxseSBmcm9tIHRoZSBsYXN0IGRheSBvZiB0aGUgbW9udGggYmVmb3JlLCBqdXN0IHRvIGJlIHN1cmVcblxuICAgICAgICB0b0RhdGUgPSB0b0RhdGUgfHwgdGhpcy5nZXRGb3JtYXR0ZWREYXRlKFwie1l9LXtNfS17RH1cIikgKyAnJTIwMjM6NTk6NTknOyAvLyBVbnRpbCB0aGUgZW5kIG9mIHRvZGF5XG4gICAgICAgIGZyb21EYXRlID0gZnJvbURhdGUgfHwgdGhpcy5nZXRGb3JtYXR0ZWREYXRlKFwie1l9LXtNfS17RH1cIiwgZGF0ZU1vbnRoQWdvKSArICclMjAwMDowMDowMCc7IC8vIFVudGlsIHRoZSBlbmQgb2YgdG9kYXlcbiAgICAgICAgLy8gZS5nIGh0dHBzOi8vcG9ydGFsLmJsYWNrYm94Lmdsb2JhbC9hcGkvbWVtYmVyLzVhZmQ2MTYzLWE4MmEtNDA3OS04ZTNiLTU5MmMzNDlhZTcyZC9yZXZlbnVlP2Zyb21EYXRlPTIwMTktMTItMTAlMjAwMDowMDowMCZ0b0RhdGU9MjAyMC0wMi0xMCUyMDIzOjU5OjU5JmluZGV4PTEmbGltaXQ9MTBcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbEFQSShgL3JldmVudWU/ZnJvbURhdGU9JHtmcm9tRGF0ZX0mdG9EYXRlPSR7dG9EYXRlfSZpbmRleD0xJmxpbWl0PTUwMGApO1xuICAgICAgICAvLyBFeGFtcGxlIHJlc3BvbnNlXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQYXltZW50IEhpc3RvcnkgKG1vbnRocylcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGRlYWxzIHdpdGggdGhlIHBhZ2luYXRpb25cbiAgICAgKiBBbHNvIG5vdGUgdGhhdCB0aGUgXCJ0b3RhbEVhcm5pbmdcIiBmaWVsZCBpcyBsb3N0LFxuICAgICAqIGJ1dCBwZW9wbGUgdXNpbmcgdGhpcyBhcyBDU1YgY2FuIHJlLWNyZWF0ZWQgdGhhdCB0aGVtc2VsdmVzIHZlcnkgZWFzaWx5IGFuZFxuICAgICAqIGl0J3Mgb24gYSBwZXIgcmVxdWVzdCBiYXNpcyBzbyB3aWxsIGJlIHdyb25nIGlmIHRoZXJlJ3MgbXVsdGlwbGUgQVBJIGNhbGxzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqfHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmluYW5jaWFsUGF5bWVudEhpc3RvcnkoKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vcG9ydGFsLmJsYWNrYm94Lmdsb2JhbC9hcGkvbWVtYmVyLzVhZmQ2MTYzLWE4MmEtNDA3OS04ZTNiLTU5MmMzNDlhZTcyZC9wYXltZW50SGlzdG9yeT9pbmRleD0xJmxpbWl0PTEwXG4gICAgICAgIC8vIEV4YW1wbGUgYXBpIHJlc3BvbnNlOiB7XCJsaXN0XCI6W3tcInBheW1lbnREYXRlXCI6XCIyMDIwLTAxLTE5VDIwOjQ4OjAwLjAwMFpcIixcImdyb3NzUmV2XCI6NjUuMTMsXCJuZXRQYXltZW50XCI6NjQuMTQsXCJwYXltZW50TWV0aG9kXCI6XCJQYXlQYWxcIixcInRyYW5zZmVyRmVlXCI6MS4zMSxcImNvbW1pc3Npb25cIjowLjMzfSx7XCJwYXltZW50RGF0ZVwiOlwiMjAxOS0xMi0yMFQxNToxMDoxNC4wMDBaXCIsXCJncm9zc1JldlwiOjkzLjUyLFwibmV0UGF5bWVudFwiOjkyLjEyLFwicGF5bWVudE1ldGhvZFwiOlwiUGF5UGFsXCIsXCJ0cmFuc2ZlckZlZVwiOjEuODgsXCJjb21taXNzaW9uXCI6MC40OH0se1wicGF5bWVudERhdGVcIjpcIjIwMTktMTEtMjBUMTU6NDU6MDIuMDAwWlwiLFwiZ3Jvc3NSZXZcIjoxNy4xNCxcIm5ldFBheW1lbnRcIjoxNi45MSxcInBheW1lbnRNZXRob2RcIjpcIlBheVBhbFwiLFwidHJhbnNmZXJGZWVcIjowLjM0LFwiY29tbWlzc2lvblwiOjAuMTF9LHtcInBheW1lbnREYXRlXCI6XCIyMDE5LTA5LTIwVDAzOjM4OjQ0LjAwMFpcIixcImdyb3NzUmV2XCI6OC45MixcIm5ldFBheW1lbnRcIjo4LjgxLFwicGF5bWVudE1ldGhvZFwiOlwiUGF5UGFsXCIsXCJ0cmFuc2ZlckZlZVwiOjAuMTgsXCJjb21taXNzaW9uXCI6MC4wN31dLFwicGFnZUluZm9cIjp7XCJ0b3RhbFJlY29yZHNcIjo0LFwidG90YWxEaXNwbGF5UmVjb3Jkc1wiOjR9fVxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsUGFnaW5hdGVkQVBJKGAvcGF5bWVudEhpc3Rvcnk/YCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUb3RhbCBFYXJuaW5ncyBSZXBvcnQgKEluZGl2aWR1YWwgc2FsZXMpXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBkZWFscyB3aXRoIHRoZSBwYWdpbmF0aW9uIGFuZCBkYXRlIHJhbmdlc1xuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Knx1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZpbmFuY2lhbFRvdGFsRWFybmluZ3NSZXBvcnQodG9EYXRlID0gbnVsbCwgZnJvbURhdGUgPSAnMjAxNy0wMS0wMSUyMDAwOjAwOjAwJykge1xuICAgICAgICAvLyBUb3RhbCBFYXJuaW5ncyBSZXBvcnQgKEluZGl2aWR1YWwgc2FsZXMpXG4gICAgICAgIC8vIGh0dHBzOi8vcG9ydGFsLmJsYWNrYm94Lmdsb2JhbC9hcGkvbWVtYmVyLzVhZmQ2MTYzLWE4MmEtNDA3OS04ZTNiLTU5MmMzNDlhZTcyZC9lYXJuaW5nc1JlcG9ydD9mcm9tRGF0ZT0yMDE5LTEyLTEwJTIwMDA6MDA6MDAmdG9EYXRlPTIwMjAtMDItMTAlMjAyMzo1OTo1OSZpbmRleD0xJmxpbWl0PTEwXG4gICAgICAgIC8vIEV4YW1wbGUge1wiaXRlbXNcIjpbe1wiZm9vdGFnZUlkXCI6XCI1NGU0MDQzZi0zOWViLTRjZWQtYTY2My1lMTA3NDVhYzIyNjBcIixcImZvb3RhZ2VOYW1lXCI6XCIyMDE5LTA1LTE2dGggT2FzaXMgT25lIEZsaWdodCAjMiAtIDE0IFN1bnNldCBkZXNjZW5kaW5nLS5tcDRcIixcImVhcm5pbmdcIjoxOC41NSxcInRvdGFsRG93bmxvYWRzXCI6MSxcImRhdGVTb2xkXCI6XCIyMDIwLTAxLTIzVDAwOjAwOjAwLjAwMFpcIn0se1wiZm9vdGFnZUlkXCI6XCI3NGVhYjc2Yi1hNGI1LTRlNjktYTdlOC1hZmU3N2IxODJiMWVcIixcImZvb3RhZ2VOYW1lXCI6XCIyMDE5LTA0LTIxc3QgTWFuaWxhIEJheSBhbmQgU3RhckNpdHkgVGhlbWUgUGFyayAtIF9WMS0wMDIyLm1wNFwiLFwiZWFybmluZ1wiOjY1LjQ2LFwidG90YWxEb3dubG9hZHNcIjoxLFwiZGF0ZVNvbGRcIjpcIjIwMTktMTItMThUMDA6MDA6MDAuMDAwWlwifV0sXCJ0b3RhbEVhcm5pbmdcIjo4NC4wMSxcInBhZ2VJbmZvXCI6e1widG90YWxSZWNvcmRzXCI6MixcInRvdGFsRGlzcGxheVJlY29yZHNcIjoyfX1cblxuICAgICAgICB0b0RhdGUgPSB0b0RhdGUgfHwgdGhpcy5nZXRGb3JtYXR0ZWREYXRlKFwie1l9LXtNfS17RH1cIikgKyAnJTIwMjM6NTk6NTknOyAvLyBVbnRpbCB0aGUgZW5kIG9mIHRvZGF5XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxQYWdpbmF0ZWRBUEkoYC9lYXJuaW5nc1JlcG9ydD9mcm9tRGF0ZT0ke2Zyb21EYXRlfSZ0b0RhdGU9JHt0b0RhdGV9JmApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTWFpbmx5IGZvciBnZXR0aW5nIHRoZSBlbWFpbCBhZGRyZXNzIG9mIGN1cmF0aW9uIG93bmVycywgdGhlaXIgbmFtZXMgYXJlIGFscmVhZHkgb3V0cHV0IGluIHRoZSBmb290YWdlIGpzb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqfHVuZGVmaW5lZD59XG4gICAgICpcbiAgICAgKiBOQjogVGhpcyBpc24ndCB1c2VkIGF0IHRoZSBtb21lbnQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3VyYXRpb25Pd25lcnMoKSB7XG4gICAgICAgIC8vIGUuZyBodHRwczovL3BvcnRhbC5ibGFja2JveC5nbG9iYWwvYXBpL21lbWJlci81YWZkNjE2My1hODJhLTQwNzktOGUzYi01OTJjMzQ5YWU3MmQvY3VyYXRpb25Gb290YWdlL2dldEN1cmF0aW9uT3duZXJzXG4gICAgICAgIC8vIEV4YW1wbGUgcmVzcG9uc2U6IHtcInN1Y2Nlc3NcIjp0cnVlLFwiZGF0YVwiOlt7XCJuYW1lXCI6XCJNaWNoYWVsIEt1YmxlclwiLFwidmFsdWVcIjpcImJsYWNrYm94UGx1cytleGFtcGxlQGdyZXlwaG9lbml4LmJpelwifV19XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxBUEkoYGN1cmF0aW9uRm9vdGFnZS9nZXRDdXJhdGlvbk93bmVyc2ApO1xuICAgIH1cblxuXG4gICAgZ2V0IHVybEJhc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnVybEJhc2VDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXJsQmFzZUNhY2hlO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBsZXQgbWVtYmVySWQgPSB0aGlzLmdldE1lbWJlcklkKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cmxCYXNlQ2FjaGUgPSBgaHR0cHM6Ly9wb3J0YWwuYmxhY2tib3guZ2xvYmFsL2FwaS9tZW1iZXIvJHttZW1iZXJJZH1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgY2FsbEFQSSh1cmksIG1ldGhvZCA9ICdHRVQnKSB7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0dXNMb2FkaW5nKGBNYWtpbmcgYSBjYWxsIHRvICR7dXJpfWApXG4gICAgICAgIGxldCBoZWFkZXJzID0gdGhpcy5nZXRBUElDYWxsSGVhZGVycyhtZXRob2QpO1xuICAgICAgICBsZXQgdXJsID0gYCR7dGhpcy51cmxCYXNlfSR7dXJpfWA7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzRXJyb3IoYHRyeWluZyB0byBtYWtlIGFuIEFQSSBjYWxsIHRvICR7dXJpfWApO1xuICAgICAgICAgICAgdGhpcy5hZGRGbGFzaE1lc3NhZ2UoYEVycm9yIHRyeWluZyB0byBtYWtlIGFuIEFQSSBjYWxsIHRvICR7dXJpfWApO1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGBObyBPSyByZXNwb25zZSBmcm9tIHRoZSBBUEkuIEdvdCB0aGUgSFRUUCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9IHdoZW4gZG9pbmcgYSAke21ldGhvZH0gcmVxdWVzdCB0byAke3VybH1gO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3JNZXNzYWdlLCB7dXJsLCB1cmksIHJlc3BvbnNlLCBoZWFkZXJzfSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgUGFnaW5hdGVkIEFQSVxuICAgICAqXG4gICAgICogVGhpcyBkZWFscyB3aXRoIHRoZSBwYWdpbmF0aW9uLCBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBOQjogVGhlID8gb3IgJiBsYXN0IGNoYXIgb2YgdGhlIHVyaSBzaG91bGQgYmUgcHJvdmlkZWQgYnkgdGhlIGNhbGxpbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB1cmlcbiAgICAgKiBAcGFyYW0gbWV0aG9kXG4gICAgICogQHBhcmFtIGxpbWl0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8W10+fVxuICAgICAqL1xuICAgIGFzeW5jIGNhbGxQYWdpbmF0ZWRBUEkodXJpLCBtZXRob2QgPSAnR0VUJywgbGltaXQgPSAyMDApIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMTtcbiAgICAgICAgbGV0IHBhZ2UgPSAxO1xuICAgICAgICB0aGlzLnNldFN0YXR1c0xvYWRpbmcoYGl0ZW1zIGZyb20gJHt1cml9LiBQYWdlICR7cGFnZX1gKTtcbiAgICAgICAgbGV0IHBhZ2luYXRlZFVyaSA9IGAke3VyaX1pbmRleD0ke2luZGV4fSZsaW1pdD0ke2xpbWl0fWA7IC8vIEFkZCBwYWdpbmF0aW9uIHF1ZXJ5XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbEFQSShwYWdpbmF0ZWRVcmksIG1ldGhvZCk7XG4gICAgICAgIC8vIGNvbnNvbGUuZGVidWcoYFRoZSBmaXJzdCBwYWdpbmF0ZWQgY2FsbCB0byAke3VyaX1gLCB7dXJpLCBwYWdpbmF0ZWRVcmksIG1ldGhvZCwgcmVzcG9uc2V9KTtcbiAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgIGxldCBwYWdlc05lZWRlZCA9IDE7XG4gICAgICAgIGxldCB0b3RhbFJlY29yZHMgPSAwO1xuICAgICAgICAvLyBBZGQgdGhlIGl0ZW1zIChvciBsaXN0IGVudHJpZXMsIGJlY2F1c2UgdGhlaXIgQVBJIGlzbid0IGNvbnNpc3RlbnQpXG4gICAgICAgIGlmIChyZXNwb25zZS5pdGVtcykge1xuICAgICAgICAgICAgaXRlbXMgPSBbXS5jb25jYXQoaXRlbXMsIHJlc3BvbnNlLml0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2UubGlzdCkge1xuICAgICAgICAgICAgaXRlbXMgPSBbXS5jb25jYXQoaXRlbXMsIHJlc3BvbnNlLmxpc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLnBhZ2VJbmZvICYmIHJlc3BvbnNlLnBhZ2VJbmZvLnRvdGFsUmVjb3Jkcykge1xuICAgICAgICAgICAgdG90YWxSZWNvcmRzID0gcmVzcG9uc2UucGFnZUluZm8udG90YWxSZWNvcmRzO1xuICAgICAgICAgICAgcGFnZXNOZWVkZWQgPSBNYXRoLmNlaWwodG90YWxSZWNvcmRzIC8gbGltaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWdlc05lZWRlZCA8IDIpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgMSBwYWdlIG9mIHJlc3BvbnNlcyBuZWVkZWRcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgIE1ha2UgdGhlIFBhZ2luYXRlZCBDYWxscyAoaWYgbmVlZGVkKVxuICAgICAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZm9yIChwYWdlID0gMjsgcGFnZSA8PSBwYWdlc05lZWRlZDsgcGFnZSsrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAocGFnZSAtIDEpICogbGltaXQgKyAxO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXNMb2FkaW5nKGBpdGVtcyBmcm9tICR7dXJpfS4gUGFnZSAke3BhZ2V9IG9mICR7cGFnZXNOZWVkZWR9YCk7XG4gICAgICAgICAgICBwYWdpbmF0ZWRVcmkgPSBgJHt1cml9aW5kZXg9JHtpbmRleH0mbGltaXQ9JHtsaW1pdH1gOyAvLyBBZGQgcGFnaW5hdGlvbiBxdWVyeVxuICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhgQWJvdXQgdG8gbWFrZSB0aGUgJHtwYWdlfSBwYWdpbmF0ZWQgY2FsbCB0byAke3VyaX1gLCB7cGFnaW5hdGVkVXJpLCBwYWdlc05lZWRlZCwgdG90YWxSZWNvcmRzfSk7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbEFQSShwYWdpbmF0ZWRVcmksIG1ldGhvZCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGVudHJpZXNcbiAgICAgICAgICAgICAgICBpdGVtcyA9IFtdLmNvbmNhdChpdGVtcywgcmVzcG9uc2UuaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxpc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGVudHJpZXNcbiAgICAgICAgICAgICAgICBpdGVtcyA9IFtdLmNvbmNhdChpdGVtcywgcmVzcG9uc2UubGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuXG5cbiAgICAgICAgLy8gLS0gRXhhbXBsZSBwYWdlSW5mb1xuICAgICAgICAvLyBcInBhZ2VJbmZvXCI6IHtcbiAgICAgICAgLy8gICAgIFwidG90YWxSZWNvcmRzXCI6IDIsXG4gICAgICAgIC8vICAgICBcInRvdGFsRGlzcGxheVJlY29yZHNcIjogMlxuICAgICAgICAvLyB9XG4gICAgfVxuXG5cbiAgICAvLyAtLSBUZXN0aW5nIHRoZSBwYWdpbmF0aW9uIGxvZ2ljXG4gICAgLy8gZS5nIHVuaXRUZXN0YWJsZVBhZ2luYXRpb24oMTgwMiwgMjAwKTsgcmV0dXJucyAxMCBwYWdlcyB3b3J0aFxuICAgIC8vIHVuaXRUZXN0YWJsZVBhZ2luYXRpb24odG90YWxSZWNvcmRzLCBsaW1pdCkge1xuICAgIC8vICAgICBsZXQgdXJpID0gJ3Rlc3QnO1xuICAgIC8vICAgICBsZXQgaW5kZXggPSAxO1xuICAgIC8vICAgICBsZXQgcGFnZSA9IDE7XG4gICAgLy8gICAgIGxldCBwYWdlc05lZWRlZCA9IE1hdGguY2VpbCh0b3RhbFJlY29yZHMgLyBsaW1pdCk7XG4gICAgLy8gICAgIGxldCBwYWdpbmF0aW9uSW5mbyA9IFtdO1xuICAgIC8vICAgICBwYWdpbmF0aW9uSW5mby5wdXNoKHtwYWdlLCBpbmRleCwgcGFnZXNOZWVkZWQsIHBhZ2luYXRlZFVyaTogYCR7dXJpfT9pbmRleD0ke2luZGV4fSZsaW1pdD0ke2xpbWl0fWB9KTtcbiAgICAvLyAgICAgZm9yIChwYWdlID0gMjsgcGFnZSA8PSBwYWdlc05lZWRlZDsgcGFnZSsrKSB7XG4gICAgLy8gICAgICAgICBsZXQgaW5kZXggPSAocGFnZSAtIDEpICogbGltaXQgKyAxO1xuICAgIC8vICAgICAgICAgLy8gdGhpcy5zZXRTdGF0dXNMb2FkaW5nKGBpdGVtcyBmcm9tICR7dXJpfS4gUGFnZSAke3BhZ2V9IG9mICR7cGFnZXNOZWVkZWR9YCk7XG4gICAgLy8gICAgICAgICBwYWdpbmF0aW9uSW5mby5wdXNoKHtwYWdlLCBpbmRleCwgcGFnZXNOZWVkZWQsIHBhZ2luYXRlZFVyaTogYCR7dXJpfT9pbmRleD0ke2luZGV4fSZsaW1pdD0ke2xpbWl0fWB9KTsgLy8gQWRkIHBhZ2luYXRpb24gcXVlcnlcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICByZXR1cm4gcGFnaW5hdGlvbkluZm87XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSBMaW5rIEVsZW1lbnQgRG93bmxvYWRcbiAgICAgKlxuICAgICAqIEdpdmUgaXQgYW4gZXhpc3RpbmcgQSBIcmVmIGVsZW1lbnQgYW5kIHR1cm4gaXQgaW50byBhIGxpbmsgdG8gYSBmaWxlIGRvd25sb2FkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBjb250ZW50XG4gICAgICogQHBhcmFtIGZpbGVOYW1lXG4gICAgICogQHBhcmFtIGNvbnRlbnRUeXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgbWFrZUxpbmtFbGVtZW50RG93bmxvYWQoZWxlbWVudCwgY29udGVudCwgZmlsZU5hbWUsIGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIGxldCBmaWxlID0gbmV3IEJsb2IoW2NvbnRlbnRdLCB7dHlwZTogY29udGVudFR5cGV9KTtcbiAgICAgICAgZWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICAgICAgZWxlbWVudC5kb3dubG9hZCA9IGZpbGVOYW1lO1xuICAgICAgICByZXR1cm4gZWxlbWVudDsgLy8gRG9uJ3QgYWN0dWFsbHkgbmVlZCB0aGUgcmV0dXJuZWQgZWxlbWVudFxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTWFrZSBMaW5rIEVsZW1lbnQgRG93bmxvYWQgSnNvblxuICAgICAqXG4gICAgICogR2l2ZSBpdCBhIGxpbmsgZWxlbWVudCwgdGhlIGFycmF5LCBvYmplY3Qgb3Igd2hhdGV2ZXIsIHBsdXMgdGhlIGZpbGVuYW1lXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ganNvbkNvbnRlbnRcbiAgICAgKiBAcGFyYW0gZmlsZU5hbWVcbiAgICAgKi9cbiAgICBtYWtlTGlua0VsZW1lbnREb3dubG9hZEpzb24oZWxlbWVudCwganNvbkNvbnRlbnQsIGZpbGVOYW1lID0gJ0JsYWNrQm94Lmpzb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VMaW5rRWxlbWVudERvd25sb2FkKGVsZW1lbnQsIEpTT04uc3RyaW5naWZ5KGpzb25Db250ZW50LCBudWxsLCAyKSwgZmlsZU5hbWUgKyAnLmpzb24nLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2UgTGluayBFbGVtZW50IERvd25sb2FkIENTVlxuICAgICAqXG4gICAgICogR2l2ZSBpdCBhIGxpbmsgZWxlbWVudCwgdGhlIGFycmF5LCBvYmplY3Qgb3Igd2hhdGV2ZXIsIHBsdXMgdGhlIGZpbGVuYW1lXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gY3N2Q29udGVudFxuICAgICAqIEBwYXJhbSBmaWxlTmFtZVxuICAgICAqL1xuICAgIG1ha2VMaW5rRWxlbWVudERvd25sb2FkQ3N2KGVsZW1lbnQsIGNzdkNvbnRlbnQsIGZpbGVOYW1lID0gJ0JsYWNrQm94Lmpzb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VMaW5rRWxlbWVudERvd25sb2FkKGVsZW1lbnQsIGNzdkNvbnRlbnQsIGZpbGVOYW1lICsgJy5jc3YnLCAndGV4dC9jc3YnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElmIHlvdSB3YW50IGEgbmV3IEEgbGluayBlbGVtZW50XG4gICAgICogQnV0IG1vc3RseSBzbyB5b3UgY2FuIGhhdmUgaXQgYXV0b21hdGljYWxseSBjbGlja2VkIGFuZCBzdGFydCB0aGUgZG93bmxvYWRcbiAgICAgKiBAcGFyYW0gY29udGVudFxuICAgICAqIEBwYXJhbSBmaWxlTmFtZVxuICAgICAqIEBwYXJhbSBjb250ZW50VHlwZVxuICAgICAqIEBwYXJhbSBkb3dubG9hZEF1dG9tYXRpY2FsbHlcbiAgICAgKiBAcmV0dXJucyB7SFRNTEFuY2hvckVsZW1lbnR9XG4gICAgICovXG4gICAgY3JlYXRlRG93bmxvYWRMaW5rRWxlbWVudChjb250ZW50LCBmaWxlTmFtZSwgY29udGVudFR5cGUsIGRvd25sb2FkQXV0b21hdGljYWxseSA9IHRydWUpIHtcbiAgICAgICAgbGV0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgbGV0IGZpbGUgPSBuZXcgQmxvYihbY29udGVudF0sIHt0eXBlOiBjb250ZW50VHlwZX0pO1xuICAgICAgICBhLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICAgICAgICBhLmRvd25sb2FkID0gZmlsZU5hbWU7XG4gICAgICAgIGEuaW5uZXJUZXh0ID0gZmlsZU5hbWU7XG4gICAgICAgIGlmICh0cnVlID09PSBkb3dubG9hZEF1dG9tYXRpY2FsbHkpIHtcbiAgICAgICAgICAgIGEuY2xpY2soKTsgLy8gQXV0b21hdGljYWxseSB0cnkgdG8gZG93bmxvYWQgdGhlIGZpbGUgY2NcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbn0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQUdBO0FBQ0E7Ozs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFBQTs7Ozs7QUFDQTs7QUFDQTtBQUNBOztBQURBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBWEE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBREE7Ozs7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBREE7QUFDQTtBQUFBOzs7Ozs7QUFDQTtBQUNBOztBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTFCQTs7Ozs7QUE0QkE7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7QUFPQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFZQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7OztBQUFBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBREE7QUFDQTtBQUFBOzs7Ozs7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7O0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7QUFFQTtBQUNBOztBQUtBO0FBQ0E7O0FBREE7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBOztBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFkQTs7Ozs7QUFlQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7O0FBVUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQTlLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBdlFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/BlackBoxPlusExport.js\n");

/***/ }),

/***/ "./src/components/BlackBoxPlusInfo.js":
/*!********************************************!*\
  !*** ./src/components/BlackBoxPlusInfo.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BlackBoxPlusInfo; });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n/**\n * =================================================================\n *  The base component\n * =================================================================\n */\nvar BlackBoxPlusInfo =\n/*#__PURE__*/\nfunction () {\n  function BlackBoxPlusInfo() {\n    var header = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this, BlackBoxPlusInfo);\n\n    this.header = 'BlackBox Plus';\n    this.bookmarkletInfoId = 'bbox_plus_bookmarklet_info';\n    this.idPostfix = '';\n    this.infoElement = void 0;\n    this.infoTextElement = void 0;\n    this.infoStatusElement = void 0;\n    this.infoHeaderElement = void 0;\n    this.authToken = void 0;\n    this.memberId = void 0;\n    this.interfaceSection = void 0;\n    this.messagesSection = void 0;\n    this.bbox_m_header_menu_id = 'm_header_menu';\n    // If there's already another bookmarklet initiated then create another\n    var bookmarkletInfoElement = document.getElementById(this.bookmarkletInfoId);\n\n    if (!bookmarkletInfoElement) {\n      console.debug(\"Setting up \" + this.bbox_m_header_menu_id);\n      var nav = document.getElementById(this.bbox_m_header_menu_id);\n\n      if (!nav) {\n        this.addFlashMessage('Unable to find the Nav Menu, can\\'t add BlackBox, wait until it\\'s loaded and try again', 'error');\n        throw new Error('Unable to find the Nav Menu');\n      }\n\n      nav.insertAdjacentHTML('afterend', \"                   <div id=\\\"\".concat(this.bookmarkletInfoId, \"\\\" class=\\\"bbox_plus_bookmarklet_info_wrapper\\\" style=\\\"color: white; float: left; padding-top: 10px; position: absolute; left: 150px; width: 270px;\\\"><h3 id=\\\"bbox_plus_header\\\"                 class=\\\"bbox_plus_header\\\">BlackBox Plus</h3><p style=\\\"color: white\\\" class=\\\"bbox_plus_info_text_wrapper\\\"><strong id=\\\"bbox_plus_status\\\"                     style=\\\"color: red\\\" class=\\\"bbox_plus_info_status\\\">*</strong> &nbsp; <span id=\\\"bbox_plus_text\\\"                   class=\\\"bbox_plus_info_text\\\">Loading</span></p></div>\"));\n      console.debug(\"Setup a Blackbox Plus info\");\n    } else {\n      this.idPostfix = '_2'; // There's already a bookmarklet installed, to create a 2nd\n\n      this.bookmarkletInfoId = 'bbox_plus_bookmarklet_info' + this.idPostfix;\n\n      if (document.getElementById(this.bookmarkletInfoId)) {\n        // @todo: Display the error better, like in a flash message\n        this.addFlashMessage('Unable to add a 3rd BlackBox Plus system', 'error');\n        throw new Error(\"Unable to add a 3rd BlackBox Plus system\");\n      }\n\n      bookmarkletInfoElement.insertAdjacentHTML('afterend', \"<div id=\\\"\".concat(this.bookmarkletInfoId, \"\\\" class=\\\"bbox_plus_bookmarklet_info_wrapper\\\" style=\\\"color: white; float: left; padding-top: 10px; position: absolute; width: 250px; left: 425px;\\\"><h3 id=\\\"bbox_plus_header\").concat(this.idPostfix, \"\\\"  class=\\\"bbox_plus_header\\\">BlackBox Plus</h3><p style=\\\"color: white\\\" class=\\\"bbox_plus_info_text_wrapper\\\"><strong id=\\\"bbox_plus_status\").concat(this.idPostfix, \"\\\" style=\\\"color: red\\\" class=\\\"bbox_plus_info_status\\\">*</strong> &nbsp; <span id=\\\"bbox_plus_text\").concat(this.idPostfix, \"\\\"  class=\\\"bbox_plus_info_text\\\">Loading</span></p></div>\"));\n      console.debug(\"Setup a 2nd Blackbox Plus info\");\n    }\n\n    this.infoElement = document.getElementById(this.bookmarkletInfoId);\n    this.infoHeaderElement = document.getElementById('bbox_plus_header' + this.idPostfix);\n    this.infoStatusElement = document.getElementById('bbox_plus_status' + this.idPostfix);\n    this.infoTextElement = document.getElementById('bbox_plus_text' + this.idPostfix);\n    this.createFooterSection();\n\n    if (header) {\n      this.setHeader(header);\n      this.setInterface(\"<h2>BlackBox Plus \".concat(header, \"</h2>\"));\n    }\n\n    this.addMessage(\"<hr /><h3>Messages</h3><a>You can add this bookmarklet from <a href=\\\"https://blackboxplus.greyphoenix.biz/\\\">blackboxplus.greyphoenix.biz</a> and checkout the codebase on <a href=\\\"https://github.com/kublermdk/BlackBox-Plus\\\">Github</a></p>\"); // this.addMessage('<p>Initial Loading complete</p>');\n  }\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(BlackBoxPlusInfo, [{\n    key: \"createFooterSection\",\n    value: function createFooterSection() {\n      // let footer = $('footer')[0];\n      var footerWrapperElement = document.getElementById('bbox_plus_footer_wrapper');\n      var footerElement = document.getElementsByTagName('footer')[0] || null;\n      var interfaceSectionContent = \"<div class=\\\"bbox_plus_interface_wrapper\\\" style=\\\"float: left; margin-left: 10px; margin-bottom: 10px;\\\"><div id=\\\"bbox_plus_interface_section\".concat(this.idPostfix, \"\\\"></div><div id=\\\"bbox_plus_messages_section\").concat(this.idPostfix, \"\\\"></div></div>\");\n\n      if (footerElement && footerWrapperElement) {\n        // Already installed before\n        // @todo: Make only 50% of the footer\n        footerWrapperElement.insertAdjacentHTML('beforeend', interfaceSectionContent);\n        $('.bbox_plus_interface_wrapper')[0].style.width = '48%';\n        $('.bbox_plus_interface_wrapper')[1].style.width = '48%';\n      } else if (footerElement) {\n        // Inserting the wrapper as well\n        footerElement.insertAdjacentHTML('afterend', \"<div id=\\\"bbox_plus_footer_wrapper\\\">\".concat(interfaceSectionContent, \"</div>\"));\n      } else {\n        console.error(\"Issue trying to find the <footer> element\");\n        this.addFlashMessage('Unable to find the footer section, wait until the page has fully loaded and try again or refresh', 'error');\n        throw new Error('Unable to create a Footer section, no footer element found');\n      }\n\n      this.interfaceSection = document.getElementById(\"bbox_plus_interface_section\".concat(this.idPostfix));\n      this.messagesSection = document.getElementById(\"bbox_plus_messages_section\".concat(this.idPostfix));\n    }\n    /**\n     * Set Interface\n     *\n     * The section at the bottom of the screen. This allows for buttons and options, etc..\n     * @param html\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"setInterface\",\n    value: function setInterface(html) {\n      this.interfaceSection.innerHTML = html;\n      return true;\n    }\n    /**\n     * Add Message\n     *\n     * This is at the bottom of the page, below the Interface section and is for messages like operations which have been completed, etc..\n     * @param messageHTML\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"addMessage\",\n    value: function addMessage(messageHTML) {\n      var existingHTML = this.messagesSection.innerHTML || '';\n      this.messagesSection.innerHTML = existingHTML + messageHTML;\n      return true;\n    }\n    /**\n     * Type should be one of 'info', 'success', 'warn', 'error'\n     * @param message\n     * @param type\n     */\n\n  }, {\n    key: \"addFlashMessage\",\n    value: function addFlashMessage(message, type) {\n      var autoRemove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      // @todo: Implement something similar to https://www.w3schools.com/howto/howto_js_alert.asp\n      var messageHTML = \"<div class=\\\"bbox_plus bbox_plus_flash_message bbox_plus_flash_message_type_\".concat(type, \"\\\"><span class=\\\"bbox_plus_flash_message_closebtn\\\" onclick=\\\"this.parentElement.style.display='none';\\\">&times;</span>\").concat(message, \"</div>\");\n      var flashElement = document.createElement('div');\n      flashElement.innerHTML = messageHTML;\n      document.body.insertAdjacentElement('beforeend', flashElement);\n\n      if (true === autoRemove) {\n        setTimeout(function () {\n          flashElement.remove(); // @todo: fadeout instead\n        }, 6000);\n      }\n\n      return flashElement;\n    }\n  }, {\n    key: \"setHeader\",\n    value: function setHeader(header) {\n      this.header = header;\n      this.infoHeaderElement.innerHTML = header;\n    }\n  }, {\n    key: \"setStatus\",\n    value: function setStatus() {\n      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var colour = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      if (text) {\n        this.infoTextElement.innerHTML = text;\n      }\n\n      if (colour) {\n        this.infoStatusElement.style.color = colour;\n      }\n\n      console.debug(\"Status: \" + text);\n    }\n  }, {\n    key: \"setStatusError\",\n    value: function setStatusError() {\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      this.setHeader('ERROR ' + this.header);\n      this.setStatus(\"<span style=\\\"color: red\\\">ERROR \".concat(context, \"</span>\"), 'red'); // @todo: Also display as a flash message\n\n      this.addFlashMessage('Error ' + context, 'error');\n      console.error(\"## ERROR ## \" + context);\n    }\n  }, {\n    key: \"setStatusLoading\",\n    value: function setStatusLoading() {\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      this.setStatus('Loading ' + context, 'orange');\n      console.debug(\"Loading: \" + context);\n    }\n  }, {\n    key: \"setStatusProcessing\",\n    value: function setStatusProcessing() {\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      this.setStatus('Processing ' + context, 'orange');\n      console.debug(\"Processing: \" + context);\n    }\n  }, {\n    key: \"setStatusDone\",\n    value: function setStatusDone() {\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      this.setStatus('Completed ' + context, 'green');\n      console.debug(\"Completed: \" + context);\n    } // c = await fetch('https://cors-anywhere.herokuapp.com/');\n    // d = await c.text();\n\n  }, {\n    key: \"dynamicallyLoadScript\",\n    value: function dynamicallyLoadScript(url) {\n      var script = document.createElement(\"script\"); // create a script DOM node\n\n      script.type = 'text/javascript';\n      script.src = url; // set its src to the provided URL\n\n      document.head.appendChild(script); // add it to the end of the head section of the page (could change 'head' to 'body' to add it to the end of the body section instead)\n    }\n  }, {\n    key: \"getAuthToken\",\n    value: function getAuthToken() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.authToken && false === force) {\n        return this.authToken;\n      }\n\n      var authToken = localStorage.token; // Get this by looking at an existing request.\n\n      if (!authToken) {\n        // $messagesSection.append('<h2 class=\"btn-outline-danger\">Unable to get your authToken. Are you logged in?</h2>');\n        this.setStatusError('Unable to get your auth token, are you logged in?');\n        throw new Error('Error, invalid auth token');\n      }\n\n      return authToken;\n    }\n  }, {\n    key: \"getMemberId\",\n    value: function getMemberId() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.memberId && false === force) {\n        return this.memberId;\n      }\n\n      var imageUrl = $('.m-topbar__userpic img').attr('src'); // e.g \"https://portal.blackbox.global/api/member/5afd6163-a82a-4079-8e3b-592c349ae72d/W/avatar?1577006745917\" -> 5afd6163-a82a-4079-8e3b-592c349ae72d\n\n      if (!imageUrl) {\n        this.setStatusError('Do you have an avatar picture? Without it we are unable to work out your BlackBox memberId');\n        throw new Error('Error, Unable to work out your Blackbox MemberId');\n      } else {\n        var memberId = imageUrl.replace('https://portal.blackbox.global/api/member/', '').replace(/\\/W\\/avatar.*/, '');\n\n        if (memberId) {\n          this.memberId = memberId;\n        } else {\n          this.setStatusError('Unable to work out your BlackBox memberId');\n          throw new Error('Issue trying to work out the memberId based off the avatar image');\n        }\n\n        return memberId;\n      }\n    }\n  }, {\n    key: \"clearMarketplaceCollaborationProjectsList\",\n    value: function () {\n      var _clearMarketplaceCollaborationProjectsList = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n      /*#__PURE__*/\n      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {\n        var _this = this;\n\n        var memberId, authToken, headers, collaboratedProjectsListResponse, collaboratedProjects;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.setStatusLoading(\"Loading up the Collaboration Projects list\");\n                memberId = this.getMemberId();\n                authToken = this.getAuthToken();\n                headers = getDefaultAPICallHeaders('POST');\n                _context.next = 6;\n                return fetch(\"https://portal.blackbox.global/api/member/\".concat(memberId, \"/collaboratedProjects?index=1&limit=100\"), headers);\n\n              case 6:\n                collaboratedProjectsListResponse = _context.sent;\n\n                if (!collaboratedProjectsListResponse.ok) {\n                  _context.next = 16;\n                  break;\n                }\n\n                _context.next = 10;\n                return collaboratedProjectsListResponse.json();\n\n              case 10:\n                collaboratedProjects = _context.sent;\n                console.debug(\"There are \".concat(collaboratedProjects.list.length, \" Collaboration Project entries \"), collaboratedProjects);\n                this.setStatusProcessing(\"Clearing the \".concat(collaboratedProjects.list.length, \" Collaboration Projects\"));\n\n                if (collaboratedProjects.list.length > 0) {\n                  headers.method = 'PUT'; // Want to do a PUT call to clear the entries\n\n                  collaboratedProjects.list.forEach(function (element, index) {\n                    _this.setStatusProcessing(\"Clearing #\".concat(index, \" \").concat(element.projectName)); // $messagesSection.append('<p class=\"\" data-projectid=\"${element.projectId}\">Clearing the Marketplace Entry #{index} ${element.projectName}</p>');\n\n\n                    console.debug(\"Clearing the Collab Entry #\".concat(index, \" \").concat(element.projectName), element); // Console.log doesn't actually work, they've set it to an empty function\n\n                    fetch(\"https://portal.blackbox.global/api/member/\".concat(memberId, \"/project/\").concat(element.projectId, \"/clearCurationProject\"), headers);\n                  });\n                }\n\n                _context.next = 17;\n                break;\n\n              case 16:\n                this.setStatusError(\"Unable to get the list of projects. HTTP-Error: \".concat(collaboratedProjectsListResponse.status));\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function clearMarketplaceCollaborationProjectsList() {\n        return _clearMarketplaceCollaborationProjectsList.apply(this, arguments);\n      }\n\n      return clearMarketplaceCollaborationProjectsList;\n    }()\n  }, {\n    key: \"getAPICallHeaders\",\n    value: function getAPICallHeaders() {\n      var method = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'GET';\n      var authToken = this.getAuthToken();\n      return {\n        \"credentials\": \"include\",\n        \"headers\": {\n          \"accept\": \"application/json, text/plain, */*\",\n          \"accept-language\": \"en-AU,en;q=0.9,en-US;q=0.8\",\n          \"cache-control\": \"no-cache\",\n          \"content-type\": \"application/vnd.blackbox.v1+json\",\n          \"pragma\": \"no-cache\",\n          \"sec-fetch-mode\": \"cors\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"timeout\": \"8000\",\n          \"token\": authToken\n        },\n        \"referrer\": \"https://portal.blackbox.global/footage/marketplace?blackbox_plus=true\",\n        // Added a query string so Blackbox can track these queries\n        \"referrerPolicy\": \"no-referrer-when-downgrade\",\n        // \"body\": \"{}\",\n        \"method\": method,\n        \"mode\": \"cors\"\n      };\n    }\n  }, {\n    key: \"getFormattedDate\",\n    value: function getFormattedDate() {\n      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"{Y}-{M}-{D}{st} {h}_{m}{ap}\";\n      var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      // e.g 2012-09-05th 09_02AM Based on https://www.willmaster.com/library/generators/date-and-time-formatting.php using {Y}-{M}-{D} {h}_{m}{ap}\n      // let format = \"{Y}-{M}-{D}{st} {h}_{m}{ap}\";\n      now = now || new Date(); // This current millisecond on user's computer.\n\n      var Month = '';\n      Month = now.getMonth() + 1;\n\n      if (Month < 10) {\n        Month = \"0\" + Month;\n      }\n\n      format = format.replace(/{M}/g, Month); // Month Day\n\n      var Mday = '';\n      Mday = now.getDate();\n\n      if (Mday < 10) {\n        Mday = \"0\" + Mday;\n      }\n\n      format = format.replace(/{D}/g, Mday); // St day suffix (Michael Kubler's custom addition)\n      // e.g 1st, 2nd, 3rd, 4th, 5th ...\n\n      var st = 'th';\n      var MdaySingle = now.getDate();\n\n      if (MdaySingle < 4) {\n        if (MdaySingle === 3) {\n          st = 'rd';\n        } else if (MdaySingle === 2) {\n          st = 'nd';\n        } else if (MdaySingle === 1) {\n          st = 'st';\n        }\n      }\n\n      format = format.replace(/{st}/g, st);\n      var Year = '';\n      Year = now.getFullYear();\n      format = format.replace(/{Y}/g, Year);\n      var h = now.getHours();\n      var ap = '';\n      var pm = h > 11;\n\n      if (h > 12) {\n        h -= 12;\n      }\n\n      ap = pm ? \"PM\" : \"AM\";\n      format = format.replace(/{ap}/g, ap);\n      var hh = '';\n\n      if (h < 10) {\n        hh = \"0\" + h;\n      } else {\n        hh = h;\n      }\n\n      format = format.replace(/{h}/g, hh);\n      var mm = '';\n      mm = now.getMinutes();\n\n      if (mm < 10) {\n        mm = \"0\" + mm;\n      }\n\n      format = format.replace(/{m}/g, mm);\n      return format;\n    }\n    /**\n     * Based off https://stackoverflow.com/a/3662980/7299352\n     * @param str\n     * @returns {DocumentFragment}\n     */\n\n  }, {\n    key: \"createNewElement\",\n    value: function createNewElement(str) {\n      var frag = document.createDocumentFragment();\n      var elem = document.createElement('div');\n      elem.innerHTML = str;\n\n      while (elem.childNodes[0]) {\n        frag.appendChild(elem.childNodes[0]);\n      }\n\n      return frag;\n    }\n  }]);\n\n  return BlackBoxPlusInfo;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9CbGFja0JveFBsdXNJbmZvLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQmxhY2tCb3hQbHVzSW5mby5qcz9kNjk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqICBUaGUgYmFzZSBjb21wb25lbnRcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsYWNrQm94UGx1c0luZm8ge1xuXG4gICAgaGVhZGVyID0gJ0JsYWNrQm94IFBsdXMnO1xuICAgIGJvb2ttYXJrbGV0SW5mb0lkID0gJ2Jib3hfcGx1c19ib29rbWFya2xldF9pbmZvJztcbiAgICBpZFBvc3RmaXggPSAnJztcbiAgICBpbmZvRWxlbWVudDtcbiAgICBpbmZvVGV4dEVsZW1lbnQ7XG4gICAgaW5mb1N0YXR1c0VsZW1lbnQ7XG4gICAgaW5mb0hlYWRlckVsZW1lbnQ7XG4gICAgYXV0aFRva2VuO1xuICAgIG1lbWJlcklkO1xuICAgIGludGVyZmFjZVNlY3Rpb247XG4gICAgbWVzc2FnZXNTZWN0aW9uO1xuICAgIGJib3hfbV9oZWFkZXJfbWVudV9pZCA9ICdtX2hlYWRlcl9tZW51JztcblxuICAgIGNvbnN0cnVjdG9yKGhlYWRlciA9ICcnKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBhbm90aGVyIGJvb2ttYXJrbGV0IGluaXRpYXRlZCB0aGVuIGNyZWF0ZSBhbm90aGVyXG4gICAgICAgIGxldCBib29rbWFya2xldEluZm9FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5ib29rbWFya2xldEluZm9JZCk7XG5cbiAgICAgICAgaWYgKCFib29rbWFya2xldEluZm9FbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiU2V0dGluZyB1cCBcIiArIHRoaXMuYmJveF9tX2hlYWRlcl9tZW51X2lkKTtcbiAgICAgICAgICAgIGxldCBuYXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmJib3hfbV9oZWFkZXJfbWVudV9pZCk7XG4gICAgICAgICAgICBpZiAoIW5hdikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmxhc2hNZXNzYWdlKCdVbmFibGUgdG8gZmluZCB0aGUgTmF2IE1lbnUsIGNhblxcJ3QgYWRkIEJsYWNrQm94LCB3YWl0IHVudGlsIGl0XFwncyBsb2FkZWQgYW5kIHRyeSBhZ2FpbicsICdlcnJvcicpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdGhlIE5hdiBNZW51Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYXYuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmVuZCcsIGAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7dGhpcy5ib29rbWFya2xldEluZm9JZH1cIiBjbGFzcz1cImJib3hfcGx1c19ib29rbWFya2xldF9pbmZvX3dyYXBwZXJcIiBzdHlsZT1cImNvbG9yOiB3aGl0ZTsgZmxvYXQ6IGxlZnQ7IHBhZGRpbmctdG9wOiAxMHB4OyBwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDE1MHB4OyB3aWR0aDogMjcwcHg7XCI+PGgzIGlkPVwiYmJveF9wbHVzX2hlYWRlclwiICAgICAgICAgICAgICAgICBjbGFzcz1cImJib3hfcGx1c19oZWFkZXJcIj5CbGFja0JveCBQbHVzPC9oMz48cCBzdHlsZT1cImNvbG9yOiB3aGl0ZVwiIGNsYXNzPVwiYmJveF9wbHVzX2luZm9fdGV4dF93cmFwcGVyXCI+PHN0cm9uZyBpZD1cImJib3hfcGx1c19zdGF0dXNcIiAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiY29sb3I6IHJlZFwiIGNsYXNzPVwiYmJveF9wbHVzX2luZm9fc3RhdHVzXCI+Kjwvc3Ryb25nPiAmbmJzcDsgPHNwYW4gaWQ9XCJiYm94X3BsdXNfdGV4dFwiICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYmJveF9wbHVzX2luZm9fdGV4dFwiPkxvYWRpbmc8L3NwYW4+PC9wPjwvZGl2PmApO1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIlNldHVwIGEgQmxhY2tib3ggUGx1cyBpbmZvXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pZFBvc3RmaXggPSAnXzInO1xuICAgICAgICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgYm9va21hcmtsZXQgaW5zdGFsbGVkLCB0byBjcmVhdGUgYSAybmRcbiAgICAgICAgICAgIHRoaXMuYm9va21hcmtsZXRJbmZvSWQgPSAnYmJveF9wbHVzX2Jvb2ttYXJrbGV0X2luZm8nICsgdGhpcy5pZFBvc3RmaXg7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5ib29rbWFya2xldEluZm9JZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBAdG9kbzogRGlzcGxheSB0aGUgZXJyb3IgYmV0dGVyLCBsaWtlIGluIGEgZmxhc2ggbWVzc2FnZVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmxhc2hNZXNzYWdlKCdVbmFibGUgdG8gYWRkIGEgM3JkIEJsYWNrQm94IFBsdXMgc3lzdGVtJywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGFkZCBhIDNyZCBCbGFja0JveCBQbHVzIHN5c3RlbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvb2ttYXJrbGV0SW5mb0VsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmVuZCcsIGA8ZGl2IGlkPVwiJHt0aGlzLmJvb2ttYXJrbGV0SW5mb0lkfVwiIGNsYXNzPVwiYmJveF9wbHVzX2Jvb2ttYXJrbGV0X2luZm9fd3JhcHBlclwiIHN0eWxlPVwiY29sb3I6IHdoaXRlOyBmbG9hdDogbGVmdDsgcGFkZGluZy10b3A6IDEwcHg7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDI1MHB4OyBsZWZ0OiA0MjVweDtcIj48aDMgaWQ9XCJiYm94X3BsdXNfaGVhZGVyJHt0aGlzLmlkUG9zdGZpeH1cIiAgY2xhc3M9XCJiYm94X3BsdXNfaGVhZGVyXCI+QmxhY2tCb3ggUGx1czwvaDM+PHAgc3R5bGU9XCJjb2xvcjogd2hpdGVcIiBjbGFzcz1cImJib3hfcGx1c19pbmZvX3RleHRfd3JhcHBlclwiPjxzdHJvbmcgaWQ9XCJiYm94X3BsdXNfc3RhdHVzJHt0aGlzLmlkUG9zdGZpeH1cIiBzdHlsZT1cImNvbG9yOiByZWRcIiBjbGFzcz1cImJib3hfcGx1c19pbmZvX3N0YXR1c1wiPio8L3N0cm9uZz4gJm5ic3A7IDxzcGFuIGlkPVwiYmJveF9wbHVzX3RleHQke3RoaXMuaWRQb3N0Zml4fVwiICBjbGFzcz1cImJib3hfcGx1c19pbmZvX3RleHRcIj5Mb2FkaW5nPC9zcGFuPjwvcD48L2Rpdj5gKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJTZXR1cCBhIDJuZCBCbGFja2JveCBQbHVzIGluZm9cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmZvRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuYm9va21hcmtsZXRJbmZvSWQpO1xuICAgICAgICB0aGlzLmluZm9IZWFkZXJFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Jib3hfcGx1c19oZWFkZXInICsgdGhpcy5pZFBvc3RmaXgpO1xuICAgICAgICB0aGlzLmluZm9TdGF0dXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Jib3hfcGx1c19zdGF0dXMnICsgdGhpcy5pZFBvc3RmaXgpO1xuICAgICAgICB0aGlzLmluZm9UZXh0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiYm94X3BsdXNfdGV4dCcgKyB0aGlzLmlkUG9zdGZpeCk7XG4gICAgICAgIHRoaXMuY3JlYXRlRm9vdGVyU2VjdGlvbigpO1xuXG4gICAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVyKGhlYWRlcik7XG4gICAgICAgICAgICB0aGlzLnNldEludGVyZmFjZShgPGgyPkJsYWNrQm94IFBsdXMgJHtoZWFkZXJ9PC9oMj5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZE1lc3NhZ2UoYDxociAvPjxoMz5NZXNzYWdlczwvaDM+PGE+WW91IGNhbiBhZGQgdGhpcyBib29rbWFya2xldCBmcm9tIDxhIGhyZWY9XCJodHRwczovL2JsYWNrYm94cGx1cy5ncmV5cGhvZW5peC5iaXovXCI+YmxhY2tib3hwbHVzLmdyZXlwaG9lbml4LmJpejwvYT4gYW5kIGNoZWNrb3V0IHRoZSBjb2RlYmFzZSBvbiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL2t1Ymxlcm1kay9CbGFja0JveC1QbHVzXCI+R2l0aHViPC9hPjwvcD5gKTtcbiAgICAgICAgLy8gdGhpcy5hZGRNZXNzYWdlKCc8cD5Jbml0aWFsIExvYWRpbmcgY29tcGxldGU8L3A+Jyk7XG4gICAgfVxuXG4gICAgY3JlYXRlRm9vdGVyU2VjdGlvbigpIHtcbiAgICAgICAgLy8gbGV0IGZvb3RlciA9ICQoJ2Zvb3RlcicpWzBdO1xuICAgICAgICBsZXQgZm9vdGVyV3JhcHBlckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmJveF9wbHVzX2Zvb3Rlcl93cmFwcGVyJyk7XG4gICAgICAgIGxldCBmb290ZXJFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Zvb3RlcicpWzBdIHx8IG51bGw7XG4gICAgICAgIGxldCBpbnRlcmZhY2VTZWN0aW9uQ29udGVudCA9IGA8ZGl2IGNsYXNzPVwiYmJveF9wbHVzX2ludGVyZmFjZV93cmFwcGVyXCIgc3R5bGU9XCJmbG9hdDogbGVmdDsgbWFyZ2luLWxlZnQ6IDEwcHg7IG1hcmdpbi1ib3R0b206IDEwcHg7XCI+PGRpdiBpZD1cImJib3hfcGx1c19pbnRlcmZhY2Vfc2VjdGlvbiR7dGhpcy5pZFBvc3RmaXh9XCI+PC9kaXY+PGRpdiBpZD1cImJib3hfcGx1c19tZXNzYWdlc19zZWN0aW9uJHt0aGlzLmlkUG9zdGZpeH1cIj48L2Rpdj48L2Rpdj5gO1xuICAgICAgICBpZiAoZm9vdGVyRWxlbWVudCAmJiBmb290ZXJXcmFwcGVyRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBpbnN0YWxsZWQgYmVmb3JlXG4gICAgICAgICAgICAvLyBAdG9kbzogTWFrZSBvbmx5IDUwJSBvZiB0aGUgZm9vdGVyXG4gICAgICAgICAgICBmb290ZXJXcmFwcGVyRWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGludGVyZmFjZVNlY3Rpb25Db250ZW50KTtcbiAgICAgICAgICAgICQoJy5iYm94X3BsdXNfaW50ZXJmYWNlX3dyYXBwZXInKVswXS5zdHlsZS53aWR0aCA9ICc0OCUnO1xuICAgICAgICAgICAgJCgnLmJib3hfcGx1c19pbnRlcmZhY2Vfd3JhcHBlcicpWzFdLnN0eWxlLndpZHRoID0gJzQ4JSc7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9vdGVyRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0aW5nIHRoZSB3cmFwcGVyIGFzIHdlbGxcbiAgICAgICAgICAgIGZvb3RlckVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmVuZCcsIGA8ZGl2IGlkPVwiYmJveF9wbHVzX2Zvb3Rlcl93cmFwcGVyXCI+JHtpbnRlcmZhY2VTZWN0aW9uQ29udGVudH08L2Rpdj5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJc3N1ZSB0cnlpbmcgdG8gZmluZCB0aGUgPGZvb3Rlcj4gZWxlbWVudFwiKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRmxhc2hNZXNzYWdlKCdVbmFibGUgdG8gZmluZCB0aGUgZm9vdGVyIHNlY3Rpb24sIHdhaXQgdW50aWwgdGhlIHBhZ2UgaGFzIGZ1bGx5IGxvYWRlZCBhbmQgdHJ5IGFnYWluIG9yIHJlZnJlc2gnLCAnZXJyb3InKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNyZWF0ZSBhIEZvb3RlciBzZWN0aW9uLCBubyBmb290ZXIgZWxlbWVudCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJmYWNlU2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBiYm94X3BsdXNfaW50ZXJmYWNlX3NlY3Rpb24ke3RoaXMuaWRQb3N0Zml4fWApO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzU2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBiYm94X3BsdXNfbWVzc2FnZXNfc2VjdGlvbiR7dGhpcy5pZFBvc3RmaXh9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IEludGVyZmFjZVxuICAgICAqXG4gICAgICogVGhlIHNlY3Rpb24gYXQgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuLiBUaGlzIGFsbG93cyBmb3IgYnV0dG9ucyBhbmQgb3B0aW9ucywgZXRjLi5cbiAgICAgKiBAcGFyYW0gaHRtbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldEludGVyZmFjZShodG1sKSB7XG4gICAgICAgIHRoaXMuaW50ZXJmYWNlU2VjdGlvbi5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgTWVzc2FnZVxuICAgICAqXG4gICAgICogVGhpcyBpcyBhdCB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLCBiZWxvdyB0aGUgSW50ZXJmYWNlIHNlY3Rpb24gYW5kIGlzIGZvciBtZXNzYWdlcyBsaWtlIG9wZXJhdGlvbnMgd2hpY2ggaGF2ZSBiZWVuIGNvbXBsZXRlZCwgZXRjLi5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZUhUTUxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBhZGRNZXNzYWdlKG1lc3NhZ2VIVE1MKSB7XG4gICAgICAgIGxldCBleGlzdGluZ0hUTUwgPSB0aGlzLm1lc3NhZ2VzU2VjdGlvbi5pbm5lckhUTUwgfHwgJyc7XG4gICAgICAgIHRoaXMubWVzc2FnZXNTZWN0aW9uLmlubmVySFRNTCA9IGV4aXN0aW5nSFRNTCArIG1lc3NhZ2VIVE1MO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIHNob3VsZCBiZSBvbmUgb2YgJ2luZm8nLCAnc3VjY2VzcycsICd3YXJuJywgJ2Vycm9yJ1xuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHR5cGVcbiAgICAgKi9cbiAgICBhZGRGbGFzaE1lc3NhZ2UobWVzc2FnZSwgdHlwZSwgYXV0b1JlbW92ZSA9IHRydWUpIHtcbiAgICAgICAgLy8gQHRvZG86IEltcGxlbWVudCBzb21ldGhpbmcgc2ltaWxhciB0byBodHRwczovL3d3dy53M3NjaG9vbHMuY29tL2hvd3RvL2hvd3RvX2pzX2FsZXJ0LmFzcFxuICAgICAgICBsZXQgbWVzc2FnZUhUTUwgPSBgPGRpdiBjbGFzcz1cImJib3hfcGx1cyBiYm94X3BsdXNfZmxhc2hfbWVzc2FnZSBiYm94X3BsdXNfZmxhc2hfbWVzc2FnZV90eXBlXyR7dHlwZX1cIj48c3BhbiBjbGFzcz1cImJib3hfcGx1c19mbGFzaF9tZXNzYWdlX2Nsb3NlYnRuXCIgb25jbGljaz1cInRoaXMucGFyZW50RWxlbWVudC5zdHlsZS5kaXNwbGF5PSdub25lJztcIj4mdGltZXM7PC9zcGFuPiR7bWVzc2FnZX08L2Rpdj5gO1xuICAgICAgICBsZXQgZmxhc2hFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGZsYXNoRWxlbWVudC5pbm5lckhUTUwgPSBtZXNzYWdlSFRNTDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2JlZm9yZWVuZCcsIGZsYXNoRWxlbWVudCk7XG5cbiAgICAgICAgaWYgKHRydWUgPT09IGF1dG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZsYXNoRWxlbWVudC5yZW1vdmUoKTsgLy8gQHRvZG86IGZhZGVvdXQgaW5zdGVhZFxuICAgICAgICAgICAgfSwgNjAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXNoRWxlbWVudDtcbiAgICB9XG5cbiAgICBzZXRIZWFkZXIoaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICB0aGlzLmluZm9IZWFkZXJFbGVtZW50LmlubmVySFRNTCA9IGhlYWRlcjtcbiAgICB9XG5cbiAgICBzZXRTdGF0dXModGV4dCA9ICcnLCBjb2xvdXIgPSAnJykge1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgdGhpcy5pbmZvVGV4dEVsZW1lbnQuaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sb3VyKSB7XG4gICAgICAgICAgICB0aGlzLmluZm9TdGF0dXNFbGVtZW50LnN0eWxlLmNvbG9yID0gY29sb3VyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJTdGF0dXM6IFwiICsgdGV4dCk7XG4gICAgfVxuXG4gICAgc2V0U3RhdHVzRXJyb3IoY29udGV4dCA9ICcnKSB7XG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKCdFUlJPUiAnICsgdGhpcy5oZWFkZXIpO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhgPHNwYW4gc3R5bGU9XCJjb2xvcjogcmVkXCI+RVJST1IgJHtjb250ZXh0fTwvc3Bhbj5gLCAncmVkJyk7XG5cbiAgICAgICAgLy8gQHRvZG86IEFsc28gZGlzcGxheSBhcyBhIGZsYXNoIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5hZGRGbGFzaE1lc3NhZ2UoJ0Vycm9yICcgKyBjb250ZXh0LCAnZXJyb3InKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIiMjIEVSUk9SICMjIFwiICsgY29udGV4dCk7XG4gICAgfVxuXG4gICAgc2V0U3RhdHVzTG9hZGluZyhjb250ZXh0ID0gJycpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoJ0xvYWRpbmcgJyArIGNvbnRleHQsICdvcmFuZ2UnKTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcIkxvYWRpbmc6IFwiICsgY29udGV4dCk7XG4gICAgfVxuXG4gICAgc2V0U3RhdHVzUHJvY2Vzc2luZyhjb250ZXh0ID0gJycpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoJ1Byb2Nlc3NpbmcgJyArIGNvbnRleHQsICdvcmFuZ2UnKTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcIlByb2Nlc3Npbmc6IFwiICsgY29udGV4dCk7XG4gICAgfVxuXG4gICAgc2V0U3RhdHVzRG9uZShjb250ZXh0ID0gJycpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoJ0NvbXBsZXRlZCAnICsgY29udGV4dCwgJ2dyZWVuJyk7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJDb21wbGV0ZWQ6IFwiICsgY29udGV4dCk7XG4gICAgfVxuXG5cbi8vIGMgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9jb3JzLWFueXdoZXJlLmhlcm9rdWFwcC5jb20vJyk7XG4vLyBkID0gYXdhaXQgYy50ZXh0KCk7XG5cbiAgICBkeW5hbWljYWxseUxvYWRTY3JpcHQodXJsKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpOyAgLy8gY3JlYXRlIGEgc2NyaXB0IERPTSBub2RlXG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7ICAvLyBzZXQgaXRzIHNyYyB0byB0aGUgcHJvdmlkZWQgVVJMXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTsgIC8vIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBoZWFkIHNlY3Rpb24gb2YgdGhlIHBhZ2UgKGNvdWxkIGNoYW5nZSAnaGVhZCcgdG8gJ2JvZHknIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBib2R5IHNlY3Rpb24gaW5zdGVhZClcbiAgICB9XG5cbiAgICBnZXRBdXRoVG9rZW4oZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW4gJiYgZmFsc2UgPT09IGZvcmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGF1dGhUb2tlbiA9IGxvY2FsU3RvcmFnZS50b2tlbjsgLy8gR2V0IHRoaXMgYnkgbG9va2luZyBhdCBhbiBleGlzdGluZyByZXF1ZXN0LlxuICAgICAgICBpZiAoIWF1dGhUb2tlbikge1xuICAgICAgICAgICAgLy8gJG1lc3NhZ2VzU2VjdGlvbi5hcHBlbmQoJzxoMiBjbGFzcz1cImJ0bi1vdXRsaW5lLWRhbmdlclwiPlVuYWJsZSB0byBnZXQgeW91ciBhdXRoVG9rZW4uIEFyZSB5b3UgbG9nZ2VkIGluPzwvaDI+Jyk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1c0Vycm9yKCdVbmFibGUgdG8gZ2V0IHlvdXIgYXV0aCB0b2tlbiwgYXJlIHlvdSBsb2dnZWQgaW4/Jyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yLCBpbnZhbGlkIGF1dGggdG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aFRva2VuO1xuICAgIH1cblxuICAgIGdldE1lbWJlcklkKGZvcmNlID0gZmFsc2UpIHtcblxuICAgICAgICBpZiAodGhpcy5tZW1iZXJJZCAmJiBmYWxzZSA9PT0gZm9yY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbWJlcklkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbWFnZVVybCA9ICQoJy5tLXRvcGJhcl9fdXNlcnBpYyBpbWcnKS5hdHRyKCdzcmMnKTsgLy8gZS5nIFwiaHR0cHM6Ly9wb3J0YWwuYmxhY2tib3guZ2xvYmFsL2FwaS9tZW1iZXIvNWFmZDYxNjMtYTgyYS00MDc5LThlM2ItNTkyYzM0OWFlNzJkL1cvYXZhdGFyPzE1NzcwMDY3NDU5MTdcIiAtPiA1YWZkNjE2My1hODJhLTQwNzktOGUzYi01OTJjMzQ5YWU3MmRcblxuICAgICAgICBpZiAoIWltYWdlVXJsKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1c0Vycm9yKCdEbyB5b3UgaGF2ZSBhbiBhdmF0YXIgcGljdHVyZT8gV2l0aG91dCBpdCB3ZSBhcmUgdW5hYmxlIHRvIHdvcmsgb3V0IHlvdXIgQmxhY2tCb3ggbWVtYmVySWQnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IsIFVuYWJsZSB0byB3b3JrIG91dCB5b3VyIEJsYWNrYm94IE1lbWJlcklkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWVtYmVySWQgPSBpbWFnZVVybC5yZXBsYWNlKCdodHRwczovL3BvcnRhbC5ibGFja2JveC5nbG9iYWwvYXBpL21lbWJlci8nLCAnJykucmVwbGFjZSgvXFwvV1xcL2F2YXRhci4qLywgJycpO1xuICAgICAgICAgICAgaWYgKG1lbWJlcklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJJZCA9IG1lbWJlcklkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1c0Vycm9yKCdVbmFibGUgdG8gd29yayBvdXQgeW91ciBCbGFja0JveCBtZW1iZXJJZCcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSXNzdWUgdHJ5aW5nIHRvIHdvcmsgb3V0IHRoZSBtZW1iZXJJZCBiYXNlZCBvZmYgdGhlIGF2YXRhciBpbWFnZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWVtYmVySWQ7XG4gICAgICAgIH1cblxuXG4gICAgfVxuXG4gICAgYXN5bmMgY2xlYXJNYXJrZXRwbGFjZUNvbGxhYm9yYXRpb25Qcm9qZWN0c0xpc3QoKSB7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0dXNMb2FkaW5nKGBMb2FkaW5nIHVwIHRoZSBDb2xsYWJvcmF0aW9uIFByb2plY3RzIGxpc3RgKTtcbiAgICAgICAgbGV0IG1lbWJlcklkID0gdGhpcy5nZXRNZW1iZXJJZCgpO1xuICAgICAgICBsZXQgYXV0aFRva2VuID0gdGhpcy5nZXRBdXRoVG9rZW4oKTtcblxuICAgICAgICBsZXQgaGVhZGVycyA9IGdldERlZmF1bHRBUElDYWxsSGVhZGVycygnUE9TVCcpO1xuICAgICAgICBsZXQgY29sbGFib3JhdGVkUHJvamVjdHNMaXN0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9wb3J0YWwuYmxhY2tib3guZ2xvYmFsL2FwaS9tZW1iZXIvJHttZW1iZXJJZH0vY29sbGFib3JhdGVkUHJvamVjdHM/aW5kZXg9MSZsaW1pdD0xMDBgLCBoZWFkZXJzKTtcblxuXG4gICAgICAgIGlmIChjb2xsYWJvcmF0ZWRQcm9qZWN0c0xpc3RSZXNwb25zZS5vaykge1xuICAgICAgICAgICAgLy8gaWYgSFRUUC1zdGF0dXMgaXMgMjAwLTI5OVxuICAgICAgICAgICAgbGV0IGNvbGxhYm9yYXRlZFByb2plY3RzID0gYXdhaXQgY29sbGFib3JhdGVkUHJvamVjdHNMaXN0UmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgVGhlcmUgYXJlICR7Y29sbGFib3JhdGVkUHJvamVjdHMubGlzdC5sZW5ndGh9IENvbGxhYm9yYXRpb24gUHJvamVjdCBlbnRyaWVzIGAsIGNvbGxhYm9yYXRlZFByb2plY3RzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzUHJvY2Vzc2luZyhgQ2xlYXJpbmcgdGhlICR7Y29sbGFib3JhdGVkUHJvamVjdHMubGlzdC5sZW5ndGh9IENvbGxhYm9yYXRpb24gUHJvamVjdHNgKTtcbiAgICAgICAgICAgIGlmIChjb2xsYWJvcmF0ZWRQcm9qZWN0cy5saXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLm1ldGhvZCA9ICdQVVQnOyAvLyBXYW50IHRvIGRvIGEgUFVUIGNhbGwgdG8gY2xlYXIgdGhlIGVudHJpZXNcbiAgICAgICAgICAgICAgICBjb2xsYWJvcmF0ZWRQcm9qZWN0cy5saXN0LmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzUHJvY2Vzc2luZyhgQ2xlYXJpbmcgIyR7aW5kZXh9ICR7ZWxlbWVudC5wcm9qZWN0TmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gJG1lc3NhZ2VzU2VjdGlvbi5hcHBlbmQoJzxwIGNsYXNzPVwiXCIgZGF0YS1wcm9qZWN0aWQ9XCIke2VsZW1lbnQucHJvamVjdElkfVwiPkNsZWFyaW5nIHRoZSBNYXJrZXRwbGFjZSBFbnRyeSAje2luZGV4fSAke2VsZW1lbnQucHJvamVjdE5hbWV9PC9wPicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBDbGVhcmluZyB0aGUgQ29sbGFiIEVudHJ5ICMke2luZGV4fSAke2VsZW1lbnQucHJvamVjdE5hbWV9YCwgZWxlbWVudCk7IC8vIENvbnNvbGUubG9nIGRvZXNuJ3QgYWN0dWFsbHkgd29yaywgdGhleSd2ZSBzZXQgaXQgdG8gYW4gZW1wdHkgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgZmV0Y2goYGh0dHBzOi8vcG9ydGFsLmJsYWNrYm94Lmdsb2JhbC9hcGkvbWVtYmVyLyR7bWVtYmVySWR9L3Byb2plY3QvJHtlbGVtZW50LnByb2plY3RJZH0vY2xlYXJDdXJhdGlvblByb2plY3RgLCBoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXNFcnJvcihgVW5hYmxlIHRvIGdldCB0aGUgbGlzdCBvZiBwcm9qZWN0cy4gSFRUUC1FcnJvcjogJHtjb2xsYWJvcmF0ZWRQcm9qZWN0c0xpc3RSZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRBUElDYWxsSGVhZGVycyhtZXRob2QgPSAnR0VUJykge1xuICAgICAgICBsZXQgYXV0aFRva2VuID0gdGhpcy5nZXRBdXRoVG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwiY3JlZGVudGlhbHNcIjogXCJpbmNsdWRlXCIsXG4gICAgICAgICAgICBcImhlYWRlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiYWNjZXB0XCI6IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qXCIsXG4gICAgICAgICAgICAgICAgXCJhY2NlcHQtbGFuZ3VhZ2VcIjogXCJlbi1BVSxlbjtxPTAuOSxlbi1VUztxPTAuOFwiLFxuICAgICAgICAgICAgICAgIFwiY2FjaGUtY29udHJvbFwiOiBcIm5vLWNhY2hlXCIsXG4gICAgICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi92bmQuYmxhY2tib3gudjEranNvblwiLFxuICAgICAgICAgICAgICAgIFwicHJhZ21hXCI6IFwibm8tY2FjaGVcIixcbiAgICAgICAgICAgICAgICBcInNlYy1mZXRjaC1tb2RlXCI6IFwiY29yc1wiLFxuICAgICAgICAgICAgICAgIFwic2VjLWZldGNoLXNpdGVcIjogXCJzYW1lLW9yaWdpblwiLFxuICAgICAgICAgICAgICAgIFwidGltZW91dFwiOiBcIjgwMDBcIixcbiAgICAgICAgICAgICAgICBcInRva2VuXCI6IGF1dGhUb2tlblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVmZXJyZXJcIjogXCJodHRwczovL3BvcnRhbC5ibGFja2JveC5nbG9iYWwvZm9vdGFnZS9tYXJrZXRwbGFjZT9ibGFja2JveF9wbHVzPXRydWVcIiwgLy8gQWRkZWQgYSBxdWVyeSBzdHJpbmcgc28gQmxhY2tib3ggY2FuIHRyYWNrIHRoZXNlIHF1ZXJpZXNcbiAgICAgICAgICAgIFwicmVmZXJyZXJQb2xpY3lcIjogXCJuby1yZWZlcnJlci13aGVuLWRvd25ncmFkZVwiLFxuICAgICAgICAgICAgLy8gXCJib2R5XCI6IFwie31cIixcbiAgICAgICAgICAgIFwibWV0aG9kXCI6IG1ldGhvZCxcbiAgICAgICAgICAgIFwibW9kZVwiOiBcImNvcnNcIlxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZ2V0Rm9ybWF0dGVkRGF0ZShmb3JtYXQgPSBcIntZfS17TX0te0R9e3N0fSB7aH1fe219e2FwfVwiLCBub3cgPSBudWxsKSB7XG4gICAgICAgIC8vIGUuZyAyMDEyLTA5LTA1dGggMDlfMDJBTSBCYXNlZCBvbiBodHRwczovL3d3dy53aWxsbWFzdGVyLmNvbS9saWJyYXJ5L2dlbmVyYXRvcnMvZGF0ZS1hbmQtdGltZS1mb3JtYXR0aW5nLnBocCB1c2luZyB7WX0te019LXtEfSB7aH1fe219e2FwfVxuICAgICAgICAvLyBsZXQgZm9ybWF0ID0gXCJ7WX0te019LXtEfXtzdH0ge2h9X3ttfXthcH1cIjtcbiAgICAgICAgbm93ID0gbm93IHx8IG5ldyBEYXRlKCk7IC8vIFRoaXMgY3VycmVudCBtaWxsaXNlY29uZCBvbiB1c2VyJ3MgY29tcHV0ZXIuXG4gICAgICAgIGxldCBNb250aCA9ICcnO1xuICAgICAgICBNb250aCA9IG5vdy5nZXRNb250aCgpICsgMTtcbiAgICAgICAgaWYgKE1vbnRoIDwgMTApIHtcbiAgICAgICAgICAgIE1vbnRoID0gXCIwXCIgKyBNb250aDtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgve019L2csIE1vbnRoKTtcblxuICAgICAgICAvLyBNb250aCBEYXlcbiAgICAgICAgbGV0IE1kYXkgPSAnJztcbiAgICAgICAgTWRheSA9IG5vdy5nZXREYXRlKCk7XG4gICAgICAgIGlmIChNZGF5IDwgMTApIHtcbiAgICAgICAgICAgIE1kYXkgPSBcIjBcIiArIE1kYXk7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL3tEfS9nLCBNZGF5KTtcblxuXG4gICAgICAgIC8vIFN0IGRheSBzdWZmaXggKE1pY2hhZWwgS3VibGVyJ3MgY3VzdG9tIGFkZGl0aW9uKVxuICAgICAgICAvLyBlLmcgMXN0LCAybmQsIDNyZCwgNHRoLCA1dGggLi4uXG4gICAgICAgIGxldCBzdCA9ICd0aCc7XG4gICAgICAgIGxldCBNZGF5U2luZ2xlID0gbm93LmdldERhdGUoKTtcbiAgICAgICAgaWYgKE1kYXlTaW5nbGUgPCA0KSB7XG4gICAgICAgICAgICBpZiAoTWRheVNpbmdsZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHN0ID0gJ3JkJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWRheVNpbmdsZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIHN0ID0gJ25kJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWRheVNpbmdsZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHN0ID0gJ3N0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgve3N0fS9nLCBzdCk7XG5cblxuICAgICAgICBsZXQgWWVhciA9ICcnO1xuICAgICAgICBZZWFyID0gbm93LmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC97WX0vZywgWWVhcik7XG4gICAgICAgIGxldCBoID0gbm93LmdldEhvdXJzKCk7XG4gICAgICAgIGxldCBhcCA9ICcnO1xuICAgICAgICBsZXQgcG0gPSAoaCA+IDExKTtcbiAgICAgICAgaWYgKGggPiAxMikge1xuICAgICAgICAgICAgaCAtPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBhcCA9IHBtID8gXCJQTVwiIDogXCJBTVwiO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgve2FwfS9nLCBhcCk7XG4gICAgICAgIGxldCBoaCA9ICcnO1xuICAgICAgICBpZiAoaCA8IDEwKSB7XG4gICAgICAgICAgICBoaCA9IFwiMFwiICsgaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhoID0gaDtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgve2h9L2csIGhoKTtcbiAgICAgICAgbGV0IG1tID0gJyc7XG4gICAgICAgIG1tID0gbm93LmdldE1pbnV0ZXMoKTtcbiAgICAgICAgaWYgKG1tIDwgMTApIHtcbiAgICAgICAgICAgIG1tID0gXCIwXCIgKyBtbTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgve219L2csIG1tKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvZmYgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM2NjI5ODAvNzI5OTM1MlxuICAgICAqIEBwYXJhbSBzdHJcbiAgICAgKiBAcmV0dXJucyB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICAgKi9cbiAgICBjcmVhdGVOZXdFbGVtZW50KCBzdHIgKSB7XG4gICAgICAgIGxldCBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlbGVtLmlubmVySFRNTCA9IHN0cjtcbiAgICAgICAgd2hpbGUgKGVsZW0uY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChlbGVtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnO1xuICAgIH1cblxufSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0FBS0E7OztBQWVBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQUtBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7Ozs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7O0FBREE7QUFDQTtBQUVBOzs7Ozs7QUFFQTtBQUNBOztBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTs7O0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/BlackBoxPlusInfo.js\n");

/***/ }),

/***/ "./src/export.js":
/*!***********************!*\
  !*** ./src/export.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _styles_less__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles.less */ \"./src/styles.less\");\n/* harmony import */ var _styles_less__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_less__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_BlackBoxPlusExport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/BlackBoxPlusExport */ \"./src/components/BlackBoxPlusExport.js\");\n/* harmony import */ var json_2_csv__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! json-2-csv */ \"./node_modules/json-2-csv/src/converter.js\");\n/* harmony import */ var json_2_csv__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(json_2_csv__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n // import BlackBoxPlusInfo from './components/blackBoxPlusInfo';\n// window.blackboxPlusInfo = new BlackBoxPlusInfo('Exporter');\n\n\n\nvar blackBoxPlusExport = new _components_BlackBoxPlusExport__WEBPACK_IMPORTED_MODULE_4__[\"default\"]('Data Exporter');\nwindow.blackBoxPlusExport = blackBoxPlusExport;\nconsole.debug(\"Configuring BlackBox Plus\");\nblackBoxPlusExport.setHeader('BB+ Exporter');\nblackBoxPlusExport.setStatusLoading('Initial Setup');\n\n_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(\n/*#__PURE__*/\n_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {\n  var linkhrefAndClassesJson, linkhrefAndClassesCsv, csvData, bbox_plus_download_workspace_items_contribute_csv_promise, bbox_plus_download_workspace_items_curation_csv_promise, bbox_plus_download_workspace_items_content_csv_promise, bbox_plus_download_financial_earnings_summary_csv_promise, bbox_plus_download_financial_summary_csv_promise, bbox_plus_download_financial_payment_history_csv_promise, bbox_plus_download_financial_total_earnings_report_csv_promise, bbox_plus_download_unpaid_earnings_csv_promise, dateFormat;\n  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (window.blackBoxPlusFootage) {\n            _context.next = 4;\n            break;\n          }\n\n          _context.next = 3;\n          return blackBoxPlusExport.getAllFootage();\n\n        case 3:\n          window.blackBoxPlusFootage = _context.sent;\n\n        case 4:\n          if (window.blackBoxPlusFinancials) {\n            _context.next = 8;\n            break;\n          }\n\n          _context.next = 7;\n          return blackBoxPlusExport.getAllFinancials();\n\n        case 7:\n          window.blackBoxPlusFinancials = _context.sent;\n\n        case 8:\n          blackBoxPlusExport.setStatusProcessing('the creation of CSV files'); // blackBoxPlusExport.addMessage('<h2>Footage data is: </h2><code>' + JSON.stringify(blackBoxPlusFootage) + `</code>`);\n\n          linkhrefAndClassesJson = \"href=\\\"#\\\" class=\\\"bbox_plus_download_link bbox_plus_download_json\\\"\";\n          linkhrefAndClassesCsv = \"href=\\\"#\\\" class=\\\"bbox_plus_download_link bbox_plus_download_csv\\\"\";\n          blackBoxPlusExport.setInterface(\"<h2>BlackBox Plus - Data Export</h2>\\n<p>Click the links below to download the:<br />\\n\".concat(blackBoxPlusFootage.contribute.length, \" Workspace Items as <a \").concat(linkhrefAndClassesJson, \" id=\\\"bbox_plus_download_workspace_items_contribute_json\\\">.json</a> as <a \").concat(linkhrefAndClassesCsv, \" id=\\\"bbox_plus_download_workspace_items_contribute_csv\\\">.csv</a><br />\\n\").concat(blackBoxPlusFootage.curation.length, \" Curation Items as <a \").concat(linkhrefAndClassesJson, \" id=\\\"bbox_plus_download_workspace_items_curation_json\\\">.json</a> as <a \").concat(linkhrefAndClassesCsv, \" id=\\\"bbox_plus_download_workspace_items_curation_csv\\\">.csv</a><br />\\n\").concat(blackBoxPlusFootage.content.length, \" Submitted Content Items as <a \").concat(linkhrefAndClassesJson, \" id=\\\"bbox_plus_download_workspace_items_content_json\\\">.json</a> as <a \").concat(linkhrefAndClassesCsv, \" id=\\\"bbox_plus_download_workspace_items_content_csv\\\">.csv</a><br />\\nOr All Footage Items as <a \").concat(linkhrefAndClassesJson, \" id=\\\"bbox_plus_download_workspace_items_all_json\\\">.json</a><br />\\n<br />\\n<h2>Financial Summary</h2>\\nEarnings Summary as <a \").concat(linkhrefAndClassesJson, \" id=\\\"bbox_plus_download_financial_earnings_summary_json\\\">.json</a> as <a \").concat(linkhrefAndClassesCsv, \" id=\\\"bbox_plus_download_financial_earnings_summary_csv\\\">.csv</a><br />\\nFinancial Summary as <a \").concat(linkhrefAndClassesJson, \" id=\\\"bbox_plus_download_financial_summary_json\\\">.json</a> as <a \").concat(linkhrefAndClassesCsv, \" id=\\\"bbox_plus_download_financial_summary_csv\\\">.csv</a><br />\\nFinancial Payment History as <a \").concat(linkhrefAndClassesJson, \" id=\\\"bbox_plus_download_financial_payment_history_json\\\">.json</a> as <a \").concat(linkhrefAndClassesCsv, \" id=\\\"bbox_plus_download_financial_payment_history_csv\\\">.csv</a><br />\\nFinancial Total Earnings Report as <a \").concat(linkhrefAndClassesJson, \" id=\\\"bbox_plus_download_financial_total_earnings_report_json\\\">.json</a> as <a \").concat(linkhrefAndClassesCsv, \" id=\\\"bbox_plus_download_financial_total_earnings_report_csv\\\">.csv</a><br />\\nUnpaid Earnings List (recently sold but not yet paid) as <a \").concat(linkhrefAndClassesJson, \" id=\\\"bbox_plus_download_unpaid_earnings_json\\\">.json</a> as <a \").concat(linkhrefAndClassesCsv, \" id=\\\"bbox_plus_download_unpaid_earnings_csv\\\">.csv</a><br />\\nOr All Financials as <a \").concat(linkhrefAndClassesJson, \" id=\\\"bbox_plus_download_financials_all_json\\\">.json</a><br />\\n\\n</p>\")); // ----------------------------------------------------------------------------\n          //   CSV\n          // ----------------------------------------------------------------------------\n\n          csvData = {\n            blackBoxPlusFootage: {},\n            blackBoxPlusFinancials: {}\n          }; // -- Footage\n\n          bbox_plus_download_workspace_items_contribute_csv_promise = Object(json_2_csv__WEBPACK_IMPORTED_MODULE_5__[\"json2csvAsync\"])(blackBoxPlusFootage.contribute, {\n            expandArrayObjects: true\n          }).then(function (data) {\n            csvData.blackBoxPlusFootage.contribute = data;\n          });\n          bbox_plus_download_workspace_items_curation_csv_promise = Object(json_2_csv__WEBPACK_IMPORTED_MODULE_5__[\"json2csvAsync\"])(blackBoxPlusFootage.curation, {\n            expandArrayObjects: true\n          }).then(function (data) {\n            csvData.blackBoxPlusFootage.curation = data;\n          });\n          bbox_plus_download_workspace_items_content_csv_promise = Object(json_2_csv__WEBPACK_IMPORTED_MODULE_5__[\"json2csvAsync\"])(blackBoxPlusFootage.content, {\n            expandArrayObjects: true\n          }).then(function (data) {\n            csvData.blackBoxPlusFootage.content = data;\n          }); // -- Financials\n\n          bbox_plus_download_financial_earnings_summary_csv_promise = Object(json_2_csv__WEBPACK_IMPORTED_MODULE_5__[\"json2csvAsync\"])(blackBoxPlusFinancials.financialEarningsSummary.items, {\n            expandArrayObjects: true\n          }).then(function (data) {\n            csvData.blackBoxPlusFinancials.financialEarningsSummary = data;\n          });\n          bbox_plus_download_financial_summary_csv_promise = Object(json_2_csv__WEBPACK_IMPORTED_MODULE_5__[\"json2csvAsync\"])(blackBoxPlusFinancials.financialSummaryInfo, {\n            expandArrayObjects: true\n          }).then(function (data) {\n            csvData.blackBoxPlusFinancials.financialSummaryInfo = data;\n          });\n          bbox_plus_download_financial_payment_history_csv_promise = Object(json_2_csv__WEBPACK_IMPORTED_MODULE_5__[\"json2csvAsync\"])(blackBoxPlusFinancials.financialPaymentHistory, {\n            expandArrayObjects: true\n          }).then(function (data) {\n            csvData.blackBoxPlusFinancials.financialPaymentHistory = data;\n          });\n          bbox_plus_download_financial_total_earnings_report_csv_promise = Object(json_2_csv__WEBPACK_IMPORTED_MODULE_5__[\"json2csvAsync\"])(blackBoxPlusFinancials.financialTotalEarningsReport, {\n            expandArrayObjects: true\n          }).then(function (data) {\n            csvData.blackBoxPlusFinancials.financialTotalEarningsReport = data;\n          });\n          bbox_plus_download_unpaid_earnings_csv_promise = Object(json_2_csv__WEBPACK_IMPORTED_MODULE_5__[\"json2csvAsync\"])(blackBoxPlusFinancials.unpaidEarnings.items, {\n            expandArrayObjects: true\n          }).then(function (data) {\n            csvData.blackBoxPlusFinancials.unpaidEarnings = data;\n          }); // bbox_plus_download_financial_earnings_summary_csv // process blackBoxPlusFinancials.financialEarningsSummary.items\n          // bbox_plus_download_financial_summary_csv // process blackBoxPlusFinancials.financialSummaryInfo\n          // bbox_plus_download_financial_payment_history_csv // process financialPaymentHistory\n          // bbox_plus_download_financial_total_earnings_report_csv // process financialTotalEarningsReport\n          // bbox_plus_download_unpaid_earnings_csv // process blackBoxPlusFinancials.unpaidEarnings.items\n          // Wait for the CSV file processing to be completed\n\n          _context.next = 23;\n          return Promise.all([bbox_plus_download_workspace_items_contribute_csv_promise, bbox_plus_download_workspace_items_curation_csv_promise, bbox_plus_download_workspace_items_content_csv_promise, bbox_plus_download_financial_earnings_summary_csv_promise, bbox_plus_download_financial_summary_csv_promise, bbox_plus_download_financial_payment_history_csv_promise, bbox_plus_download_financial_total_earnings_report_csv_promise, bbox_plus_download_unpaid_earnings_csv_promise]);\n\n        case 23:\n          console.debug('csvData char length is ', JSON.stringify(csvData).length);\n          dateFormat = blackBoxPlusExport.getFormattedDate(); // e.g 2012-09-05th 09:02AM Based on https://www.willmaster.com/library/generators/date-and-time-formatting.php using {Y}-{M}-{D}{st} {h}:{m}{ap}\n          // Footage\n\n          blackBoxPlusExport.makeLinkElementDownloadCsv($('#bbox_plus_download_workspace_items_contribute_csv')[0], csvData.blackBoxPlusFootage.contribute, \"\".concat(dateFormat, \" BlackBox Footage - Contribute Workspace Items\"));\n          blackBoxPlusExport.makeLinkElementDownloadCsv($('#bbox_plus_download_workspace_items_curation_csv')[0], csvData.blackBoxPlusFootage.curation, \"\".concat(dateFormat, \" BlackBox Footage - Curation Items\"));\n          blackBoxPlusExport.makeLinkElementDownloadCsv($('#bbox_plus_download_workspace_items_content_csv')[0], csvData.blackBoxPlusFootage.content, \"\".concat(dateFormat, \" BlackBox Footage - Processed Submitted Items\")); // Finances\n\n          blackBoxPlusExport.makeLinkElementDownloadCsv($('#bbox_plus_download_financial_earnings_summary_csv')[0], csvData.blackBoxPlusFinancials.financialEarningsSummary, \"\".concat(dateFormat, \" BlackBox Financials Earnings Summary\"));\n          blackBoxPlusExport.makeLinkElementDownloadCsv($('#bbox_plus_download_financial_summary_csv')[0], csvData.blackBoxPlusFinancials.financialSummaryInfo, \"\".concat(dateFormat, \" BlackBox Financials Summary Info\"));\n          blackBoxPlusExport.makeLinkElementDownloadCsv($('#bbox_plus_download_financial_payment_history_csv')[0], csvData.blackBoxPlusFinancials.financialPaymentHistory, \"\".concat(dateFormat, \" BlackBox Financials Payment History\"));\n          blackBoxPlusExport.makeLinkElementDownloadCsv($('#bbox_plus_download_financial_total_earnings_report_csv')[0], csvData.blackBoxPlusFinancials.financialTotalEarningsReport, \"\".concat(dateFormat, \" BlackBox Financials Total Earnings Report\"));\n          blackBoxPlusExport.makeLinkElementDownloadCsv($('#bbox_plus_download_unpaid_earnings_csv')[0], csvData.blackBoxPlusFinancials.unpaidEarnings, \"\".concat(dateFormat, \" BlackBox Financials Unpaid Earnings\")); // ----------------------------------------------------------------------------\n          //   JSON\n          // ----------------------------------------------------------------------------\n\n          blackBoxPlusExport.makeLinkElementDownloadJson($('#bbox_plus_download_workspace_items_contribute_json')[0], blackBoxPlusFootage.contribute, \"\".concat(dateFormat, \" BlackBox Contribute Workspace Items\"));\n          blackBoxPlusExport.makeLinkElementDownloadJson($('#bbox_plus_download_workspace_items_curation_json')[0], blackBoxPlusFootage.curation, \"\".concat(dateFormat, \" BlackBox Curation Items\"));\n          blackBoxPlusExport.makeLinkElementDownloadJson($('#bbox_plus_download_workspace_items_content_json')[0], blackBoxPlusFootage.content, \"\".concat(dateFormat, \" BlackBox Content Items\"));\n          blackBoxPlusExport.makeLinkElementDownloadJson($('#bbox_plus_download_workspace_items_all_json')[0], blackBoxPlusFootage, \"\".concat(dateFormat, \" BlackBox All Footage Items\"));\n          blackBoxPlusExport.makeLinkElementDownloadJson($('#bbox_plus_download_financial_earnings_summary_json')[0], blackBoxPlusFinancials.financialEarningsSummary, \"\".concat(dateFormat, \" BlackBox Financial Earnings Summary Info\"));\n          blackBoxPlusExport.makeLinkElementDownloadJson($('#bbox_plus_download_financial_summary_json')[0], blackBoxPlusFinancials.financialSummaryInfo, \"\".concat(dateFormat, \" BlackBox Financial Summary Info\"));\n          blackBoxPlusExport.makeLinkElementDownloadJson($('#bbox_plus_download_financial_payment_history_json')[0], blackBoxPlusFinancials.financialPaymentHistory, \"\".concat(dateFormat, \" BlackBox Financial Payment History\"));\n          blackBoxPlusExport.makeLinkElementDownloadJson($('#bbox_plus_download_financial_total_earnings_report_json')[0], blackBoxPlusFinancials.financialTotalEarningsReport, \"\".concat(dateFormat, \" BlackBox Financial Total Earnings Report\"));\n          blackBoxPlusExport.makeLinkElementDownloadJson($('#bbox_plus_download_unpaid_earnings_json')[0], blackBoxPlusFinancials.unpaidEarnings, \"\".concat(dateFormat, \" BlackBox Financial Unpaid Earnings Summary Info\"));\n          blackBoxPlusExport.makeLinkElementDownloadJson($('#bbox_plus_download_financials_all_json')[0], blackBoxPlusFinancials, \"\".concat(dateFormat, \" BlackBox All Financials\"));\n          blackBoxPlusExport.setStatusDone(\"<span onClick=\\\"window.scrollTo(0,document.body.scrollHeight);\\\">View the links in the footer</span>\");\n          scrollTo(0, document.body.scrollHeight); // If we want to Dedupe the contents, best option seems to be doing it based on footageId?\n          // https://wsvincent.com/javascript-remove-duplicates-array/\n          // let footageIds = blackBoxPlusFootage.content.map(function (footage) {\n          //     return footage.footageId;\n          // });\n          // let uniqueFootageIds = [...new Set(footageIds)];\n\n        case 45:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n}))();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZXhwb3J0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2V4cG9ydC5qcz8yNzVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4vc3R5bGVzLmxlc3NcIjtcclxuaW1wb3J0IFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lXCI7XHJcbi8vIGltcG9ydCBCbGFja0JveFBsdXNJbmZvIGZyb20gJy4vY29tcG9uZW50cy9ibGFja0JveFBsdXNJbmZvJztcclxuLy8gd2luZG93LmJsYWNrYm94UGx1c0luZm8gPSBuZXcgQmxhY2tCb3hQbHVzSW5mbygnRXhwb3J0ZXInKTtcclxuaW1wb3J0IEJsYWNrQm94UGx1c0V4cG9ydCBmcm9tICcuL2NvbXBvbmVudHMvQmxhY2tCb3hQbHVzRXhwb3J0JztcclxuaW1wb3J0IHtqc29uMmNzdkFzeW5jfSBmcm9tICdqc29uLTItY3N2JztcclxuXHJcbnZhciBibGFja0JveFBsdXNFeHBvcnQgPSBuZXcgQmxhY2tCb3hQbHVzRXhwb3J0KCdEYXRhIEV4cG9ydGVyJyk7XHJcbndpbmRvdy5ibGFja0JveFBsdXNFeHBvcnQgPSBibGFja0JveFBsdXNFeHBvcnQ7XHJcblxyXG5jb25zb2xlLmRlYnVnKFwiQ29uZmlndXJpbmcgQmxhY2tCb3ggUGx1c1wiKTtcclxuYmxhY2tCb3hQbHVzRXhwb3J0LnNldEhlYWRlcignQkIrIEV4cG9ydGVyJyk7XHJcbmJsYWNrQm94UGx1c0V4cG9ydC5zZXRTdGF0dXNMb2FkaW5nKCdJbml0aWFsIFNldHVwJyk7XHJcblxyXG4oYXN5bmMgKCkgPT4ge1xyXG5cclxuXHJcbiAgICBpZiAoIXdpbmRvdy5ibGFja0JveFBsdXNGb290YWdlKSB7XHJcbiAgICAgICAgd2luZG93LmJsYWNrQm94UGx1c0Zvb3RhZ2UgPSBhd2FpdCBibGFja0JveFBsdXNFeHBvcnQuZ2V0QWxsRm9vdGFnZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKCF3aW5kb3cuYmxhY2tCb3hQbHVzRmluYW5jaWFscykge1xyXG4gICAgICAgIHdpbmRvdy5ibGFja0JveFBsdXNGaW5hbmNpYWxzID0gYXdhaXQgYmxhY2tCb3hQbHVzRXhwb3J0LmdldEFsbEZpbmFuY2lhbHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBibGFja0JveFBsdXNFeHBvcnQuc2V0U3RhdHVzUHJvY2Vzc2luZygndGhlIGNyZWF0aW9uIG9mIENTViBmaWxlcycpO1xyXG4gICAgLy8gYmxhY2tCb3hQbHVzRXhwb3J0LmFkZE1lc3NhZ2UoJzxoMj5Gb290YWdlIGRhdGEgaXM6IDwvaDI+PGNvZGU+JyArIEpTT04uc3RyaW5naWZ5KGJsYWNrQm94UGx1c0Zvb3RhZ2UpICsgYDwvY29kZT5gKTtcclxuICAgIGxldCBsaW5raHJlZkFuZENsYXNzZXNKc29uID0gYGhyZWY9XCIjXCIgY2xhc3M9XCJiYm94X3BsdXNfZG93bmxvYWRfbGluayBiYm94X3BsdXNfZG93bmxvYWRfanNvblwiYDtcclxuICAgIGxldCBsaW5raHJlZkFuZENsYXNzZXNDc3YgPSBgaHJlZj1cIiNcIiBjbGFzcz1cImJib3hfcGx1c19kb3dubG9hZF9saW5rIGJib3hfcGx1c19kb3dubG9hZF9jc3ZcImA7XHJcbiAgICBibGFja0JveFBsdXNFeHBvcnQuc2V0SW50ZXJmYWNlKGA8aDI+QmxhY2tCb3ggUGx1cyAtIERhdGEgRXhwb3J0PC9oMj5cclxuPHA+Q2xpY2sgdGhlIGxpbmtzIGJlbG93IHRvIGRvd25sb2FkIHRoZTo8YnIgLz5cclxuJHtibGFja0JveFBsdXNGb290YWdlLmNvbnRyaWJ1dGUubGVuZ3RofSBXb3Jrc3BhY2UgSXRlbXMgYXMgPGEgJHtsaW5raHJlZkFuZENsYXNzZXNKc29ufSBpZD1cImJib3hfcGx1c19kb3dubG9hZF93b3Jrc3BhY2VfaXRlbXNfY29udHJpYnV0ZV9qc29uXCI+Lmpzb248L2E+IGFzIDxhICR7bGlua2hyZWZBbmRDbGFzc2VzQ3N2fSBpZD1cImJib3hfcGx1c19kb3dubG9hZF93b3Jrc3BhY2VfaXRlbXNfY29udHJpYnV0ZV9jc3ZcIj4uY3N2PC9hPjxiciAvPlxyXG4ke2JsYWNrQm94UGx1c0Zvb3RhZ2UuY3VyYXRpb24ubGVuZ3RofSBDdXJhdGlvbiBJdGVtcyBhcyA8YSAke2xpbmtocmVmQW5kQ2xhc3Nlc0pzb259IGlkPVwiYmJveF9wbHVzX2Rvd25sb2FkX3dvcmtzcGFjZV9pdGVtc19jdXJhdGlvbl9qc29uXCI+Lmpzb248L2E+IGFzIDxhICR7bGlua2hyZWZBbmRDbGFzc2VzQ3N2fSBpZD1cImJib3hfcGx1c19kb3dubG9hZF93b3Jrc3BhY2VfaXRlbXNfY3VyYXRpb25fY3N2XCI+LmNzdjwvYT48YnIgLz5cclxuJHtibGFja0JveFBsdXNGb290YWdlLmNvbnRlbnQubGVuZ3RofSBTdWJtaXR0ZWQgQ29udGVudCBJdGVtcyBhcyA8YSAke2xpbmtocmVmQW5kQ2xhc3Nlc0pzb259IGlkPVwiYmJveF9wbHVzX2Rvd25sb2FkX3dvcmtzcGFjZV9pdGVtc19jb250ZW50X2pzb25cIj4uanNvbjwvYT4gYXMgPGEgJHtsaW5raHJlZkFuZENsYXNzZXNDc3Z9IGlkPVwiYmJveF9wbHVzX2Rvd25sb2FkX3dvcmtzcGFjZV9pdGVtc19jb250ZW50X2NzdlwiPi5jc3Y8L2E+PGJyIC8+XHJcbk9yIEFsbCBGb290YWdlIEl0ZW1zIGFzIDxhICR7bGlua2hyZWZBbmRDbGFzc2VzSnNvbn0gaWQ9XCJiYm94X3BsdXNfZG93bmxvYWRfd29ya3NwYWNlX2l0ZW1zX2FsbF9qc29uXCI+Lmpzb248L2E+PGJyIC8+XHJcbjxiciAvPlxyXG48aDI+RmluYW5jaWFsIFN1bW1hcnk8L2gyPlxyXG5FYXJuaW5ncyBTdW1tYXJ5IGFzIDxhICR7bGlua2hyZWZBbmRDbGFzc2VzSnNvbn0gaWQ9XCJiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsX2Vhcm5pbmdzX3N1bW1hcnlfanNvblwiPi5qc29uPC9hPiBhcyA8YSAke2xpbmtocmVmQW5kQ2xhc3Nlc0Nzdn0gaWQ9XCJiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsX2Vhcm5pbmdzX3N1bW1hcnlfY3N2XCI+LmNzdjwvYT48YnIgLz5cclxuRmluYW5jaWFsIFN1bW1hcnkgYXMgPGEgJHtsaW5raHJlZkFuZENsYXNzZXNKc29ufSBpZD1cImJib3hfcGx1c19kb3dubG9hZF9maW5hbmNpYWxfc3VtbWFyeV9qc29uXCI+Lmpzb248L2E+IGFzIDxhICR7bGlua2hyZWZBbmRDbGFzc2VzQ3N2fSBpZD1cImJib3hfcGx1c19kb3dubG9hZF9maW5hbmNpYWxfc3VtbWFyeV9jc3ZcIj4uY3N2PC9hPjxiciAvPlxyXG5GaW5hbmNpYWwgUGF5bWVudCBIaXN0b3J5IGFzIDxhICR7bGlua2hyZWZBbmRDbGFzc2VzSnNvbn0gaWQ9XCJiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsX3BheW1lbnRfaGlzdG9yeV9qc29uXCI+Lmpzb248L2E+IGFzIDxhICR7bGlua2hyZWZBbmRDbGFzc2VzQ3N2fSBpZD1cImJib3hfcGx1c19kb3dubG9hZF9maW5hbmNpYWxfcGF5bWVudF9oaXN0b3J5X2NzdlwiPi5jc3Y8L2E+PGJyIC8+XHJcbkZpbmFuY2lhbCBUb3RhbCBFYXJuaW5ncyBSZXBvcnQgYXMgPGEgJHtsaW5raHJlZkFuZENsYXNzZXNKc29ufSBpZD1cImJib3hfcGx1c19kb3dubG9hZF9maW5hbmNpYWxfdG90YWxfZWFybmluZ3NfcmVwb3J0X2pzb25cIj4uanNvbjwvYT4gYXMgPGEgJHtsaW5raHJlZkFuZENsYXNzZXNDc3Z9IGlkPVwiYmJveF9wbHVzX2Rvd25sb2FkX2ZpbmFuY2lhbF90b3RhbF9lYXJuaW5nc19yZXBvcnRfY3N2XCI+LmNzdjwvYT48YnIgLz5cclxuVW5wYWlkIEVhcm5pbmdzIExpc3QgKHJlY2VudGx5IHNvbGQgYnV0IG5vdCB5ZXQgcGFpZCkgYXMgPGEgJHtsaW5raHJlZkFuZENsYXNzZXNKc29ufSBpZD1cImJib3hfcGx1c19kb3dubG9hZF91bnBhaWRfZWFybmluZ3NfanNvblwiPi5qc29uPC9hPiBhcyA8YSAke2xpbmtocmVmQW5kQ2xhc3Nlc0Nzdn0gaWQ9XCJiYm94X3BsdXNfZG93bmxvYWRfdW5wYWlkX2Vhcm5pbmdzX2NzdlwiPi5jc3Y8L2E+PGJyIC8+XHJcbk9yIEFsbCBGaW5hbmNpYWxzIGFzIDxhICR7bGlua2hyZWZBbmRDbGFzc2VzSnNvbn0gaWQ9XCJiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsc19hbGxfanNvblwiPi5qc29uPC9hPjxiciAvPlxyXG5cclxuPC9wPmApO1xyXG5cclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyAgIENTVlxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgbGV0IGNzdkRhdGEgPSB7YmxhY2tCb3hQbHVzRm9vdGFnZToge30sIGJsYWNrQm94UGx1c0ZpbmFuY2lhbHM6IHt9fTtcclxuICAgIC8vIC0tIEZvb3RhZ2VcclxuICAgIGxldCBiYm94X3BsdXNfZG93bmxvYWRfd29ya3NwYWNlX2l0ZW1zX2NvbnRyaWJ1dGVfY3N2X3Byb21pc2UgPSBqc29uMmNzdkFzeW5jKGJsYWNrQm94UGx1c0Zvb3RhZ2UuY29udHJpYnV0ZSwge2V4cGFuZEFycmF5T2JqZWN0czogdHJ1ZX0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICBjc3ZEYXRhLmJsYWNrQm94UGx1c0Zvb3RhZ2UuY29udHJpYnV0ZSA9IGRhdGE7XHJcbiAgICB9KTtcclxuICAgIGxldCBiYm94X3BsdXNfZG93bmxvYWRfd29ya3NwYWNlX2l0ZW1zX2N1cmF0aW9uX2Nzdl9wcm9taXNlID0ganNvbjJjc3ZBc3luYyhibGFja0JveFBsdXNGb290YWdlLmN1cmF0aW9uLCB7ZXhwYW5kQXJyYXlPYmplY3RzOiB0cnVlfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIGNzdkRhdGEuYmxhY2tCb3hQbHVzRm9vdGFnZS5jdXJhdGlvbiA9IGRhdGE7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgYmJveF9wbHVzX2Rvd25sb2FkX3dvcmtzcGFjZV9pdGVtc19jb250ZW50X2Nzdl9wcm9taXNlID0ganNvbjJjc3ZBc3luYyhibGFja0JveFBsdXNGb290YWdlLmNvbnRlbnQsIHtleHBhbmRBcnJheU9iamVjdHM6IHRydWV9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgY3N2RGF0YS5ibGFja0JveFBsdXNGb290YWdlLmNvbnRlbnQgPSBkYXRhO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gLS0gRmluYW5jaWFsc1xyXG4gICAgbGV0IGJib3hfcGx1c19kb3dubG9hZF9maW5hbmNpYWxfZWFybmluZ3Nfc3VtbWFyeV9jc3ZfcHJvbWlzZSA9IGpzb24yY3N2QXN5bmMoYmxhY2tCb3hQbHVzRmluYW5jaWFscy5maW5hbmNpYWxFYXJuaW5nc1N1bW1hcnkuaXRlbXMsIHtleHBhbmRBcnJheU9iamVjdHM6IHRydWV9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgY3N2RGF0YS5ibGFja0JveFBsdXNGaW5hbmNpYWxzLmZpbmFuY2lhbEVhcm5pbmdzU3VtbWFyeSA9IGRhdGE7XHJcbiAgICB9KTtcclxuICAgIGxldCBiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsX3N1bW1hcnlfY3N2X3Byb21pc2UgPSBqc29uMmNzdkFzeW5jKGJsYWNrQm94UGx1c0ZpbmFuY2lhbHMuZmluYW5jaWFsU3VtbWFyeUluZm8sIHtleHBhbmRBcnJheU9iamVjdHM6IHRydWV9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgY3N2RGF0YS5ibGFja0JveFBsdXNGaW5hbmNpYWxzLmZpbmFuY2lhbFN1bW1hcnlJbmZvID0gZGF0YTtcclxuICAgIH0pO1xyXG4gICAgbGV0IGJib3hfcGx1c19kb3dubG9hZF9maW5hbmNpYWxfcGF5bWVudF9oaXN0b3J5X2Nzdl9wcm9taXNlID0ganNvbjJjc3ZBc3luYyhibGFja0JveFBsdXNGaW5hbmNpYWxzLmZpbmFuY2lhbFBheW1lbnRIaXN0b3J5LCB7ZXhwYW5kQXJyYXlPYmplY3RzOiB0cnVlfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIGNzdkRhdGEuYmxhY2tCb3hQbHVzRmluYW5jaWFscy5maW5hbmNpYWxQYXltZW50SGlzdG9yeSA9IGRhdGE7XHJcbiAgICB9KTtcclxuICAgIGxldCBiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsX3RvdGFsX2Vhcm5pbmdzX3JlcG9ydF9jc3ZfcHJvbWlzZSA9IGpzb24yY3N2QXN5bmMoYmxhY2tCb3hQbHVzRmluYW5jaWFscy5maW5hbmNpYWxUb3RhbEVhcm5pbmdzUmVwb3J0LCB7ZXhwYW5kQXJyYXlPYmplY3RzOiB0cnVlfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIGNzdkRhdGEuYmxhY2tCb3hQbHVzRmluYW5jaWFscy5maW5hbmNpYWxUb3RhbEVhcm5pbmdzUmVwb3J0ID0gZGF0YTtcclxuICAgIH0pO1xyXG4gICAgbGV0IGJib3hfcGx1c19kb3dubG9hZF91bnBhaWRfZWFybmluZ3NfY3N2X3Byb21pc2UgPSBqc29uMmNzdkFzeW5jKGJsYWNrQm94UGx1c0ZpbmFuY2lhbHMudW5wYWlkRWFybmluZ3MuaXRlbXMsIHtleHBhbmRBcnJheU9iamVjdHM6IHRydWV9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgY3N2RGF0YS5ibGFja0JveFBsdXNGaW5hbmNpYWxzLnVucGFpZEVhcm5pbmdzID0gZGF0YTtcclxuICAgIH0pO1xyXG4gICAgLy8gYmJveF9wbHVzX2Rvd25sb2FkX2ZpbmFuY2lhbF9lYXJuaW5nc19zdW1tYXJ5X2NzdiAvLyBwcm9jZXNzIGJsYWNrQm94UGx1c0ZpbmFuY2lhbHMuZmluYW5jaWFsRWFybmluZ3NTdW1tYXJ5Lml0ZW1zXHJcbiAgICAvLyBiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsX3N1bW1hcnlfY3N2IC8vIHByb2Nlc3MgYmxhY2tCb3hQbHVzRmluYW5jaWFscy5maW5hbmNpYWxTdW1tYXJ5SW5mb1xyXG4gICAgLy8gYmJveF9wbHVzX2Rvd25sb2FkX2ZpbmFuY2lhbF9wYXltZW50X2hpc3RvcnlfY3N2IC8vIHByb2Nlc3MgZmluYW5jaWFsUGF5bWVudEhpc3RvcnlcclxuICAgIC8vIGJib3hfcGx1c19kb3dubG9hZF9maW5hbmNpYWxfdG90YWxfZWFybmluZ3NfcmVwb3J0X2NzdiAvLyBwcm9jZXNzIGZpbmFuY2lhbFRvdGFsRWFybmluZ3NSZXBvcnRcclxuICAgIC8vIGJib3hfcGx1c19kb3dubG9hZF91bnBhaWRfZWFybmluZ3NfY3N2IC8vIHByb2Nlc3MgYmxhY2tCb3hQbHVzRmluYW5jaWFscy51bnBhaWRFYXJuaW5ncy5pdGVtc1xyXG5cclxuXHJcbiAgICAvLyBXYWl0IGZvciB0aGUgQ1NWIGZpbGUgcHJvY2Vzc2luZyB0byBiZSBjb21wbGV0ZWRcclxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtiYm94X3BsdXNfZG93bmxvYWRfd29ya3NwYWNlX2l0ZW1zX2NvbnRyaWJ1dGVfY3N2X3Byb21pc2UsYmJveF9wbHVzX2Rvd25sb2FkX3dvcmtzcGFjZV9pdGVtc19jdXJhdGlvbl9jc3ZfcHJvbWlzZSwgIGJib3hfcGx1c19kb3dubG9hZF93b3Jrc3BhY2VfaXRlbXNfY29udGVudF9jc3ZfcHJvbWlzZSxcclxuICAgICAgICBiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsX2Vhcm5pbmdzX3N1bW1hcnlfY3N2X3Byb21pc2UsIGJib3hfcGx1c19kb3dubG9hZF9maW5hbmNpYWxfc3VtbWFyeV9jc3ZfcHJvbWlzZSwgYmJveF9wbHVzX2Rvd25sb2FkX2ZpbmFuY2lhbF9wYXltZW50X2hpc3RvcnlfY3N2X3Byb21pc2UsIGJib3hfcGx1c19kb3dubG9hZF9maW5hbmNpYWxfdG90YWxfZWFybmluZ3NfcmVwb3J0X2Nzdl9wcm9taXNlLCBiYm94X3BsdXNfZG93bmxvYWRfdW5wYWlkX2Vhcm5pbmdzX2Nzdl9wcm9taXNlXHJcbiAgICBdKTtcclxuICAgIGNvbnNvbGUuZGVidWcoJ2NzdkRhdGEgY2hhciBsZW5ndGggaXMgJywgSlNPTi5zdHJpbmdpZnkoY3N2RGF0YSkubGVuZ3RoKTtcclxuICAgIGxldCBkYXRlRm9ybWF0ID0gYmxhY2tCb3hQbHVzRXhwb3J0LmdldEZvcm1hdHRlZERhdGUoKTsgLy8gZS5nIDIwMTItMDktMDV0aCAwOTowMkFNIEJhc2VkIG9uIGh0dHBzOi8vd3d3LndpbGxtYXN0ZXIuY29tL2xpYnJhcnkvZ2VuZXJhdG9ycy9kYXRlLWFuZC10aW1lLWZvcm1hdHRpbmcucGhwIHVzaW5nIHtZfS17TX0te0R9e3N0fSB7aH06e219e2FwfVxyXG4gICAgLy8gRm9vdGFnZVxyXG4gICAgYmxhY2tCb3hQbHVzRXhwb3J0Lm1ha2VMaW5rRWxlbWVudERvd25sb2FkQ3N2KCQoJyNiYm94X3BsdXNfZG93bmxvYWRfd29ya3NwYWNlX2l0ZW1zX2NvbnRyaWJ1dGVfY3N2JylbMF0sIGNzdkRhdGEuYmxhY2tCb3hQbHVzRm9vdGFnZS5jb250cmlidXRlLCBgJHtkYXRlRm9ybWF0fSBCbGFja0JveCBGb290YWdlIC0gQ29udHJpYnV0ZSBXb3Jrc3BhY2UgSXRlbXNgKTtcclxuICAgIGJsYWNrQm94UGx1c0V4cG9ydC5tYWtlTGlua0VsZW1lbnREb3dubG9hZENzdigkKCcjYmJveF9wbHVzX2Rvd25sb2FkX3dvcmtzcGFjZV9pdGVtc19jdXJhdGlvbl9jc3YnKVswXSwgY3N2RGF0YS5ibGFja0JveFBsdXNGb290YWdlLmN1cmF0aW9uLCBgJHtkYXRlRm9ybWF0fSBCbGFja0JveCBGb290YWdlIC0gQ3VyYXRpb24gSXRlbXNgKTtcclxuICAgIGJsYWNrQm94UGx1c0V4cG9ydC5tYWtlTGlua0VsZW1lbnREb3dubG9hZENzdigkKCcjYmJveF9wbHVzX2Rvd25sb2FkX3dvcmtzcGFjZV9pdGVtc19jb250ZW50X2NzdicpWzBdLCBjc3ZEYXRhLmJsYWNrQm94UGx1c0Zvb3RhZ2UuY29udGVudCwgYCR7ZGF0ZUZvcm1hdH0gQmxhY2tCb3ggRm9vdGFnZSAtIFByb2Nlc3NlZCBTdWJtaXR0ZWQgSXRlbXNgKTtcclxuICAgIC8vIEZpbmFuY2VzXHJcbiAgICBibGFja0JveFBsdXNFeHBvcnQubWFrZUxpbmtFbGVtZW50RG93bmxvYWRDc3YoJCgnI2Jib3hfcGx1c19kb3dubG9hZF9maW5hbmNpYWxfZWFybmluZ3Nfc3VtbWFyeV9jc3YnKVswXSwgY3N2RGF0YS5ibGFja0JveFBsdXNGaW5hbmNpYWxzLmZpbmFuY2lhbEVhcm5pbmdzU3VtbWFyeSwgYCR7ZGF0ZUZvcm1hdH0gQmxhY2tCb3ggRmluYW5jaWFscyBFYXJuaW5ncyBTdW1tYXJ5YCk7XHJcbiAgICBibGFja0JveFBsdXNFeHBvcnQubWFrZUxpbmtFbGVtZW50RG93bmxvYWRDc3YoJCgnI2Jib3hfcGx1c19kb3dubG9hZF9maW5hbmNpYWxfc3VtbWFyeV9jc3YnKVswXSwgY3N2RGF0YS5ibGFja0JveFBsdXNGaW5hbmNpYWxzLmZpbmFuY2lhbFN1bW1hcnlJbmZvLCBgJHtkYXRlRm9ybWF0fSBCbGFja0JveCBGaW5hbmNpYWxzIFN1bW1hcnkgSW5mb2ApO1xyXG4gICAgYmxhY2tCb3hQbHVzRXhwb3J0Lm1ha2VMaW5rRWxlbWVudERvd25sb2FkQ3N2KCQoJyNiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsX3BheW1lbnRfaGlzdG9yeV9jc3YnKVswXSwgY3N2RGF0YS5ibGFja0JveFBsdXNGaW5hbmNpYWxzLmZpbmFuY2lhbFBheW1lbnRIaXN0b3J5LCBgJHtkYXRlRm9ybWF0fSBCbGFja0JveCBGaW5hbmNpYWxzIFBheW1lbnQgSGlzdG9yeWApO1xyXG4gICAgYmxhY2tCb3hQbHVzRXhwb3J0Lm1ha2VMaW5rRWxlbWVudERvd25sb2FkQ3N2KCQoJyNiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsX3RvdGFsX2Vhcm5pbmdzX3JlcG9ydF9jc3YnKVswXSwgY3N2RGF0YS5ibGFja0JveFBsdXNGaW5hbmNpYWxzLmZpbmFuY2lhbFRvdGFsRWFybmluZ3NSZXBvcnQsIGAke2RhdGVGb3JtYXR9IEJsYWNrQm94IEZpbmFuY2lhbHMgVG90YWwgRWFybmluZ3MgUmVwb3J0YCk7XHJcbiAgICBibGFja0JveFBsdXNFeHBvcnQubWFrZUxpbmtFbGVtZW50RG93bmxvYWRDc3YoJCgnI2Jib3hfcGx1c19kb3dubG9hZF91bnBhaWRfZWFybmluZ3NfY3N2JylbMF0sIGNzdkRhdGEuYmxhY2tCb3hQbHVzRmluYW5jaWFscy51bnBhaWRFYXJuaW5ncywgYCR7ZGF0ZUZvcm1hdH0gQmxhY2tCb3ggRmluYW5jaWFscyBVbnBhaWQgRWFybmluZ3NgKTtcclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyAgIEpTT05cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGJsYWNrQm94UGx1c0V4cG9ydC5tYWtlTGlua0VsZW1lbnREb3dubG9hZEpzb24oJCgnI2Jib3hfcGx1c19kb3dubG9hZF93b3Jrc3BhY2VfaXRlbXNfY29udHJpYnV0ZV9qc29uJylbMF0sIGJsYWNrQm94UGx1c0Zvb3RhZ2UuY29udHJpYnV0ZSwgYCR7ZGF0ZUZvcm1hdH0gQmxhY2tCb3ggQ29udHJpYnV0ZSBXb3Jrc3BhY2UgSXRlbXNgKTtcclxuICAgIGJsYWNrQm94UGx1c0V4cG9ydC5tYWtlTGlua0VsZW1lbnREb3dubG9hZEpzb24oJCgnI2Jib3hfcGx1c19kb3dubG9hZF93b3Jrc3BhY2VfaXRlbXNfY3VyYXRpb25fanNvbicpWzBdLCBibGFja0JveFBsdXNGb290YWdlLmN1cmF0aW9uLCBgJHtkYXRlRm9ybWF0fSBCbGFja0JveCBDdXJhdGlvbiBJdGVtc2ApO1xyXG4gICAgYmxhY2tCb3hQbHVzRXhwb3J0Lm1ha2VMaW5rRWxlbWVudERvd25sb2FkSnNvbigkKCcjYmJveF9wbHVzX2Rvd25sb2FkX3dvcmtzcGFjZV9pdGVtc19jb250ZW50X2pzb24nKVswXSwgYmxhY2tCb3hQbHVzRm9vdGFnZS5jb250ZW50LCBgJHtkYXRlRm9ybWF0fSBCbGFja0JveCBDb250ZW50IEl0ZW1zYCk7XHJcbiAgICBibGFja0JveFBsdXNFeHBvcnQubWFrZUxpbmtFbGVtZW50RG93bmxvYWRKc29uKCQoJyNiYm94X3BsdXNfZG93bmxvYWRfd29ya3NwYWNlX2l0ZW1zX2FsbF9qc29uJylbMF0sIGJsYWNrQm94UGx1c0Zvb3RhZ2UsIGAke2RhdGVGb3JtYXR9IEJsYWNrQm94IEFsbCBGb290YWdlIEl0ZW1zYCk7XHJcbiAgICBibGFja0JveFBsdXNFeHBvcnQubWFrZUxpbmtFbGVtZW50RG93bmxvYWRKc29uKCQoJyNiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsX2Vhcm5pbmdzX3N1bW1hcnlfanNvbicpWzBdLCBibGFja0JveFBsdXNGaW5hbmNpYWxzLmZpbmFuY2lhbEVhcm5pbmdzU3VtbWFyeSwgYCR7ZGF0ZUZvcm1hdH0gQmxhY2tCb3ggRmluYW5jaWFsIEVhcm5pbmdzIFN1bW1hcnkgSW5mb2ApO1xyXG4gICAgYmxhY2tCb3hQbHVzRXhwb3J0Lm1ha2VMaW5rRWxlbWVudERvd25sb2FkSnNvbigkKCcjYmJveF9wbHVzX2Rvd25sb2FkX2ZpbmFuY2lhbF9zdW1tYXJ5X2pzb24nKVswXSwgYmxhY2tCb3hQbHVzRmluYW5jaWFscy5maW5hbmNpYWxTdW1tYXJ5SW5mbywgYCR7ZGF0ZUZvcm1hdH0gQmxhY2tCb3ggRmluYW5jaWFsIFN1bW1hcnkgSW5mb2ApO1xyXG4gICAgYmxhY2tCb3hQbHVzRXhwb3J0Lm1ha2VMaW5rRWxlbWVudERvd25sb2FkSnNvbigkKCcjYmJveF9wbHVzX2Rvd25sb2FkX2ZpbmFuY2lhbF9wYXltZW50X2hpc3RvcnlfanNvbicpWzBdLCBibGFja0JveFBsdXNGaW5hbmNpYWxzLmZpbmFuY2lhbFBheW1lbnRIaXN0b3J5LCBgJHtkYXRlRm9ybWF0fSBCbGFja0JveCBGaW5hbmNpYWwgUGF5bWVudCBIaXN0b3J5YCk7XHJcbiAgICBibGFja0JveFBsdXNFeHBvcnQubWFrZUxpbmtFbGVtZW50RG93bmxvYWRKc29uKCQoJyNiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsX3RvdGFsX2Vhcm5pbmdzX3JlcG9ydF9qc29uJylbMF0sIGJsYWNrQm94UGx1c0ZpbmFuY2lhbHMuZmluYW5jaWFsVG90YWxFYXJuaW5nc1JlcG9ydCwgYCR7ZGF0ZUZvcm1hdH0gQmxhY2tCb3ggRmluYW5jaWFsIFRvdGFsIEVhcm5pbmdzIFJlcG9ydGApO1xyXG4gICAgYmxhY2tCb3hQbHVzRXhwb3J0Lm1ha2VMaW5rRWxlbWVudERvd25sb2FkSnNvbigkKCcjYmJveF9wbHVzX2Rvd25sb2FkX3VucGFpZF9lYXJuaW5nc19qc29uJylbMF0sIGJsYWNrQm94UGx1c0ZpbmFuY2lhbHMudW5wYWlkRWFybmluZ3MsIGAke2RhdGVGb3JtYXR9IEJsYWNrQm94IEZpbmFuY2lhbCBVbnBhaWQgRWFybmluZ3MgU3VtbWFyeSBJbmZvYCk7XHJcbiAgICBibGFja0JveFBsdXNFeHBvcnQubWFrZUxpbmtFbGVtZW50RG93bmxvYWRKc29uKCQoJyNiYm94X3BsdXNfZG93bmxvYWRfZmluYW5jaWFsc19hbGxfanNvbicpWzBdLCBibGFja0JveFBsdXNGaW5hbmNpYWxzLCBgJHtkYXRlRm9ybWF0fSBCbGFja0JveCBBbGwgRmluYW5jaWFsc2ApO1xyXG4gICAgYmxhY2tCb3hQbHVzRXhwb3J0LnNldFN0YXR1c0RvbmUoYDxzcGFuIG9uQ2xpY2s9XCJ3aW5kb3cuc2Nyb2xsVG8oMCxkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCk7XCI+VmlldyB0aGUgbGlua3MgaW4gdGhlIGZvb3Rlcjwvc3Bhbj5gKTtcclxuICAgIHNjcm9sbFRvKDAsIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0KTtcclxuXHJcbiAgICAvLyBJZiB3ZSB3YW50IHRvIERlZHVwZSB0aGUgY29udGVudHMsIGJlc3Qgb3B0aW9uIHNlZW1zIHRvIGJlIGRvaW5nIGl0IGJhc2VkIG9uIGZvb3RhZ2VJZD9cclxuICAgIC8vIGh0dHBzOi8vd3N2aW5jZW50LmNvbS9qYXZhc2NyaXB0LXJlbW92ZS1kdXBsaWNhdGVzLWFycmF5L1xyXG4gICAgLy8gbGV0IGZvb3RhZ2VJZHMgPSBibGFja0JveFBsdXNGb290YWdlLmNvbnRlbnQubWFwKGZ1bmN0aW9uIChmb290YWdlKSB7XHJcbiAgICAvLyAgICAgcmV0dXJuIGZvb3RhZ2UuZm9vdGFnZUlkO1xyXG4gICAgLy8gfSk7XHJcbiAgICAvLyBsZXQgdW5pcXVlRm9vdGFnZUlkcyA9IFsuLi5uZXcgU2V0KGZvb3RhZ2VJZHMpXTtcclxuXHJcbn0pKCk7XHJcblxyXG5cclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFPQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBeEVBO0FBQUE7QUFDQTtBQURBO0FBMkVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/export.js\n");

/***/ }),

/***/ "./src/styles.less":
/*!*************************!*\
  !*** ./src/styles.less ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!../node_modules/less-loader/dist/cjs.js!./styles.less */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/styles.less\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\nvar exported = content.locals ? content.locals : {};\n\n\n\nmodule.exports = exported;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzLmxlc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzLmxlc3M/ZGM4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlcy5sZXNzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG52YXIgZXhwb3J0ZWQgPSBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDoge307XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVkOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/styles.less\n");

/***/ })

/******/ });